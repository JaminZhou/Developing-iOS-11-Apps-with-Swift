1
00:00:00,401 --> 00:00:04,403
[MUSIC]

2
00:00:04,472 --> 00:00:09,340
斯坦福大学。 >>好吧，好吧，

3
00:00:09,409 --> 00:00:13,878
欢迎参加2017年秋季的CS193P讲座5。

4
00:00:13,947 --> 00:00:16,981
所以我要在这里开始几分钟

5
00:00:17,050 --> 00:00:19,818
只要再过几次Swift的小东西。

6
00:00:19,887 --> 00:00:21,786
这些实际上是在你的阅读任务

7
00:00:21,855 --> 00:00:25,090
本星期。所以我真的只是强调这些

8
00:00:25,158 --> 00:00:28,693
事情，那么我们今天就要深入到我们的主题

9
00:00:28,762 --> 00:00:33,098
这是视图，图纸，如何在iOS中进行自定义绘图。

10
00:00:33,166 --> 00:00:36,968
我将从一个巨大的演示开始，这是我唯一的一个演示

11
00:00:37,037 --> 00:00:40,872
今天可能会做的是我们MVC的模型。

12
00:00:40,940 --> 00:00:43,408
但是这会让我给你看一个枚举的例子，

13
00:00:43,477 --> 00:00:45,677
我们没有得到专注的工作。

14
00:00:45,746 --> 00:00:49,981
所以你只在理论上知道枚举，我们将实际上做

15
00:00:50,050 --> 00:00:53,918
枚举。好吧，让我们来做这些小事。

16
00:00:53,987 --> 00:00:56,455
其中之一是Swift中的错误处理。

17
00:00:56,523 --> 00:00:58,757
现在，很多时候你会遇到错误

18
00:00:58,825 --> 00:01:01,626
这将是那样的，可以预期的或

19
00:01:01,695 --> 00:01:04,596
预料。你知道，你在网络上做些什么

20
00:01:04,664 --> 00:01:06,131
可能有网络超时，

21
00:01:06,200 --> 00:01:07,599
这是一个正常的错误。

22
00:01:07,668 --> 00:01:10,135
如果你有这样的错误，你可能会有

23
00:01:10,204 --> 00:01:12,136
这个函数的一个参数和

24
00:01:12,205 --> 00:01:15,507
这个网络调用。也许甚至是一个闭包的调用

25
00:01:15,575 --> 00:01:19,177
你回来说，我发现这个有点期待的错误。

26
00:01:19,246 --> 00:01:22,513
但有时候你有错误，你不期望或

27
00:01:22,582 --> 00:01:25,783
这是一种罕见的，真正打乱了使用

28
00:01:25,852 --> 00:01:30,021
一个方法或其他。而在这种错误中，

29
00:01:30,090 --> 00:01:33,057
而不是必须有一个你的参数是一个错误

30
00:01:33,126 --> 00:01:35,927
处理程序或返回错误，或类似的东西。

31
00:01:35,996 --> 00:01:39,030
你可以做一些被称为抛出错误的东西。

32
00:01:39,099 --> 00:01:39,998
现在，在其他语言中，

33
00:01:40,067 --> 00:01:42,300
你可能会认为这就像提出例外或

34
00:01:42,369 --> 00:01:44,469
类似的东西。这有点简单了

35
00:01:44,537 --> 00:01:47,372
当你在Swift中设计时更优雅。这很简单

36
00:01:47,441 --> 00:01:50,174
这个，可能会出错的方法，好吧，

37
00:01:50,243 --> 00:01:53,578
一个重大的错误，将扰乱它在做什么，

38
00:01:53,647 --> 00:01:56,848
可以决定它抛出错误。你看到这些

39
00:01:56,917 --> 00:01:59,417
方法很清楚，因为当他们宣布的时候，他们会的

40
00:01:59,486 --> 00:02:03,555
最后把这个词扔出去。所以这个功能保存

41
00:02:03,623 --> 00:02:07,025
抛出。好的，如果出现错误，则会引发此错误。

42
00:02:07,094 --> 00:02:11,263
现在，当它向你抛出一个错误，你需要抓住它。

43
00:02:11,331 --> 00:02:12,998
好的，你会发现这个错误

44
00:02:13,066 --> 00:02:15,066
那么你可以看看它，并决定要做什么。所以

45
00:02:15,135 --> 00:02:18,036
你如何捕获抛出的错误？好，

46
00:02:18,105 --> 00:02:22,674
你可以通过把这个do catch结构放在你的

47
00:02:22,743 --> 00:02:27,345
调用可能抛出的方法。你说，尝试一下

48
00:02:27,414 --> 00:02:31,382
通话的前面。所以你会尝试这种方法

49
00:02:31,451 --> 00:02:34,552
它可能会抛出。但既然你已经把它放在里面了，

50
00:02:34,621 --> 00:02:37,322
抓住东西，你在那里看到的东西，你会去的

51
00:02:37,390 --> 00:02:40,292
赶上那个错误。好的，就这么简单。

52
00:02:40,361 --> 00:02:43,161
所以，抛出的任何方法都必须用try来调用。

53
00:02:43,229 --> 00:02:45,897
好吧，你必须让斯威夫特知道我明白这一点

54
00:02:45,966 --> 00:02:47,666
可以扔，所以我正在尝试。

55
00:02:47,734 --> 00:02:50,168
但它不一定要保持，抓住，

56
00:02:50,237 --> 00:02:53,638
我会在一秒钟内告诉你如何做到这一点，而不是捕捉。

57
00:02:53,707 --> 00:02:56,474
如果你想抓住，那么你这样做，赶上

58
00:02:56,543 --> 00:02:59,778
在抓住你注意到有绿色，让错误。

59
00:02:59,847 --> 00:03:02,914
好吧，那个小错误的东西，它只是一个局部变量。

60
00:03:02,983 --> 00:03:05,517
这就是你被抛到的东西，好吧，

61
00:03:05,585 --> 00:03:08,353
当它抛出一个错误。这将是

62
00:03:08,421 --> 00:03:12,190
实现协议错误的东西，但是

63
00:03:12,259 --> 00:03:14,259
实际上在协议中没有任何东西。

64
00:03:14,328 --> 00:03:17,262
它只是识别，只是输入这个错误。

65
00:03:17,330 --> 00:03:20,732
现在，在iOS的时候，错误会抛到你身上，

66
00:03:20,801 --> 00:03:23,234
几乎总是会有NSErrors。

67
00:03:23,303 --> 00:03:26,271
所以一个NSError只是一个类，它实现了错误

68
00:03:26,340 --> 00:03:29,741
议定书就是说，没有什么特别的。

69
00:03:29,810 --> 00:03:32,277
但NSError有很多不错的方法和变数，

70
00:03:32,346 --> 00:03:35,213
像错误代码，甚至是一个本地化的描述

71
00:03:35,282 --> 00:03:37,582
您可能会向用户展示的错误，

72
00:03:37,651 --> 00:03:40,752
例如。所以这种方式是如果你有一个功能

73
00:03:40,821 --> 00:03:41,686
保存抛出，

74
00:03:41,755 --> 00:03:44,155
你会去看它的文档和

75
00:03:44,224 --> 00:03:47,693
看看它可以抛出什么样的NSError的东西。它会抛出

76
00:03:47,761 --> 00:03:50,127
某些错误，如保存，保存也许是

77
00:03:50,196 --> 00:03:52,964
保存到数据库和磁盘已满，所以数据库

78
00:03:53,033 --> 00:03:55,333
无法保存，所以也许有一个错误代码

79
00:03:55,402 --> 00:03:58,169
磁盘满或任何。所以这就是你要做的

80
00:03:58,238 --> 00:04:00,906
捕捉抛出的错误和处理它，看看它，

81
00:04:00,974 --> 00:04:05,410
看看是什么，决定做什么。但是你可以说，

82
00:04:05,479 --> 00:04:09,814
尝试！，这是什么意思，试试这个和

83
00:04:09,883 --> 00:04:12,583
如果它引发我的应用程序崩溃。现在，

84
00:04:12,652 --> 00:04:15,887
你只会这样做，如果你100％确定，

85
00:04:15,956 --> 00:04:19,323
那东西不能扔在你的情况下

86
00:04:19,392 --> 00:04:22,627
在做，这是非常罕见的，所以我们很少try！

87
00:04:22,696 --> 00:04:27,365
但更好的一个，如果你不在乎的错误是try？

88
00:04:27,434 --> 00:04:32,370
所以try？，请尝试这个，如果它抛出，不要崩溃，

89
00:04:32,439 --> 00:04:36,441
但只是忽略了它投掷的事实。所以

90
00:04:36,510 --> 00:04:37,509
这有点像尝试和

91
00:04:37,578 --> 00:04:40,445
忽视。现在有趣的是，你可能正在调用

92
00:04:40,513 --> 00:04:44,382
一个返回值的函数。一个可以抛出的int。

93
00:04:44,451 --> 00:04:47,184
所以在这里我有我的错误倾向函数返回

94
00:04:47,253 --> 00:04:52,089
一个整数，好吧，如果我想尝试尝试一下呢？好，

95
00:04:52,158 --> 00:04:55,560
如果成功，我需要那个int回来。但如果失败了，

96
00:04:55,629 --> 00:05:00,198
我不能得到int回来。那么当你尝试时会发生什么？

97
00:05:00,266 --> 00:05:04,102
它本质上改变了函数的返回值

98
00:05:04,170 --> 00:05:07,405
成为该值的可选版本。所以

99
00:05:07,474 --> 00:05:09,974
如果你有一个容易出错的函数返回一个int和

100
00:05:10,043 --> 00:05:13,144
你试试？它，你让它等于什么，你知道，

101
00:05:13,213 --> 00:05:16,347
让x等于。这个x现在成为一个可选的int，

102
00:05:16,416 --> 00:05:19,117
因为如果它抛出，它会给你

103
00:05:19,185 --> 00:05:21,786
零。如果它不扔，你会得到正常的x值

104
00:05:21,855 --> 00:05:25,756
返回一个int的错误倾向函数返回。好的？

105
00:05:25,825 --> 00:05:28,426
所以这是错误处理。没有太多的方法

106
00:05:28,495 --> 00:05:31,596
那里扔iOS，偶尔在那里。你懂，

107
00:05:31,665 --> 00:05:33,965
你可能有一个典型的应用程序，也许你有三个

108
00:05:34,034 --> 00:05:36,601
其中四个，在某个地方。他们是相当罕见的，但是

109
00:05:36,670 --> 00:05:39,137
你必须知道如何处理它们。所以这些是方法

110
00:05:39,205 --> 00:05:43,708
处理它们。好的，我现在想回到Any。

111
00:05:43,777 --> 00:05:45,309
这种类型我们看到的任何

112
00:05:45,378 --> 00:05:49,113
NSAttributedString字典。还有一个叫做任何

113
00:05:49,182 --> 00:05:52,550
与Any完全相同的对象，它只是用于类

114
00:05:52,619 --> 00:05:55,820
只有对象是只有任何一个类。和

115
00:05:55,889 --> 00:05:58,856
我告诉过你，无论如何，你不知道它是什么类型的，

116
00:05:58,925 --> 00:06:02,360
它可以是任何类型。而且我们也知道那不是

117
00:06:02,428 --> 00:06:06,597
很swifty，而cuz Swift非常紧张。所以任何和

118
00:06:06,666 --> 00:06:09,601
AnyObject与Objective-C兼容。

119
00:06:09,670 --> 00:06:12,870
Objective-C有一个非常重要的称为ID的类型

120
00:06:12,939 --> 00:06:16,775
基本上是任何的，它是建立在所有的API。

121
00:06:16,843 --> 00:06:19,777
所以当Swift出现并尝试强制输入时，

122
00:06:19,846 --> 00:06:22,213
它必须有这一个让步。所以

123
00:06:22,281 --> 00:06:25,483
我们不会像我所说的那样使用我们自己的代码中的任何代码

124
00:06:25,552 --> 00:06:29,554
向后兼容。所以任何类型的变量都可以

125
00:06:29,622 --> 00:06:34,960
保持任何类型。结构，枚举，类，任何东西。

126
00:06:35,028 --> 00:06:39,096
而问题是，你不能发送任何消息

127
00:06:39,165 --> 00:06:42,600
任何类型的东西，因为你没有，在你的代码中，

128
00:06:42,669 --> 00:06:45,537
知道这是什么。好的？现在，Swift在封面下，

129
00:06:45,606 --> 00:06:48,172
可能知道它是什么，但是既然你输入了Any，

130
00:06:48,241 --> 00:06:51,042
假设你不想发送任何消息给它

131
00:06:51,110 --> 00:06:54,712
你不知道是什么那么，我们怎么样

132
00:06:54,781 --> 00:06:57,381
在Swift中处理这种情况，我们得到强类型

133
00:06:57,450 --> 00:06:59,250
语言，我们不能发送消息给任何。好，

134
00:06:59,318 --> 00:07:03,287
我们必须将其转换。现在，让我们来谈谈你在哪里

135
00:07:03,356 --> 00:07:06,391
会看到它，你已经看到它在NSAttributedString的情况下，

136
00:07:06,460 --> 00:07:08,159
对？那么，我们有那个字典。

137
00:07:08,228 --> 00:07:11,796
另一个地方你会看到它是方法的参数。所以

138
00:07:11,864 --> 00:07:13,364
这里是一个叫做“准备”的方法

139
00:07:13,433 --> 00:07:16,667
Segue。这是一个UIView控制器方法，对吗？

140
00:07:16,736 --> 00:07:18,069
你们都知道UIView控制器是什么？

141
00:07:18,137 --> 00:07:20,705
我们为了集中做了一个。和

142
00:07:20,774 --> 00:07:24,709
我谈到了我们什么时候做MVC，我们有多个MVC，

143
00:07:24,778 --> 00:07:28,246
他们拥有一个完整的屏幕。那么，我们有时从过渡

144
00:07:28,315 --> 00:07:31,682
一个MVC在一起，到另一个。而这准备继续，

145
00:07:31,751 --> 00:07:34,785
一个segue是从一个MVC到另一个的转换，这个

146
00:07:34,854 --> 00:07:38,490
在转换发生时在视图控件中被调用。好，

147
00:07:38,558 --> 00:07:41,993
其中的一个参数在那里最后是sender

148
00:07:42,062 --> 00:07:46,564
类型Any ?.好吧，可选的任何。这基本上是

149
00:07:46,633 --> 00:07:51,269
什么按钮导致这个MVC转移到一个新的MVC如此。

150
00:07:51,338 --> 00:07:54,072
所以这可能是一个按钮，发件人是

151
00:07:54,141 --> 00:07:56,608
它也可以发生，如果你点击表中的一行

152
00:07:56,676 --> 00:08:00,445
视图。所以这不是一个按钮，这是一个表视图。cell，

153
00:08:00,513 --> 00:08:02,980
好吧，或者可能发生在其他事情上。

154
00:08:03,049 --> 00:08:06,050
它甚至可能通过代码发生，在这种情况下，这是一个零。

155
00:08:06,119 --> 00:08:09,220
所以这就是为什么你需要任何权利，因为你是

156
00:08:09,288 --> 00:08:12,057
不知道它是一个按钮还是一个表格

157
00:08:12,125 --> 00:08:15,025
其他事情导致这件事情发生。所以

158
00:08:15,094 --> 00:08:19,097
你会看到它作为参数，一个非常罕见的功能

159
00:08:19,166 --> 00:08:23,201
像这样你可以在那里通过任何东西。但

160
00:08:23,270 --> 00:08:27,439
我们如何使用这个任何东西？好吧，让我们说

161
00:08:27,507 --> 00:08:30,241
一个按钮被传递到你的桌子上，我怎么知道它是什么

162
00:08:30,309 --> 00:08:33,310
是和它交谈，而所有这一切，当这是任何事情。

163
00:08:33,379 --> 00:08:37,816
好的，在我告诉你如何做之前，当然不要使用Any

164
00:08:37,884 --> 00:08:41,319
在这个过程中除了做向后兼容的调用

165
00:08:41,388 --> 00:08:44,823
APIs。你没有你自己的数据结构不会

166
00:08:44,892 --> 00:08:47,492
使用任何。有些人尝试使用任何时候

167
00:08:47,561 --> 00:08:49,561
他们基本上不知道如何设计一个数据结构，

168
00:08:49,630 --> 00:08:51,395
而他们就像是，我只是把它变成一个Any，

169
00:08:51,464 --> 00:08:52,396
任何和数组

170
00:08:52,465 --> 00:08:53,965
我会开始随便扔东西

171
00:08:54,034 --> 00:08:57,535
不，我们不这样做，好吧，那不是，Swift。好吧，

172
00:08:57,604 --> 00:09:01,039
所以现在我怎么使用任何。我必须将其转换为类型

173
00:09:01,107 --> 00:09:04,609
我知道，因为我不能发送任何消息或变数，

174
00:09:04,678 --> 00:09:07,011
我必须将其转换。我们转换它，

175
00:09:07,080 --> 00:09:09,847
用一个特殊的关键字和Swift调用，

176
00:09:09,916 --> 00:09:14,385
作为问号。而这只是试图

177
00:09:14,453 --> 00:09:18,056
将其转换为您指定的类型，如果不能，

178
00:09:18,124 --> 00:09:21,326
它返回一个零。这就是为什么它是问号。

179
00:09:21,394 --> 00:09:23,894
就这么简单。所以这里是一个例子，

180
00:09:23,963 --> 00:09:25,262
这里最好通过例子来学习。

181
00:09:25,331 --> 00:09:29,934
比方说，我有一个名为未知的变种，哪种类型的任何，所以

182
00:09:30,003 --> 00:09:32,237
我不知道是什么这可能是任何东西，

183
00:09:32,305 --> 00:09:36,941
我认为那个未知的东西可能是类型的，

184
00:09:37,009 --> 00:09:40,244
我的风格。我不确定，但我认为它可能会输入。

185
00:09:40,313 --> 00:09:44,982
所以我会说如果我可以让foo这个新的变量，

186
00:09:45,051 --> 00:09:50,055
等于未知的MyType。然后在那里，

187
00:09:50,123 --> 00:09:53,391
我可以发送邮件到MyType可以理解的foo，

188
00:09:53,460 --> 00:09:56,460
对？所以我只是将未知的转换成了

189
00:09:56,529 --> 00:10:00,565
一个新的MyType类型变量，如果可能的话使用as。

190
00:10:00,634 --> 00:10:02,567
你可以看到这很好，它像英文。

191
00:10:02,636 --> 00:10:05,703
如果我可以让foo等于未知的MyType，

192
00:10:05,772 --> 00:10:09,674
那么我将使用它作为MyType。就是这样了，

193
00:10:09,743 --> 00:10:12,844
这很简单，这就是我们如何访问任何。和

194
00:10:12,912 --> 00:10:15,413
如果不是，如果不知道是其他类型和

195
00:10:15,481 --> 00:10:17,381
不能被解释为MyType，

196
00:10:17,450 --> 00:10:20,217
那么这个花括号，那东西不会发生。

197
00:10:20,286 --> 00:10:22,253
你甚至可以说别的，还有其他的东西

198
00:10:22,322 --> 00:10:24,522
别的事情会发生，那也可以。

199
00:10:24,591 --> 00:10:27,258
现在这个As的铸造不仅仅是为了

200
00:10:27,327 --> 00:10:31,295
任何，我们也可以投其他的东西。为什么，为什么我们会

201
00:10:31,364 --> 00:10:35,533
曾经想投？那么一个经典的演员就是演员

202
00:10:35,601 --> 00:10:40,771
从变量类型转换到它的一个子类。所以

203
00:10:40,840 --> 00:10:44,409
让我们来看一个例子。所以在这里我有一个变量vc，

204
00:10:44,478 --> 00:10:48,612
非常重要的是它的UIViewController类型。

205
00:10:48,681 --> 00:10:51,916
换句话说就是iOS类，即UIViewController

206
00:10:51,985 --> 00:10:55,720
vc的类型现在我把它设置成等于创建

207
00:10:55,788 --> 00:10:59,357
我们来看一个ConcentrationViewController，它是一个子类

208
00:10:59,426 --> 00:11:03,294
比如说UIViewController。现在类型为vc，

209
00:11:03,362 --> 00:11:06,163
即使我分配给它一个ConcentrationViewController，

210
00:11:06,232 --> 00:11:08,432
该类型仍然是UIViewController

211
00:11:08,501 --> 00:11:10,567
ConcentrationViewController。这不是它的类型，

212
00:11:10,636 --> 00:11:13,938
它的类型是UIViewController。但这是一个法律声明，

213
00:11:14,007 --> 00:11:15,740
因为当然是一个ConcentrationViewController

214
00:11:15,808 --> 00:11:18,776
从UIViewController继承，那就是

215
00:11:18,845 --> 00:11:22,346
一个UIViewController。现在，如果我想发送flipCard，

216
00:11:22,415 --> 00:11:26,117
可以说这是在ConcentrationViewController中的一个方法，

217
00:11:26,186 --> 00:11:30,355
到VC我不能这样做。它甚至不会编译，为什么？

218
00:11:30,423 --> 00:11:32,790
因为vc是UIViewController的子类型，而且

219
00:11:32,859 --> 00:11:36,127
类UIViewController没有flipCard。

220
00:11:36,196 --> 00:11:38,596
ConcentrationViewController有它，但

221
00:11:38,664 --> 00:11:41,499
不是UIViewController。所以人们感到困惑

222
00:11:41,568 --> 00:11:43,668
这在我们谈论的时候有点像回来

223
00:11:43,737 --> 00:11:45,203
协议和我有事情要移动。

224
00:11:45,271 --> 00:11:47,805
它是可移动的，我在那里有一辆汽车

225
00:11:47,874 --> 00:11:50,675
我想让它换油，人们都喜欢，为什么不呢？

226
00:11:50,743 --> 00:11:53,978
那么，因为这个变量是可移动的，而且

227
00:11:54,047 --> 00:11:56,914
动不了如何换油，汽车呢。

228
00:11:56,983 --> 00:11:59,517
这是同样的东西，完全一样的东西

229
00:11:59,586 --> 00:12:02,954
只是继承而不是协议。所以

230
00:12:03,022 --> 00:12:05,623
如果我想发送flipCard到vc，怎么办？

231
00:12:05,691 --> 00:12:08,959
我会这样做吗？或者我可以用完全相同的方式投出任何东西？

232
00:12:09,028 --> 00:12:13,064
我可以说，如果我让一些新的变量叫做cvc，

233
00:12:13,133 --> 00:12:15,866
ConcentrationViewController等于vc

234
00:12:15,935 --> 00:12:18,202
作为ConentrationViewController。

235
00:12:18,271 --> 00:12:21,706
现在cvc是一个ConcentrationViewController，

236
00:12:21,775 --> 00:12:25,743
我可以发送它翻转卡。就像我对Any所做的一样，

237
00:12:25,812 --> 00:12:27,512
我正在检查是否有可能

238
00:12:27,580 --> 00:12:31,983
这个var被转换，在这种情况下被转换。

239
00:12:32,052 --> 00:12:35,086
这就是所谓的downcasted，这个东西的一个子类

240
00:12:35,155 --> 00:12:39,456
我可以和它的子类进行交互。一样

241
00:12:39,525 --> 00:12:42,026
在这里与协议发生，我们可以做同样的事情

242
00:12:42,095 --> 00:12:45,997
在可移动的汽车。我们可以有一个可移动的var和

243
00:12:46,066 --> 00:12:49,600
试着把它当作汽车。如果你成功了，

244
00:12:49,668 --> 00:12:52,803
那么我们可以发一个换油。但如果这是一个形状和

245
00:12:52,872 --> 00:12:54,939
那失败了，我们会返回零和

246
00:12:55,008 --> 00:12:57,074
我们将无法做到这一点。所以

247
00:12:57,143 --> 00:13:01,045
你会看到我们这样做铸造没有任何与任何，

248
00:13:01,113 --> 00:13:04,382
一些与任何，但很多时候只是铸造。

249
00:13:04,451 --> 00:13:07,985
因为我们有一些需要一些父类的功能

250
00:13:08,054 --> 00:13:10,588
我们把一个下来的子类传递给它。

251
00:13:10,657 --> 00:13:13,424
而且我们会放下来看看这个子类

252
00:13:13,493 --> 00:13:16,694
如果是这个子类，那么我们可以发送消息。

253
00:13:16,763 --> 00:13:17,762
好，就这样

254
00:13:17,831 --> 00:13:18,763
任何和Castings对象。

255
00:13:18,831 --> 00:13:21,566
在我们进入之前，我有最后一张幻灯片

256
00:13:21,634 --> 00:13:25,136
意见，只是其他四个有趣的类

257
00:13:25,205 --> 00:13:28,940
你应该了解基础。一个是NSObject。

258
00:13:29,009 --> 00:13:33,278
NSObject是所有类的根类

259
00:13:33,346 --> 00:13:37,649
Objective-C的。所有的东西像UIViewController，

260
00:13:37,717 --> 00:13:40,217
所有UI套件类，所有那些东西

261
00:13:40,286 --> 00:13:42,453
在Objective-C世界中开发的

262
00:13:42,521 --> 00:13:45,757
与Objective-C仍然兼容。他们的根类，

263
00:13:45,825 --> 00:13:48,726
他们最终从顶端继承的东西，

264
00:13:48,795 --> 00:13:52,964
是NSObject。在Swift中，不需要从子类继承

265
00:13:53,032 --> 00:13:58,169
NSObject，虽然有一些小的深奥的API

266
00:13:58,237 --> 00:14:00,938
要求你通过一个类，那就必须执行

267
00:14:01,006 --> 00:14:03,841
NSObject的。当我们到达时，我会向你解释，

268
00:14:03,910 --> 00:14:06,778
但通常你的Swift类，就像记得集中

269
00:14:06,846 --> 00:14:09,613
那个班，我们原来是这样做的。它没有继承

270
00:14:09,682 --> 00:14:11,949
NSObject的。它没有从任何东西继承。

271
00:14:12,018 --> 00:14:13,951
当它是一个类时，我们稍后将其转换为结构体。

272
00:14:14,020 --> 00:14:15,920
这在Swift中是完全合法的，

273
00:14:15,988 --> 00:14:17,722
这在Objective-C中是不正确的。

274
00:14:17,791 --> 00:14:20,958
在Objective-C中几乎所有的类都必须继承

275
00:14:21,027 --> 00:14:24,428
从NSObject，因为一些运行时被内置到

276
00:14:24,497 --> 00:14:27,832
这个类，而不是在实际的运行时间喜欢它

277
00:14:27,900 --> 00:14:31,302
是在Swift。好的，第二个有趣的课是NSNumber，

278
00:14:31,370 --> 00:14:34,605
在Objective-C中，当你实际上传递数字时

279
00:14:34,674 --> 00:14:36,140
通过他们与这个类。

280
00:14:36,209 --> 00:14:39,076
NSNumber，它是一个类，所以它是一个引用类型。

281
00:14:39,145 --> 00:14:42,480
你没有double和int类。

282
00:14:42,548 --> 00:14:45,683
Objective-C中有C中的double和int，但是

283
00:14:45,751 --> 00:14:48,819
你没有这个所以，如果你想传递一些东西

284
00:14:48,888 --> 00:14:51,789
以面向对象的方式，你必须通过这个NSNumnber。

285
00:14:51,857 --> 00:14:54,592
现在它可以表示任何类型的数字，浮点数

286
00:14:54,660 --> 00:14:57,695
数字，整数，任何东西。这是一种通用的

287
00:14:57,764 --> 00:15:00,831
号码持有人，甚至可以容纳一个布尔值在那里。

288
00:15:00,900 --> 00:15:04,469
现在真的很棒，是整个iOS的所有API

289
00:15:04,537 --> 00:15:07,872
需要一个NSNumber，并有很多，自动

290
00:15:07,941 --> 00:15:12,943
桥接到Swift类型。所以如果你有一个Objective-C的话

291
00:15:13,012 --> 00:15:15,980
基于API的API在某个地方需要一个数字

292
00:15:16,049 --> 00:15:19,383
一个论点，你可以在那里通过一个双。或者一个int，或者

293
00:15:19,452 --> 00:15:22,587
不管它在期待什么，不管它应该是什么。

294
00:15:22,656 --> 00:15:24,221
你甚至不知道，你甚至不知道，

295
00:15:24,290 --> 00:15:26,390
你甚至不会看到NSNumber，因为文档

296
00:15:26,459 --> 00:15:29,560
已经被转换，以显示你。

297
00:15:29,629 --> 00:15:32,129
类似的，当事情出来时，如果有事情发生

298
00:15:32,198 --> 00:15:33,798
作为一个NSNumber出来的API，

299
00:15:33,866 --> 00:15:36,534
你可以把它作为double或者int来处理，或者

300
00:15:36,603 --> 00:15:40,571
什么是合适的，它工作得很好。但我只是

301
00:15:40,640 --> 00:15:42,740
提到如果你看到它，想知道那是什么？

302
00:15:42,809 --> 00:15:45,710
这是旧的Objective-C通用号码持有人吗？

303
00:15:45,778 --> 00:15:47,645
很容易看到一个从双或者创建一个

304
00:15:47,714 --> 00:15:49,580
int通过使用初始化，对吧？

305
00:15:49,649 --> 00:15:52,482
NSNumbers子35.5，这会给你

306
00:15:52,551 --> 00:15:55,085
一个双倍35.5的NSNumber。

307
00:15:55,154 --> 00:15:58,189
你可以用数字来表示数值

308
00:15:58,258 --> 00:16:02,026
intValue，doubleValue，boolValue，他们会给你。

309
00:16:02,095 --> 00:16:05,563
Swift类型的double，int，bool或者

310
00:16:05,632 --> 00:16:08,932
随你。好，日期你们有些人已经知道了

311
00:16:09,001 --> 00:16:11,669
日期，因为你做了额外的信贷也许，在作业1

312
00:16:11,737 --> 00:16:14,939
或2.日期只是表示任何日期和时间的一种方式。

313
00:16:15,008 --> 00:16:17,842
你知道，在内部，我认为，

314
00:16:17,910 --> 00:16:21,712
像自1970年以来的秒数或类似的东西。

315
00:16:21,781 --> 00:16:24,281
这样做很好，即使很小也很棒

316
00:16:24,350 --> 00:16:27,384
因为日期包括了时间，

317
00:16:27,453 --> 00:16:30,655
小的你知道，亚毫秒时间。

318
00:16:30,723 --> 00:16:32,323
但是我只是想让你注意到日期

319
00:16:32,391 --> 00:16:34,925
其他类，如日历，

320
00:16:34,994 --> 00:16:38,129
DateFormatter，DateComponents。 DateComponents会给

321
00:16:38,198 --> 00:16:40,497
你喜欢月份和类似的东西。和

322
00:16:40,566 --> 00:16:44,034
为什么还有其他的类？那么因为日期，

323
00:16:44,103 --> 00:16:46,603
如果你要把它放在你的用户界面，你必须非常

324
00:16:46,672 --> 00:16:50,607
小心。在世界各地，日期代表非常，

325
00:16:50,676 --> 00:16:53,744
非常不同，这不仅仅是一个月的名字

326
00:16:53,813 --> 00:16:56,013
在不同的语言是不同的。

327
00:16:56,082 --> 00:17:00,651
这是其他地方，我们称他们在世界各地，

328
00:17:00,720 --> 00:17:03,521
使用完全不同的约会系统。甚至会

329
00:17:03,590 --> 00:17:07,191
与我们使用完全不同的日历。所以

330
00:17:07,260 --> 00:17:09,293
如果你要把日期放进去，你真的要小心了

331
00:17:09,361 --> 00:17:11,562
你的用户界面了解所有这些其他类。

332
00:17:11,630 --> 00:17:13,564
有大量的文件如何做到这一点。

333
00:17:13,632 --> 00:17:16,033
但是，这是额外的工作。现在，如果你只是使用日期

334
00:17:16,102 --> 00:17:17,835
内部喜欢跟踪如何

335
00:17:17,904 --> 00:17:21,338
长时间集中移动，或者设定游戏移动正在进行，

336
00:17:21,407 --> 00:17:24,208
显然你不需要任何其他的东西。和

337
00:17:24,276 --> 00:17:28,679
最后有数据。数据只是一小块，

338
00:17:28,748 --> 00:17:33,351
我们使用它在iOS API中传输大量数据。

339
00:17:33,419 --> 00:17:36,087
例如，如果我们从互联网上获得图像，

340
00:17:36,155 --> 00:17:39,323
从一些网址，它会作为一个大袋子进来。和

341
00:17:39,392 --> 00:17:40,858
我们有像UI图像类，

342
00:17:40,926 --> 00:17:42,293
我今天要谈的

343
00:17:42,362 --> 00:17:43,627
这可以看一下这个包

344
00:17:43,696 --> 00:17:46,697
说，这是jpeg数据，并从中产生一个图像。要么

345
00:17:46,765 --> 00:17:49,900
看一下一大堆，你知道我们有格式化程序

346
00:17:49,969 --> 00:17:54,004
看，并说这是JSON数据。很好，谁知道JSON是什么，

347
00:17:54,073 --> 00:17:55,439
举起你的手如果你听说过JSON，好吧，

348
00:17:55,508 --> 00:17:58,909
大。所以这是JSON数据，我们将其解释为JSON数据。所以

349
00:17:58,978 --> 00:18:00,577
这就是这个数据结构是什么，

350
00:18:00,646 --> 00:18:03,347
这只是一小袋，还有很多的方法

351
00:18:03,416 --> 00:18:07,117
将其转换成其他类型的东西。就这样，如此

352
00:18:07,186 --> 00:18:09,253
这就是我想提到的那些快速的事情。

353
00:18:09,321 --> 00:18:12,289
现在我们可以深入到今天的主要话题了

354
00:18:12,358 --> 00:18:15,392
一个非常酷的，这是意见。好，那么

355
00:18:15,461 --> 00:18:18,562
我不希望你对这个word视图感到困惑。

356
00:18:18,631 --> 00:18:21,966
我在两种情况下使用它。一个是MVC。

357
00:18:22,034 --> 00:18:26,003
其中一封信是V视图。这意味着

358
00:18:26,071 --> 00:18:30,107
你的控制器的通用小众的一堆。那个视图，

359
00:18:30,176 --> 00:18:33,377
大写V视图，包含了很多意见。

360
00:18:33,446 --> 00:18:37,381
我正在谈论的这些视图，以及这些视图

361
00:18:37,450 --> 00:18:41,652
视图，我的意思是iOS类UI视图的子类。所以

362
00:18:41,721 --> 00:18:44,588
这就是我们今天正在讨论的是这些视图，

363
00:18:44,657 --> 00:18:46,857
这些东西在MVC看来。为。。。道歉

364
00:18:46,926 --> 00:18:50,060
在那里的术语是相同的，但是相同的词，

365
00:18:50,129 --> 00:18:53,564
那里的意思有些不同。那么什么是一个视图？

366
00:18:53,633 --> 00:18:56,433
什么是UIView的子类？基本上就是这样

367
00:18:56,502 --> 00:18:59,703
在屏幕上定义坐标的矩形，

368
00:18:59,772 --> 00:19:00,637
一个坐标系。和

369
00:19:00,706 --> 00:19:02,372
这是一个坐标系统，你会用来画，和

370
00:19:02,441 --> 00:19:03,841
这也是一个坐标系

371
00:19:03,909 --> 00:19:05,843
获得多点触摸事件，对，

372
00:19:05,911 --> 00:19:09,546
用手指在屏幕上。它是分层的，

373
00:19:09,615 --> 00:19:12,182
这意味着这些矩形住在其他矩形内，

374
00:19:12,251 --> 00:19:13,584
住在其他矩形内，对吗？

375
00:19:13,653 --> 00:19:15,252
所以里面的意见里面的意见。

376
00:19:15,321 --> 00:19:16,987
你用浓度来看这个

377
00:19:17,056 --> 00:19:19,824
我们有那个黑色的最高层的视图

378
00:19:19,892 --> 00:19:22,660
然后在里面，我们有堆栈视图。

379
00:19:22,729 --> 00:19:24,762
还记得吗？所以这是另一种视图。

380
00:19:24,831 --> 00:19:28,165
在堆栈视图内部还有三个堆栈视图。

381
00:19:28,234 --> 00:19:31,201
这三个部分里面有四个卡片按钮。所以

382
00:19:31,270 --> 00:19:34,405
作为UI按钮，正确。另外你有其他的意见像你的

383
00:19:34,473 --> 00:19:37,975
新游戏按钮，分数，翻转计数，这些都是意见。

384
00:19:38,043 --> 00:19:40,044
而且他们每个人都是那种，你知道，

385
00:19:40,112 --> 00:19:41,779
在分层表示。

386
00:19:41,848 --> 00:19:45,382
所以，如果你看一个特定的视图和方式

387
00:19:45,451 --> 00:19:47,084
你想看看它的父视图是谁，

388
00:19:47,153 --> 00:19:50,154
换句话说就是它的视图。你只是问为什么

389
00:19:50,223 --> 00:19:53,490
var superview。好的。现在，它是一个可选的UIView

390
00:19:53,559 --> 00:19:56,793
因为它目前可能不在屏幕上，对吗？所以

391
00:19:56,862 --> 00:20:00,230
可能目前不在监视中。你当然可以

392
00:20:00,299 --> 00:20:02,799
添加它。反过来，如果你有一个看法和

393
00:20:02,868 --> 00:20:05,235
你想说，它里面的所有子视图是什么？

394
00:20:05,304 --> 00:20:07,971
就像你想问我们blackview在哪里，

395
00:20:08,040 --> 00:20:11,842
向我展示你的所有子视图，像这个顶层的stackview和

396
00:20:11,911 --> 00:20:14,912
翻转计数，标签和得分以及新游戏

397
00:20:14,980 --> 00:20:18,815
按钮。你用另一个视图var调用

398
00:20:18,884 --> 00:20:22,452
子视图，就像你看到的那样，是一个UIView数组。好的，

399
00:20:22,521 --> 00:20:27,524
所以管理这个非常简单。还有一个用户界面

400
00:20:27,593 --> 00:20:31,362
窗户就像上面那样，但是我们从来不付钱

401
00:20:31,430 --> 00:20:34,998
注意在iOS中。这不像你在哪里的Mac

402
00:20:35,067 --> 00:20:37,701
在一个大的桌面上有很多窗口。 UIWindow，

403
00:20:37,769 --> 00:20:40,637
唯一的一次，你可能永远关心，也许如果

404
00:20:40,706 --> 00:20:43,340
你有一个应用程序，喜欢投射自己的一部分

405
00:20:43,409 --> 00:20:47,278
到外部屏幕或东西。但是忘记了。所以

406
00:20:47,346 --> 00:20:50,147
在这个类中，我们甚至不会提到UIWindow。

407
00:20:50,216 --> 00:20:51,982
无论如何，它可能是UIView的子类，

408
00:20:52,050 --> 00:20:55,886
但是我们没有真正谈论它。现在这个层次结构

409
00:20:55,955 --> 00:20:59,723
视图内的视图，你在界面生成器中的Xcode。

410
00:20:59,792 --> 00:21:02,392
对，你看到我们如何建立浓度，

411
00:21:02,461 --> 00:21:05,762
我们把东西拖出来，我们点击了嵌入堆栈视图按钮，

412
00:21:05,831 --> 00:21:08,632
那种工作人员。所以这就是我们如何建立这个层次结构，

413
00:21:08,701 --> 00:21:11,802
在99％的时间内把意见放在视图里面。

414
00:21:11,871 --> 00:21:14,404
但它也可以在代码中完成。并在你的任务

415
00:21:14,473 --> 00:21:16,907
3，我会问你做这两个。构建视图层次结构

416
00:21:16,975 --> 00:21:19,543
像你一样的界面建设者在集中。但

417
00:21:19,612 --> 00:21:21,812
那么也可以在代码中做一些。和

418
00:21:21,881 --> 00:21:25,416
你这样做只是说addSubview一个视图，

419
00:21:25,484 --> 00:21:29,486
它会将该视图添加为子视图之一。

420
00:21:29,555 --> 00:21:33,557
这里唯一棘手的事情是，当你想拉出来

421
00:21:33,625 --> 00:21:34,875
如果您想从视图层次结构中拉出视图，

422
00:21:34,876 --> 00:21:36,126
一些原因。

423
00:21:36,195 --> 00:21:38,629
您将该消息发送到视图本身。

424
00:21:38,698 --> 00:21:41,298
好的，你把它发送到视图，你想删除和

425
00:21:41,366 --> 00:21:44,067
你说从父视图中删除自己，与此删除

426
00:21:44,136 --> 00:21:46,536
从superview。所以这里有点不一样

427
00:21:46,605 --> 00:21:49,806
您发送添加到封闭视图，但您发送

428
00:21:49,875 --> 00:21:54,411
删除到实际的观点本身。现在这个在哪里

429
00:21:54,480 --> 00:21:57,447
视图层次开始。什么是顶部包含视图？

430
00:21:57,516 --> 00:22:01,284
当然，这就好像集中的黑色视图，

431
00:22:01,353 --> 00:22:05,422
对，那是非常顶端视图。还有一个非常重要的var，

432
00:22:05,490 --> 00:22:10,161
在UIView控制器中，称为view。

433
00:22:10,229 --> 00:22:12,796
这个观点指出了那个黑色的顶部。

434
00:22:12,864 --> 00:22:14,364
它会自动连线

435
00:22:14,433 --> 00:22:18,002
你在界面建设者，所以你可以随时在那里开始

436
00:22:18,070 --> 00:22:19,870
有点工作你的方式通过层次结构，

437
00:22:19,939 --> 00:22:22,740
看着这些子视图并继续下去。所以

438
00:22:22,808 --> 00:22:25,809
这是一个UIView，在UIView控制器，

439
00:22:25,878 --> 00:22:29,779
非常重要的var知道你是否想访问你的看法

440
00:22:29,848 --> 00:22:32,816
直接层级。现在当然，你也可以访问

441
00:22:32,885 --> 00:22:36,920
你的视图层次结构在任何一个outlet。对，

442
00:22:36,989 --> 00:22:39,523
如果你创建一个像堆栈视图的outlet，

443
00:22:39,591 --> 00:22:41,291
现在你可以看看堆栈视图了

444
00:22:41,360 --> 00:22:43,594
然后开始查看其子视图，如果你想，

445
00:22:43,663 --> 00:22:46,430
你不必从顶部开始，开始往下看。

446
00:22:46,498 --> 00:22:48,932
你可以使用outlet，只要去任何你想要的视图

447
00:22:49,001 --> 00:22:53,337
随时。好的，让我们来谈一谈

448
00:22:53,406 --> 00:22:56,874
初始化一个视图，对吧？获得初始化。一般，

449
00:22:56,942 --> 00:23:00,310
像往常一样，我们尽可能地避免做初始化，

450
00:23:00,379 --> 00:23:04,548
用我们所知道的所有其他方式。如果你必须做一个视图

451
00:23:04,616 --> 00:23:07,384
初始化因为你只是一个变种，你只是没有办法

452
00:23:07,452 --> 00:23:10,253
可以使用我们所知的其他方式初始化它。然后

453
00:23:10,322 --> 00:23:13,424
你必须明白这个视图有两个初始值，

454
00:23:13,492 --> 00:23:16,927
带有框架的init和带有编码器的init。初始化框架是

455
00:23:16,995 --> 00:23:19,930
你用usd来创建一个代码视图的初始化器。

456
00:23:19,998 --> 00:23:23,200
带编码器的初始化器是在什么时候使用的

457
00:23:23,269 --> 00:23:26,070
你在一个界面生成器中构建你的视图

458
00:23:26,138 --> 00:23:29,473
它获得免费的大步，然后你的应用程序运行。运行时，

459
00:23:29,542 --> 00:23:32,943
它与初始化与编码器的初始化。编码器，

460
00:23:33,012 --> 00:23:36,246
NSCoder是一个处理这个机制的协议

461
00:23:36,315 --> 00:23:38,849
用界面生成器冷冻干燥

462
00:23:38,918 --> 00:23:42,186
然后，当你的应用程序运行时，重新启动它。所以

463
00:23:42,254 --> 00:23:44,020
你必须执行这两个。和

464
00:23:44,089 --> 00:23:45,288
你必须同时实施的原因

465
00:23:45,357 --> 00:23:47,791
这些是cuz init与frame是一个指定的

466
00:23:47,859 --> 00:23:51,561
初始值设定项，好的。所以，如果你曾经创造了一个视图

467
00:23:51,630 --> 00:23:55,198
代码，你需要，如果你想要你的代码执行，它的

468
00:23:55,267 --> 00:23:59,336
将不得不这样做。然后init与编码器是必需的

469
00:23:59,404 --> 00:24:02,339
初始值设定项，因为它是UIView协议的一部分

470
00:24:02,408 --> 00:24:05,676
实现，你看到的NSCoder协议。记得，

471
00:24:05,744 --> 00:24:08,278
如果你使用一个协议，并且它有一个init，

472
00:24:08,347 --> 00:24:11,715
这是必需的，好吧。所以你必须实现它们两个。

473
00:24:11,784 --> 00:24:13,950
现在你可以有一些其他的功能，如设置或

474
00:24:14,019 --> 00:24:17,053
不管怎么说，都是从他们那里调用的。虽然，

475
00:24:17,122 --> 00:24:20,490
有时候并不是那么简单，因为如果你使用的话

476
00:24:20,559 --> 00:24:23,027
这个机制初始化你自己的变数，你应该

477
00:24:23,095 --> 00:24:26,263
在你调用super.init之前初始化你自己的变量。

478
00:24:26,332 --> 00:24:29,833
好的，所以你必须在里面初始化这些变量

479
00:24:29,902 --> 00:24:32,402
这些inits。也许你可能有轻微的重复

480
00:24:32,471 --> 00:24:34,304
代码在那里，这样做。但是，希望，

481
00:24:34,372 --> 00:24:39,409
你可以完全避免在UIView这个init。好的，另一个

482
00:24:39,478 --> 00:24:42,946
初始化UIView的替代方法是awakeFromNib（）。

483
00:24:43,015 --> 00:24:45,682
现在awakeFromNib（）实际上是一个函数，

484
00:24:45,751 --> 00:24:48,652
发送给每一个出来的对象

485
00:24:48,721 --> 00:24:50,988
一个interbase面对建造者文件。

486
00:24:51,057 --> 00:24:53,223
每个UI按钮，每个UIView控制器，

487
00:24:53,292 --> 00:24:56,526
一切从那里出来，当它解冻，

488
00:24:56,595 --> 00:24:59,162
它得到发送awakeFromNib（）。现在唯一的事情

489
00:24:59,231 --> 00:25:01,965
把初始化存在，它只会工作

490
00:25:02,034 --> 00:25:04,768
来自界面生成器文件的视图。

491
00:25:04,837 --> 00:25:07,704
如果您从代码构建时使用init创建视图，

492
00:25:07,773 --> 00:25:10,974
如果你创建了一个，这个不会被调用。好的，

493
00:25:11,042 --> 00:25:15,178
这只有当你解冻写入界面时才会发生。

494
00:25:15,247 --> 00:25:19,649
NIB是界面生成器文件的一种真正的旧名称，

495
00:25:19,718 --> 00:25:24,087
IB和NIB意味着界面生成器。可以，然后呢

496
00:25:24,156 --> 00:25:25,955
这是视图的初始化。好吧，

497
00:25:26,024 --> 00:25:28,591
现在让我们来谈谈我们如何绘制。我们有这个UIView。

498
00:25:28,660 --> 00:25:30,260
我们为什么要这样做？那么，我们要画画。

499
00:25:30,328 --> 00:25:32,963
我们如何画？在我可以告诉你如何画画之前，

500
00:25:33,032 --> 00:25:34,631
我们必须谈谈一些类型，

501
00:25:34,699 --> 00:25:38,468
四个非常重要的类型。好的，他们都是从CG开始的，

502
00:25:38,537 --> 00:25:42,906
像这个，CGFloat。 CG代表Core Graphics。

503
00:25:42,974 --> 00:25:46,710
核心图形是底层的绘图系统

504
00:25:46,779 --> 00:25:49,680
在iOS中正常的2D绘图。还有其他的

505
00:25:49,748 --> 00:25:54,151
绘制3D和其他东西的系统。不会

506
00:25:54,219 --> 00:25:55,986
谈论那些因为我们只有这么多的话题。

507
00:25:56,054 --> 00:25:59,056
我们只会谈论基本的2D绘图系统，

508
00:25:59,124 --> 00:26:03,127
这就是所谓的核心图形。所以核心图形有这些

509
00:26:03,195 --> 00:26:06,029
四种类型，他们只是在说的关键

510
00:26:06,098 --> 00:26:09,800
关于绘图的东西，一个是CGFloat。所以所有的绘图是

511
00:26:09,868 --> 00:26:13,970
在一个按照浮点数的系统中。所以

512
00:26:14,039 --> 00:26:16,139
你正在绘制一个浮点坐标系统，

513
00:26:16,208 --> 00:26:17,841
不是整数，它们是浮点数。

514
00:26:17,910 --> 00:26:20,443
当你说你想画的地方，你的每一点

515
00:26:20,512 --> 00:26:22,479
只处理浮点数。和

516
00:26:22,548 --> 00:26:24,648
那些浮点数必须是CGFloat。

517
00:26:24,716 --> 00:26:29,018
他们不能双打或定期漂浮，他们必须是

518
00:26:29,087 --> 00:26:32,889
CGFloats。幸运的是，CGFloat有一个初始化器。

519
00:26:32,958 --> 00:26:37,127
我们会让你从一个double创建一个CGFloat，但是

520
00:26:37,196 --> 00:26:41,698
CGFloat是坐标值的基本类型，

521
00:26:41,766 --> 00:26:45,268
浮点坐标值。所有的绘画，所有你的

522
00:26:45,337 --> 00:26:50,107
代码是绘图将有CGFloats。当然，现在，

523
00:26:50,175 --> 00:26:53,276
有CGPoint，这只是一个结构，有两件事情

524
00:26:53,345 --> 00:26:57,314
其中，x和y，都是CGFloats。还有CGSize，

525
00:26:57,383 --> 00:27:00,650
这是一个有两个东西的结构，两个CGFloats，

526
00:27:00,719 --> 00:27:04,688
宽度和高度。好吧，所以你有浮动，CGFloat基地

527
00:27:04,756 --> 00:27:07,490
事情，那么你有点和大小。而且当然，

528
00:27:07,559 --> 00:27:11,962
你可以将点和大小组合成非常重要的CGRect。

529
00:27:12,031 --> 00:27:16,166
现在CGRect显然只是找到一个矩形，

530
00:27:16,235 --> 00:27:18,936
包括你的意见的整个边界，矩形或

531
00:27:19,004 --> 00:27:21,338
你想在你的象限系统中绘制任何矩形

532
00:27:21,407 --> 00:27:25,008
你会用这个。它有一些初始化程序

533
00:27:25,077 --> 00:27:27,043
包括初始化和大小。

534
00:27:27,112 --> 00:27:29,346
也是初始化器，需要xy的宽度，高度等

535
00:27:29,415 --> 00:27:32,749
而且还有一大堆其他的变数和

536
00:27:32,818 --> 00:27:37,353
操纵rects的函数，像minX这样的变量，

537
00:27:37,422 --> 00:27:41,992
这给你的矩形的最小x值。

538
00:27:42,061 --> 00:27:44,828
或者，相交需要另一个矩形和

539
00:27:44,897 --> 00:27:48,131
返回两个矩形相交的布尔值。

540
00:27:48,200 --> 00:27:51,268
还有一个交点，它返回一个新的矩形

541
00:27:51,336 --> 00:27:55,005
这是两个重叠矩形的交集。

542
00:27:55,074 --> 00:27:57,608
它也包含CGPoint，它会告诉你是否

543
00:27:57,676 --> 00:28:00,343
有一点，那就是CGRect里面的一点。所以

544
00:28:00,412 --> 00:28:03,280
有很多，这大概有两三十种方法

545
00:28:03,349 --> 00:28:05,716
绝对检查出文档CGRect，

546
00:28:05,784 --> 00:28:08,451
因为它会使你的代码更清洁。实际上，

547
00:28:08,520 --> 00:28:10,353
你会在周三的演示中看到。

548
00:28:10,422 --> 00:28:13,290
我甚至扩展了CGRect来增加五六个

549
00:28:13,358 --> 00:28:16,627
一个便利的功能，因为CGRect了

550
00:28:16,695 --> 00:28:20,263
在你写的所有代码中如此重要。

551
00:28:20,332 --> 00:28:23,901
当你在绘画的时候。所以现在你知道这四种类型，

552
00:28:23,969 --> 00:28:26,636
让我们来谈谈我们要的坐标系

553
00:28:26,705 --> 00:28:30,306
在这里画画。要知道的最重要的事情

554
00:28:30,375 --> 00:28:34,444
除了它的浮点精度

555
00:28:34,513 --> 00:28:38,415
得出的是，原点在左上角，而不是在下面

556
00:28:38,484 --> 00:28:41,184
剩下。左下角是笛卡尔坐标，

557
00:28:41,253 --> 00:28:43,653
你知道，就像你在数学课上一样。左下角的alk，

558
00:28:43,722 --> 00:28:46,589
也恰好是Mac上的坐标系，

559
00:28:46,658 --> 00:28:49,159
好的。但在iOS中，它在左上角，

560
00:28:49,228 --> 00:28:53,363
这意味着越来越多的值向下

561
00:28:53,432 --> 00:28:57,033
屏幕的底部。举个例子，我明白了这一点

562
00:28:57,102 --> 00:29:00,971
在那边。在那里看，500,35。

563
00:29:01,039 --> 00:29:05,409
现在已经过了500了，35了，正确的，已经结束了。

564
00:29:05,477 --> 00:29:08,979
所以这是500的x，而实际上它将是500.0

565
00:29:09,047 --> 00:29:13,917
和35.0 cuz他们是浮点值，对不对？好的，

566
00:29:13,986 --> 00:29:18,455
该坐标系中的单位称为点。

567
00:29:18,523 --> 00:29:21,724
点与像素不一样。

568
00:29:21,793 --> 00:29:25,261
像素是屏幕的小点。

569
00:29:25,330 --> 00:29:29,666
一些屏幕有很多像素，非常，

570
00:29:29,735 --> 00:29:33,169
非常高的分辨率，我们称之为视网膜显示器。

571
00:29:33,238 --> 00:29:36,272
你可能听过这句话。每个像素很多

572
00:29:36,341 --> 00:29:40,209
点。为什么这么好？那么，因为记得你可以画画

573
00:29:40,278 --> 00:29:44,614
在浮点边界上，所以你可以在27.3，27.6，

574
00:29:44,683 --> 00:29:48,552
28，对吗？你可以在点之间画画。和

575
00:29:48,620 --> 00:29:50,520
你得到这些非常光滑的曲线或

576
00:29:50,589 --> 00:29:54,090
无论在视网膜显示器上。在较低的res显示屏上，

577
00:29:54,159 --> 00:29:57,027
也许每个点只有一个像素，等等

578
00:29:57,095 --> 00:30:01,131
当你画画的时候更加粗糙。但是你不画

579
00:30:01,199 --> 00:30:03,366
在像素边界上，您可以绘制点边界。

580
00:30:03,435 --> 00:30:06,136
这样，即使你每个点有很多像素，

581
00:30:06,205 --> 00:30:09,006
它看起来基本上和下面的一样大小

582
00:30:09,074 --> 00:30:12,875
分辨率设备。好吧，它不像高

583
00:30:12,944 --> 00:30:16,412
分辨率的设备，但它是相同的大小因为它的变焦点。

584
00:30:16,481 --> 00:30:19,716
你可以找出你的设备每个点有多少像素

585
00:30:19,784 --> 00:30:23,053
通过使用UIView内容scale.factor谁转

586
00:30:23,122 --> 00:30:26,589
一个浮动，它现在要么是一，二，或

587
00:30:26,658 --> 00:30:29,493
三。它会告诉你有多少像素在那里

588
00:30:29,561 --> 00:30:34,097
每点。好吧，

589
00:30:34,165 --> 00:30:38,434
所有UIView中最重要的矩形是界限，

590
00:30:38,503 --> 00:30:41,871
它是在UIView CGRect var。它告诉你的界限，

591
00:30:41,940 --> 00:30:44,941
绘图系统的坐标，原点和坐标

592
00:30:45,010 --> 00:30:48,612
在你自己的绘图坐标系中的宽度和高度。

593
00:30:48,681 --> 00:30:50,447
有一件事你必须明白的是，

594
00:30:50,515 --> 00:30:53,883
不同的观点有不同的坐标系统。

595
00:30:53,952 --> 00:30:56,619
好的，他们每个人都有自己的坐标系，

596
00:30:56,688 --> 00:30:59,789
这个bounds是在你的。所以当你画画时，

597
00:30:59,858 --> 00:31:03,226
你总是使用bounds。现在有一些其他的

598
00:31:03,294 --> 00:31:08,064
像frame的东西。 Var frame，听起来很bounds。

599
00:31:08,133 --> 00:31:12,902
框架与您的绘图无关。没有，

600
00:31:12,971 --> 00:31:15,472
这是一个正义，但与你的绘画无关。

601
00:31:15,540 --> 00:31:19,643
frame是你在你的父视图的地方。

602
00:31:19,711 --> 00:31:21,811
所以，甚至在你的坐标系统框架，

603
00:31:21,880 --> 00:31:23,814
在这是你的超级观点的坐标系统。

604
00:31:23,883 --> 00:31:26,650
说，你在哪里？与中心类似。

605
00:31:26,718 --> 00:31:30,253
中心不是你绘画区的中心，

606
00:31:30,321 --> 00:31:34,357
在你的父视图中的中心。所以框架在中心

607
00:31:34,426 --> 00:31:39,362
是，你在哪里？边界是你正在绘制的地方。

608
00:31:39,431 --> 00:31:42,332
不要把这些事情搞糊涂了。我有一个滑下来

609
00:31:42,401 --> 00:31:44,400
在这里，快速通过它，我们从来没有使用框架或

610
00:31:44,469 --> 00:31:46,836
中心画，因为它与绘画无关，

611
00:31:46,905 --> 00:31:48,171
它与定位有关。

612
00:31:48,240 --> 00:31:50,773
你可能会认为这个frame和bounds

613
00:31:50,842 --> 00:31:54,711
会是相同的大小，但意见可以旋转。和

614
00:31:54,779 --> 00:31:57,747
如果你想象旋转你的视图，bounds会旋转

615
00:31:57,815 --> 00:32:01,651
与，好吧，所以他们保持相同的大小，但现在的frame

616
00:32:01,719 --> 00:32:05,922
必须变得更大。完全封闭这是因为它

617
00:32:05,991 --> 00:32:09,960
一个菱形，右边，视图B是钻石形状。可以，然后呢

618
00:32:10,028 --> 00:32:12,829
frame大小的宽度和高度是不一样的

619
00:32:12,897 --> 00:32:15,531
必然是bounds大小的宽度和高度。

620
00:32:15,600 --> 00:32:17,433
千万不要把它们想成是一样的。

621
00:32:17,502 --> 00:32:20,369
如果你用这个框架来画这个课，

622
00:32:20,438 --> 00:32:22,639
你会受到伤害，这是错误的。

623
00:32:25,677 --> 00:32:27,376
好，现在我们知道我们在哪里的bounds

624
00:32:27,445 --> 00:32:29,412
正在绘制。我们知道我们有这个坐标系

625
00:32:29,481 --> 00:32:32,582
左上角。我们如何创建其中的一个视图？

626
00:32:32,651 --> 00:32:33,850
好的，我们要创建一个。好，

627
00:32:33,919 --> 00:32:36,987
我告诉过你，主要是在Interface Builder中做的，但是

628
00:32:37,055 --> 00:32:39,890
如果我有一个自定义的视图。假设我有一个自定义的视图，

629
00:32:39,958 --> 00:32:42,024
画一些特别的东西给我。

630
00:32:42,093 --> 00:32:45,295
如何将它拖出界面生成器？对，

631
00:32:45,363 --> 00:32:48,031
界面生成器在右下角有很好的列表

632
00:32:48,099 --> 00:32:51,534
UIButton的角落，UILabel，所有那些很酷的东西。

633
00:32:51,603 --> 00:32:54,403
我的视图不会在那里，对吗？

634
00:32:54,472 --> 00:32:57,774
那么我该如何制作一个？那么，事实证明，你拖出来

635
00:32:57,842 --> 00:33:01,078
一个通用的。目前，就我而言，

636
00:33:01,146 --> 00:33:04,213
这是长长的名单中的第二个。

637
00:33:04,282 --> 00:33:06,983
在那里叫做UIView。你拖出一个通用的

638
00:33:07,052 --> 00:33:09,319
那么你要检查它，但你会用

639
00:33:09,387 --> 00:33:11,654
在右上方有一个与你不同的检查员

640
00:33:11,723 --> 00:33:13,857
通常这样做。这不是属性检查器，

641
00:33:13,925 --> 00:33:16,225
这是身份检查员。我认为这是标签，

642
00:33:16,294 --> 00:33:18,828
只有一个在属性检查器的左侧。和

643
00:33:18,897 --> 00:33:20,697
在那里，最重要的事情正在进行

644
00:33:20,765 --> 00:33:23,532
成为你正在检查的东西的一部分

645
00:33:23,601 --> 00:33:26,202
当你第一次把它拖出来的时候会是UIView。而你

646
00:33:26,271 --> 00:33:29,906
只是要改变下拉选择你的类。

647
00:33:29,975 --> 00:33:32,575
所以现在你有一个视图，但这是你的类。

648
00:33:32,644 --> 00:33:37,247
这就是你要创建你的自定义视图。现在，

649
00:33:37,316 --> 00:33:39,516
另一种可以创建视图的方式是在代码中。

650
00:33:39,584 --> 00:33:42,051
再次，我会要求你在你的双方都这样做

651
00:33:42,120 --> 00:33:45,622
任务三。而你只是通过调用frame来做到这一点

652
00:33:45,691 --> 00:33:49,826
UIView与我们之前谈到的frame初始化器。

653
00:33:49,895 --> 00:33:52,762
你也可以设置UIView左括号，关闭

654
00:33:52,831 --> 00:33:56,533
括号，那么你的框架将是0000，左上角，

655
00:33:56,601 --> 00:33:59,769
没有大小。然后你可以设置该frame var，

656
00:33:59,837 --> 00:34:02,706
我在前面谈到，定位和

657
00:34:02,775 --> 00:34:06,075
大小，这个视图在父视图。好的，

658
00:34:06,144 --> 00:34:07,744
只是永远记住frame，虽然，

659
00:34:07,813 --> 00:34:09,078
在父视图的坐标系中，

660
00:34:09,147 --> 00:34:10,713
它是在说你在哪里。

661
00:34:10,782 --> 00:34:11,747
与你的绘画无关，

662
00:34:11,816 --> 00:34:15,251
只是你在哪里。好的，这是一个例子。

663
00:34:15,320 --> 00:34:18,722
我要创建一个UILabel编码。好的，UILabel，你

664
00:34:18,790 --> 00:34:21,191
知道那是什么，对吗？它显示文字，就是这样

665
00:34:21,259 --> 00:34:24,026
那个翻转的冒号0，那是一个UILabel。当然，

666
00:34:24,095 --> 00:34:26,062
UILabel从UIView继承。

667
00:34:26,130 --> 00:34:29,032
这是一个屏幕上的矩形区域。所有矩形区域

668
00:34:29,101 --> 00:34:33,002
在屏幕上是UIViews。所以，我要创建一个矩形

669
00:34:33,071 --> 00:34:35,539
说它会在哪里。这个长方形将会进入

670
00:34:35,607 --> 00:34:37,640
父视图的坐标系。在这种情况下，

671
00:34:37,709 --> 00:34:39,475
我会把标签放在最顶层。

672
00:34:39,544 --> 00:34:42,912
换句话说，浓度的黑色视图，我正在放

673
00:34:42,981 --> 00:34:46,049
它恰到好处。所以这20个横跨和20个下来和

674
00:34:46,118 --> 00:34:49,686
宽度为100，高度为50，这是在黑色的意见，

675
00:34:49,754 --> 00:34:53,122
顶层视图坐标系统。然后我创建

676
00:34:53,191 --> 00:34:57,426
使用该框架的UILabel。我把标签的文字设置成你好。

677
00:34:57,495 --> 00:35:00,163
没有什么在屏幕上发生，是的。

678
00:35:00,231 --> 00:35:03,032
现在，我需要添加它作为黑视图的子视图，所以

679
00:35:03,101 --> 00:35:05,835
我会假设这个代码是在视图控制器和

680
00:35:05,904 --> 00:35:08,104
我要使用非常特殊的var视图。

681
00:35:08,173 --> 00:35:12,708
并说，查看，添加子视图这个标签。现在

682
00:35:12,777 --> 00:35:15,778
UI标签被添加为顶级视图的子视图，

683
00:35:15,847 --> 00:35:17,146
集中的黑色视图，

684
00:35:17,215 --> 00:35:19,582
它在这里是白色的，它被放在20,20，

685
00:35:19,650 --> 00:35:24,988
在顶层视图坐标系中为150。记得，

686
00:35:25,056 --> 00:35:28,591
左上角是00.所以，这意味着从左上角向下

687
00:35:28,659 --> 00:35:32,695
角。大家都知道了？这就是你如何添加视图，

688
00:35:32,764 --> 00:35:35,965
只需添加子视图就很容易了。你就是这样放的

689
00:35:36,033 --> 00:35:39,735
在代码上的屏幕上查看。好，那我什么时候想要

690
00:35:39,804 --> 00:35:42,605
创建我自己的UIView子类与只使用UIButton或

691
00:35:42,674 --> 00:35:44,841
的UILabel？那些是UIView子类。

692
00:35:44,909 --> 00:35:47,477
那么，如果我明显想要做自定义绘图或

693
00:35:47,545 --> 00:35:49,913
如果我想处理一些自定义触摸事件，

694
00:35:49,982 --> 00:35:51,714
捏或类似的东西。

695
00:35:51,783 --> 00:35:55,085
我会在周三讨论处理触摸事件，但是

696
00:35:55,153 --> 00:35:58,321
今天我们要专注于绘画。所以我们要做

697
00:35:58,390 --> 00:36:02,859
所有绘图今天。所以要画画就不那么容易了，

698
00:36:02,927 --> 00:36:07,397
在所有的iOS中，只有一种方法可以绘制。哪一个

699
00:36:07,466 --> 00:36:12,235
你是在UIView中重写这个函数并实现它。

700
00:36:12,304 --> 00:36:15,872
这是绘制的唯一途径。你不能调用任何函数

701
00:36:15,941 --> 00:36:18,240
这个方法之外的任何东西，

702
00:36:18,309 --> 00:36:21,477
这是绘制的唯一方法。所以这很简单，

703
00:36:21,546 --> 00:36:23,246
你不必担心任何其他机制

704
00:36:23,315 --> 00:36:26,516
是唯一的一个。所以在这个绘制方法里面，

705
00:36:26,585 --> 00:36:28,884
你会画出你的bounds，

706
00:36:28,953 --> 00:36:31,721
无论你做什么自定义绘图。好的，

707
00:36:31,790 --> 00:36:36,359
永远不要调用这个方法。这种方法，

708
00:36:36,428 --> 00:36:38,762
你重写和实现你的绘图，

709
00:36:38,830 --> 00:36:42,432
你永远不会调用。如果你想要重画你的视图，

710
00:36:42,500 --> 00:36:45,167
因为关于你的事情已经改变了，你调用给你

711
00:36:45,236 --> 00:36:48,237
这两个方法对你自己，setNeedsDisplay或

712
00:36:48,306 --> 00:36:50,974
用rect setNeedsDisplay。好的，和

713
00:36:51,042 --> 00:36:54,143
告诉系统，嘿，我的观点需要重新绘制，

714
00:36:54,212 --> 00:36:58,014
请重新绘制它。所以，只有系统，只有iOS

715
00:36:58,082 --> 00:37:01,083
调用给你的draw，你可调用给它，或告诉它

716
00:37:01,152 --> 00:37:04,954
你要它调用它，通过调用setNeedsDisplay。

717
00:37:05,023 --> 00:37:08,023
现在注意这个矩形，看看绘制矩形。那是什么

718
00:37:08,092 --> 00:37:11,794
直接参数，既可以上下拖动也可以显示。

719
00:37:11,863 --> 00:37:15,898
这纯粹是一个优化矩形，好吧。那就是如果，

720
00:37:15,967 --> 00:37:18,501
例如，你有另一个视图顶部的视图和

721
00:37:18,569 --> 00:37:21,271
它走了，它露出一个小矩形的视图，

722
00:37:21,339 --> 00:37:24,240
系统会调用你的绘制只有矩形。

723
00:37:24,309 --> 00:37:27,443
但是如果你愿意的话，你可以重新绘制整个视图。

724
00:37:27,512 --> 00:37:30,012
但是，如果你只能绘制效率

725
00:37:30,081 --> 00:37:31,914
暴露的矩形，

726
00:37:31,983 --> 00:37:35,051
那么你可以高效。所以这纯粹是一个优化。

727
00:37:35,119 --> 00:37:37,520
你可以忽略它，如果你想，只是画出你的整个视图。

728
00:37:37,588 --> 00:37:40,256
所以，如果你有一个简单的视图，很容易绘制，

729
00:37:40,325 --> 00:37:43,259
不使用大量资源而不使用3D图形或

730
00:37:43,327 --> 00:37:48,731
东西，那么你可以忽略这个矩形。好吧，

731
00:37:48,800 --> 00:37:51,400
那么我如何执行这个绘制矩形？好，我覆盖

732
00:37:51,469 --> 00:37:53,669
现在我想画画。那么我们该怎么做呢？

733
00:37:53,738 --> 00:37:56,005
我们要用核心图形来做，

734
00:37:56,074 --> 00:37:59,242
这是绘图层次的基础。基本的方法

735
00:37:59,310 --> 00:38:01,944
要做到这一点，你会得到所谓的绘画上下文和

736
00:38:02,013 --> 00:38:04,914
你问这个背景画线和

737
00:38:04,983 --> 00:38:08,317
东西，好吧。现在，也有一种面向对象的方式

738
00:38:08,386 --> 00:38:10,353
绘制一个名为UIBezierPath的类。

739
00:38:10,422 --> 00:38:12,788
UIBezierPath，相同的概念。

740
00:38:12,857 --> 00:38:15,425
这只是一点点的东西或以你的方式

741
00:38:15,494 --> 00:38:17,693
可以建立一个包含一些绘图的对象。

742
00:38:17,762 --> 00:38:19,862
如果你想重复绘制这个对象，

743
00:38:19,931 --> 00:38:23,199
也许用不同的颜色，不管。那么让我们来谈谈

744
00:38:23,267 --> 00:38:26,469
绘制核心图形的基本核心概念，

745
00:38:26,537 --> 00:38:27,737
我们该怎么做呢？

746
00:38:27,806 --> 00:38:30,606
关于核心图形的第一件事就是它

747
00:38:30,675 --> 00:38:33,709
基于上下文，所以你必须得到一个上下文。 UIBezierPath

748
00:38:33,778 --> 00:38:35,477
会自动获取上下文

749
00:38:35,546 --> 00:38:37,414
你，但是如果你不使用UIBezierPath，

750
00:38:37,482 --> 00:38:39,815
你必须得到一个上下文。现在，在drawRect中，

751
00:38:39,884 --> 00:38:42,451
你可以使用这个Swift全局函数，

752
00:38:42,520 --> 00:38:46,055
UIGraphicsGetCurrentContext，它会给你一个上下文

753
00:38:46,124 --> 00:38:49,992
画画，好的。但也可能有其他的情况下，印刷或

754
00:38:50,061 --> 00:38:51,961
绘制和关闭屏幕缓冲区，

755
00:38:52,029 --> 00:38:54,898
我不会谈论这些，但还有其他的

756
00:38:54,966 --> 00:38:57,300
如何获得上下文。但是当你在drawRect中时，

757
00:38:57,368 --> 00:38:59,468
这很容易。你只需要调用这个全局函数，

758
00:38:59,537 --> 00:39:03,005
它会给你你正在绘制的上下文。

759
00:39:03,074 --> 00:39:04,474
好的，一旦你有了上下文，

760
00:39:04,542 --> 00:39:08,777
现在你使用上下文创建所谓的路径。

761
00:39:08,846 --> 00:39:11,981
路径只是弧线和线

762
00:39:12,050 --> 00:39:15,184
然后移动到，就像跳过一点点。

763
00:39:15,253 --> 00:39:19,121
这只是所有这些的组合，这是一条道路。

764
00:39:19,190 --> 00:39:21,023
所以你会建立一些路径。

765
00:39:21,092 --> 00:39:24,994
然后，你要设置一些绘图属性，

766
00:39:25,063 --> 00:39:28,931
像你想要绘制的颜色，任何字体，种类。

767
00:39:29,000 --> 00:39:31,801
这是一个绘图属性，我们将讨论字体

768
00:39:31,870 --> 00:39:34,637
有点，但线宽，纹理，这样的事情。

769
00:39:34,705 --> 00:39:37,006
你把所有这些设置好，然后你做一个

770
00:39:37,075 --> 00:39:41,611
两条东西与你的路径，你抚摸它，或者你填写它。所以，

771
00:39:41,680 --> 00:39:45,414
笔画意味着沿着我的路线画一条线，你知道，

772
00:39:45,483 --> 00:39:49,519
具有一定的线条宽度和颜色，填充方式填写

773
00:39:49,587 --> 00:39:54,023
我的线圈的区域。信不信由你，

774
00:39:54,091 --> 00:39:58,895
这是基本上吸引人的唯一途径。

775
00:39:58,963 --> 00:40:01,764
核心图形，你可能会喜欢，哇，这似乎是真的

776
00:40:01,833 --> 00:40:04,266
限制。我所能做的就是弧线和线条并填充它们

777
00:40:04,335 --> 00:40:06,902
抚摸它们，但是当你构建时你可以做什么，这是惊人的

778
00:40:06,971 --> 00:40:10,372
在那个原始强大的机制之上，好吧，

779
00:40:10,441 --> 00:40:13,709
我们会谈论这个。所以UIBezierPath也是这样

780
00:40:13,778 --> 00:40:16,212
事情，它只是在封面上做了很多，但它已经

781
00:40:16,281 --> 00:40:20,083
设置线的方法，以及类似的东西。

782
00:40:20,151 --> 00:40:22,819
有中风的方法和填补的方法

783
00:40:22,887 --> 00:40:26,923
一个方法来做弧和线和所有的东西。所以

784
00:40:26,991 --> 00:40:31,127
这只是一种仲裁收集袋。所以

785
00:40:31,196 --> 00:40:33,196
让我们看看代码的样子。

786
00:40:33,265 --> 00:40:35,731
用这种机制绘制一个三角形。

787
00:40:35,800 --> 00:40:39,168
所以第一次，我会用UIBezierPath做。我要创造

788
00:40:39,237 --> 00:40:41,470
UIBezierPath，它有很多的初始化，但

789
00:40:41,539 --> 00:40:43,973
我要用那个创造一条空路的那个。

790
00:40:44,042 --> 00:40:45,941
那创造一个新的，没有什么。

791
00:40:46,010 --> 00:40:48,911
现在我要走了，我要开始移动

792
00:40:48,980 --> 00:40:51,714
一个点你看到80横跨和50下降。

793
00:40:51,783 --> 00:40:55,317
让我们假设这个屏幕是160点和

794
00:40:55,386 --> 00:40:59,022
你知道300或400高。所以我正在半途而废

795
00:40:59,090 --> 00:41:02,725
从顶部向下50分，我的余量在左边。

796
00:41:02,794 --> 00:41:05,461
现在我要添加一行到140以上，

797
00:41:05,530 --> 00:41:08,364
几乎到了那边的屏幕边缘

798
00:41:08,433 --> 00:41:11,834
150下来，然后我要添加另一行。你看怎么样

799
00:41:11,903 --> 00:41:14,671
我只是在我的UIBezierPath上调用函数来添加行，

800
00:41:14,739 --> 00:41:17,573
对？所以还有另一个在这里。那么我会去的

801
00:41:17,642 --> 00:41:20,944
关闭我的路径，以便在UIBezierPath中调用一个方法

802
00:41:21,012 --> 00:41:24,447
关闭，从你开始的地方开始画一条线，

803
00:41:24,516 --> 00:41:27,183
无论如何。所以，我要关闭我的路径。

804
00:41:27,251 --> 00:41:28,884
在UIbezierPath中有很多方法

805
00:41:28,953 --> 00:41:31,554
必须去看文档。但在这里

806
00:41:31,623 --> 00:41:34,090
一个简单的，那些简单的方法用法吧？现在我

807
00:41:34,158 --> 00:41:36,693
一种欺骗你，因为你会看这个和

808
00:41:36,761 --> 00:41:39,562
它看起来像我所说的那样，它画在屏幕上，但是

809
00:41:39,631 --> 00:41:42,831
没有。我只是想给你可视化的东西

810
00:41:42,900 --> 00:41:46,335
继续。事实上，当我这样做的时候，什么也没有发生

811
00:41:46,404 --> 00:41:49,072
屏幕。没有什么事情发生

812
00:41:49,140 --> 00:41:51,975
我所做的只是建立这个UIBezierPath对象。

813
00:41:52,043 --> 00:41:55,010
如果我想出现在碎石，我必须设置我的绘画

814
00:41:55,079 --> 00:41:57,079
属性，并告诉它来冲刺或填充。所以

815
00:41:57,148 --> 00:42:01,683
让我们这样做。现在我们把颜色和填充颜色都设置好了

816
00:42:01,752 --> 00:42:06,756
使用UIColor类来抚摸颜色。所以

817
00:42:06,825 --> 00:42:09,191
我们不把它放在我们的UIBezier路上，

818
00:42:09,260 --> 00:42:10,326
我们实际上使用颜色和

819
00:42:10,395 --> 00:42:13,095
我们说像UIColor.green.setFill这样的东西。

820
00:42:13,164 --> 00:42:18,067
那么，绿色是UIColor上的静态变量，

821
00:42:18,136 --> 00:42:20,269
这意味着它就像一个类的颜色一样，

822
00:42:20,338 --> 00:42:23,873
就像获得唯一标识符在卡中一样。和

823
00:42:23,941 --> 00:42:26,975
它只是得到了绿色，它有大约10或

824
00:42:27,044 --> 00:42:31,514
12种预定义的颜色，红色，绿色，蓝色，洋红色，青色，

825
00:42:31,583 --> 00:42:34,016
那种东西。我们也可以做颜色。

826
00:42:34,084 --> 00:42:35,684
我们可以在那里使用颜色文字。

827
00:42:35,753 --> 00:42:38,454
记得当我们做了颜色文字？完全合法的

828
00:42:38,522 --> 00:42:42,692
说colorLiteral.setFill。所以我们正在设置我们的填充颜色

829
00:42:42,761 --> 00:42:44,794
和我们的中风颜色。所以我们要用绿色填充。

830
00:42:44,863 --> 00:42:46,495
我们的三角形将被填满绿色和

831
00:42:46,564 --> 00:42:48,931
该线将被绘制红色和

832
00:42:49,000 --> 00:42:51,401
我也回到BezierPath，说：

833
00:42:51,469 --> 00:42:54,704
设置高两点三宽的线

834
00:42:54,772 --> 00:42:58,774
决议发挥将是九个像素宽。所以

835
00:42:58,843 --> 00:43:01,978
这是一个非常粗的线，而不是那么厚，但如此

836
00:43:02,046 --> 00:43:04,313
现在我已经设置了这些东西，我可以中风和

837
00:43:04,382 --> 00:43:06,348
填。所以让我们先填充和

838
00:43:06,417 --> 00:43:08,884
当我觉得我得到这个通知时，没有一条线

839
00:43:08,953 --> 00:43:12,087
我只是得到了我所做的路径的填补。

840
00:43:12,156 --> 00:43:15,591
然后当我中风时，我得到了红色的3点宽线

841
00:43:15,660 --> 00:43:19,162
周围。是吗？ >>这是哪里

842
00:43:19,230 --> 00:43:22,932
书面？ >>这写在哪里？

843
00:43:23,001 --> 00:43:25,401
就像你把这个放在哪里？在你的绘画rect。

844
00:43:25,470 --> 00:43:28,337
在那个绘制方法中，我们在UIView中重写，

845
00:43:28,405 --> 00:43:33,709
这就是代码的地方。 >>所以，当我拖动一个UIView

846
00:43:33,778 --> 00:43:37,046
出来的故事板，我必须做一个出口，

847
00:43:37,115 --> 00:43:38,748
像，有 - 好的，所以问题是，

848
00:43:38,817 --> 00:43:41,617
当我拖动一个UIView到我的故事板和

849
00:43:41,686 --> 00:43:43,118
我把它设置为我的自定义类，

850
00:43:43,187 --> 00:43:46,455
我必须喜欢做一个出口或什么？不，你只是，

851
00:43:46,524 --> 00:43:50,693
在你的自定义代码中，实现你的绘图

852
00:43:50,762 --> 00:43:54,263
优化rect参数，并把这个代码在那里，和

853
00:43:54,332 --> 00:43:58,100
每一次系统在屏幕上都有你的视图

854
00:43:58,169 --> 00:44:00,602
会画这个。现在它是非常有效的，它只会问

855
00:44:00,671 --> 00:44:03,806
你要画一次，除非事物发生变化，但它会画出来

856
00:44:03,874 --> 00:44:07,075
为你。所以整体来说，所有的绘图都是按需的，

857
00:44:07,144 --> 00:44:10,446
对？系统要求你画画，它叫你的功能，

858
00:44:10,515 --> 00:44:11,914
你实现这个代码和

859
00:44:11,983 --> 00:44:15,751
它吸引了需求。你永远不要强制绘制。

860
00:44:15,820 --> 00:44:17,353
唯一的办法就是可以强制绘图，

861
00:44:17,422 --> 00:44:19,455
那是setNeedsDisplay。而且即使这只是说

862
00:44:19,523 --> 00:44:22,491
请系统尽快抽取我，但不是

863
00:44:22,560 --> 00:44:26,362
即刻。这一切都是按需绘制的。所以，这是如何

864
00:44:26,431 --> 00:44:29,431
你会执行。这个代码将在你的绘制矩形。

865
00:44:29,500 --> 00:44:32,067
我们称之为dra_rect，它被称为绘制矩形。

866
00:44:32,136 --> 00:44:35,538
现在它被称为绘制在酒吧rect，但我想我们

867
00:44:35,606 --> 00:44:39,141
可以称之为绘制方法，但我们称之为dra_rect，

868
00:44:39,210 --> 00:44:43,045
这是正确的参数，好吧，优化。

869
00:44:43,114 --> 00:44:46,748
好吧，现在你可以使用UIBezierPath来创建

870
00:44:46,817 --> 00:44:51,120
一些非常常见的路径就像我们将要做的圆角矩形

871
00:44:51,188 --> 00:44:54,223
在我们的演示中使用，因为我们要做一张扑克牌

872
00:44:54,291 --> 00:44:57,793
有一个圆角的矩形。你也可以做圆圈，椭圆，

873
00:44:57,862 --> 00:45:02,098
就像使用UIBenzierPath的其他初始值设定项一样。

874
00:45:02,167 --> 00:45:04,934
请注意，您可以使用BezierPath剪辑

875
00:45:05,002 --> 00:45:07,269
你的绘画。你一定会想要这个

876
00:45:07,338 --> 00:45:09,538
你的功课，注意这里。所以

877
00:45:09,607 --> 00:45:12,608
这意味着你画出一些像你三角形的形状。

878
00:45:12,677 --> 00:45:15,344
如果你发送添加剪辑到你的路径，

879
00:45:15,413 --> 00:45:18,781
现在所有将来的绘图都将在这个三角形内。即使

880
00:45:18,850 --> 00:45:22,618
你在外面画，外面的东西都会被剪掉。

881
00:45:22,687 --> 00:45:25,387
所以，这可以真正方便您的功课。

882
00:45:25,456 --> 00:45:30,159
这是我的暗示。你也可以做点击检测

883
00:45:30,228 --> 00:45:33,162
像这个三角形中的点，对吗？

884
00:45:33,231 --> 00:45:36,065
使用这个包含点方法和

885
00:45:36,134 --> 00:45:38,133
很多其他的东西。所以请检查文档

886
00:45:38,202 --> 00:45:42,238
UIBezierPath你可以做的事情。

887
00:45:42,306 --> 00:45:45,540
好的，让我们来谈谈UIColor吧？好的，

888
00:45:45,609 --> 00:45:48,010
首先设置填充和笔画的东西。

889
00:45:48,079 --> 00:45:51,314
我们知道很多创建颜色的方法。颜色文字，

890
00:45:51,382 --> 00:45:54,483
也是我提到的静态函数。你也可以创建

891
00:45:54,552 --> 00:45:56,718
他们与初始化器采取RGB值。

892
00:45:56,787 --> 00:45:59,388
或HSB是色相饱和度和亮度还是

893
00:45:59,457 --> 00:46:02,224
甚至一个模式。你可以创建一个真正的颜色

894
00:46:02,293 --> 00:46:05,594
一个图案的一些图像，就像重复的，正确的，

895
00:46:05,663 --> 00:46:08,764
这是一个很酷。而且我们也知道有视图

896
00:46:08,832 --> 00:46:11,300
背景颜色，对吧？我们设置背景颜色

897
00:46:11,368 --> 00:46:14,203
我们在浓度的基本视图是黑色的。

898
00:46:14,272 --> 00:46:16,672
我们将按钮的背景颜色设置为橙色，所以

899
00:46:16,740 --> 00:46:20,810
鉴于此，当然有一个变种。颜色也是，

900
00:46:20,879 --> 00:46:25,047
重要的是，可以是透明的。透明

901
00:46:25,116 --> 00:46:27,549
颜色，你可以看到通过它一点点

902
00:46:27,618 --> 00:46:30,819
我们使用称为alpha的东西指定透明度。

903
00:46:30,888 --> 00:46:34,390
有多少人听说过alpha绘图？可以，然后呢

904
00:46:34,459 --> 00:46:37,559
你们大多数人都知道这很好所以，我们使用阿尔法。 0的阿尔法

905
00:46:37,628 --> 00:46:40,563
意味着完全透明，alpha 1意味着完全不透明

906
00:46:40,632 --> 00:46:43,098
我们之间可以有任何号码。得到的方式

907
00:46:43,167 --> 00:46:46,234
一个透明的颜色，是采取你有一个颜色，像黄色

908
00:46:46,303 --> 00:46:48,737
让我们说在那里，你发送信息，或者

909
00:46:48,806 --> 00:46:50,706
该函数与AlphaComponent一起使用。和

910
00:46:50,774 --> 00:46:54,009
它会给你一个透明的新颜色。

911
00:46:54,078 --> 00:46:56,712
现在你可以绘制这个透明度。

912
00:46:56,780 --> 00:47:00,616
如果你想用透明的方式来画你，

913
00:47:00,685 --> 00:47:03,853
尽管如此，要非常小心。因为，

914
00:47:03,921 --> 00:47:07,255
系统默认默认只显示您的视图

915
00:47:07,324 --> 00:47:11,594
画不透明。它只用完全不透明的颜色绘制。

916
00:47:11,662 --> 00:47:14,997
如果你真的用透明的颜色绘制，

917
00:47:15,065 --> 00:47:19,601
你必须在被称为opaque的视图上设置一个var为false。

918
00:47:19,670 --> 00:47:23,172
现在他为什么这样做？那么想象一下CPU和CPU有多少

919
00:47:23,241 --> 00:47:26,875
由于现在是GPU密集型，所以要用透明度来绘制

920
00:47:26,944 --> 00:47:32,248
你背后的视图必须与你的位子合成，

921
00:47:32,316 --> 00:47:35,084
你知道合成不便宜，好吗？

922
00:47:35,153 --> 00:47:37,686
GPU在那里做了很多工作，所以

923
00:47:37,755 --> 00:47:39,455
这就是为什么它假设一切都是不透明的

924
00:47:39,524 --> 00:47:42,658
重叠的一切都不需要合成。

925
00:47:42,726 --> 00:47:45,927
所以，如果你想透明地画画，

926
00:47:45,996 --> 00:47:47,596
这很好。这是合法的。

927
00:47:47,664 --> 00:47:49,731
这不是那么贵，你永远不会想这样做。

928
00:47:49,800 --> 00:47:51,400
但是确保你把这个不透明设置为false。

929
00:47:51,469 --> 00:47:53,502
你可以在界面生成器中做到这一点。

930
00:47:53,571 --> 00:47:54,370
你可以点击视图，

931
00:47:54,439 --> 00:47:56,938
在那里的检查员的事情之一

932
00:47:57,007 --> 00:48:00,576
不管它是不透明的，只是把它关掉。顺便一提，

933
00:48:00,644 --> 00:48:03,678
你可以使你的整个视图透明，如果你想，

934
00:48:03,747 --> 00:48:04,847
通过设置alpha，

935
00:48:04,915 --> 00:48:07,916
所以视图有alpha。这意味着你所有的绘图

936
00:48:07,985 --> 00:48:10,553
会有些透明。

937
00:48:10,622 --> 00:48:15,290
这是一个很酷的功能。好吧，

938
00:48:15,359 --> 00:48:21,663
简要提一下关于图层。所以UIView的绘图机制，

939
00:48:21,732 --> 00:48:24,566
实际上是建立在另一个完整的系统上，我不是

940
00:48:24,635 --> 00:48:28,437
要谈论，称为核心动画。那是因为

941
00:48:28,506 --> 00:48:33,242
你在视图中所做的一切都可以动画。移动的意见，

942
00:48:33,311 --> 00:48:36,745
透明度发生，所有这些东西可以动画和

943
00:48:36,814 --> 00:48:39,147
有一个完整的图层来做到这一点。所以，

944
00:48:39,216 --> 00:48:42,184
UIView，我们看到它的顶级API，但是

945
00:48:42,253 --> 00:48:45,453
实际上是用于绘图的所有其他API，称为CALayer，

946
00:48:45,522 --> 00:48:46,988
核心动画层API。

947
00:48:47,057 --> 00:48:49,624
我其实在作业2的提示中提到了这一点，

948
00:48:49,693 --> 00:48:53,095
你已经看到了这个。在UIView中有这个var，

949
00:48:53,164 --> 00:48:56,064
它在按钮中，因为按钮是一个UIView，

950
00:48:56,133 --> 00:49:00,335
所谓的层，它给你的图层，CALayer，这是

951
00:49:00,404 --> 00:49:03,205
正在使用。现在我要谈谈关于动画的一切，

952
00:49:03,274 --> 00:49:05,541
希望下周，也许是一周之后

953
00:49:05,609 --> 00:49:08,611
我们会进入一些这些东西。但是你已经知道了

954
00:49:08,679 --> 00:49:11,747
从作业2，有几个非常好的变数

955
00:49:11,815 --> 00:49:14,950
CALayer像cornerRadius，如果你想要一个圆形的

956
00:49:15,019 --> 00:49:18,120
在你的视图上，或者borderWidth和borderColor。

957
00:49:18,189 --> 00:49:21,122
顺便说一下，你注意到了borderColor的存在

958
00:49:21,191 --> 00:49:23,091
一个CGColor，而不是一个UIColor。

959
00:49:23,160 --> 00:49:26,528
CGColor意味着它是一个核心图形颜色，为什么？

960
00:49:26,597 --> 00:49:29,365
那么，那是因为这整个机制，

961
00:49:29,434 --> 00:49:31,934
核心动画，在用户界面工具包层下面，和

962
00:49:32,003 --> 00:49:34,569
它建立在核心图形层之上。所以

963
00:49:34,638 --> 00:49:37,806
它不能真正使用UIColor结构

964
00:49:37,875 --> 00:49:41,277
因为它在框架的层次结构中高于它

965
00:49:41,345 --> 00:49:44,379
取决于彼此，所以使用C，CGColor。

966
00:49:44,448 --> 00:49:48,584
幸运的是，UIColor也高于Core Graphics。所以它有一个变种

967
00:49:48,652 --> 00:49:52,221
称为CGColor，它给你自己作为CGColor，和

968
00:49:52,289 --> 00:49:54,956
我根据你的任务提示，

969
00:49:55,025 --> 00:49:59,161
对？好吧，这是一个层面的东西，我们会谈论，

970
00:49:59,230 --> 00:50:02,464
以后更多关于动画。我们来谈谈一下

971
00:50:02,533 --> 00:50:05,334
透明度和如何工作，如哪些意见

972
00:50:05,403 --> 00:50:08,471
其他观点的前面，对不对？如果我有一个透明的

973
00:50:08,539 --> 00:50:11,840
查看，并显示后面的一个，这是后面？

974
00:50:11,908 --> 00:50:15,110
这一切都取决于子视图列表的顺序。

975
00:50:15,179 --> 00:50:19,715
任何具有子视图的视图都有它们的数组。

976
00:50:19,784 --> 00:50:24,019
该阵容中的第一件事是背后。和

977
00:50:24,088 --> 00:50:26,989
其他一切都在前面一步，

978
00:50:27,057 --> 00:50:28,791
最后一件事是在前面的那个。

979
00:50:28,859 --> 00:50:32,160
所以，如果你有你的视图和多个子视图

980
00:50:32,229 --> 00:50:35,430
他们重叠，这是在第一个在后面的人

981
00:50:35,499 --> 00:50:38,634
子视图列表。所以你可以重新排列子视图列表

982
00:50:38,703 --> 00:50:41,836
移动它们。把它从前面移到后面或者

983
00:50:41,905 --> 00:50:45,140
无论如何，所以你可以控制这种透明效果。

984
00:50:45,209 --> 00:50:46,975
而且，即使没有透明度，

985
00:50:47,044 --> 00:50:48,677
如果这些观点是相互重叠的

986
00:50:48,746 --> 00:50:49,711
他们碰巧重叠。

987
00:50:49,780 --> 00:50:51,347
有很多次，当我们有多个子视图，

988
00:50:51,415 --> 00:50:53,215
他们是并排的，他们不重叠，

989
00:50:53,284 --> 00:50:56,585
但他们可以。哎呀，他们可以重叠，如果他们

990
00:50:56,654 --> 00:51:00,055
那么这个子视图会告诉你这个命令，

991
00:51:00,124 --> 00:51:04,693
哪些在前面。你完全可以

992
00:51:04,761 --> 00:51:08,096
隐藏视图而不将其从视图层次结构中取出，

993
00:51:08,165 --> 00:51:11,700
与isHidden。如果你说一个观点，这是一个变种，

994
00:51:11,769 --> 00:51:14,436
如果你说视图是隐藏等于是，它不会出现

995
00:51:14,505 --> 00:51:16,838
在屏幕上。它仍然在视图层次结构中，

996
00:51:16,907 --> 00:51:19,541
仍然在子视图列表中。它仍然有父视图，

997
00:51:19,609 --> 00:51:21,843
但它不会在那里，也不会有任何手势。

998
00:51:21,912 --> 00:51:23,011
所以你不会看到它的图纸，

999
00:51:23,080 --> 00:51:25,580
你不会有任何手势，它会被隐藏。和

1000
00:51:25,649 --> 00:51:28,584
你会惊奇地发现想要做这些事是多么普遍。

1001
00:51:28,653 --> 00:51:30,552
您在视图层次结构中放置了一个视图，

1002
00:51:30,621 --> 00:51:34,323
你把它藏起来，那么当一些条件成立的时候，

1003
00:51:34,391 --> 00:51:37,893
可能是动画。事情出现了，这是一个常见的方式

1004
00:51:37,961 --> 00:51:42,597
构建交互式用户界面。好的，所以我们知道如何

1005
00:51:42,666 --> 00:51:45,567
用这些弧线绘制。怎么绘制文字？好，

1006
00:51:45,635 --> 00:51:50,405
其实文字只是一些字体设计师，moveto，lineto，

1007
00:51:50,474 --> 00:51:54,176
curveto，好的。这就是所有的角色，每个角色

1008
00:51:54,245 --> 00:51:56,545
文本只是一堆小的moveto，lineto的。

1009
00:51:56,613 --> 00:52:00,182
幸运的是，某处的某个字体设计师完成了这些工作

1010
00:52:00,250 --> 00:52:01,784
你，或者那将是令人难以置信的繁琐

1011
00:52:01,852 --> 00:52:04,753
你现在呢，不是吗？所以我们想要画画

1012
00:52:04,822 --> 00:52:09,158
使用这些美妙的moveto，linetos，这是字形

1013
00:52:09,226 --> 00:52:12,694
在一个字体中。那么我们该怎么做呢？那么，我甚至在潜水之前

1014
00:52:12,763 --> 00:52:16,531
进入这一点，请记住，UILabel绘制文本真的很好。

1015
00:52:16,600 --> 00:52:19,535
而且没有理由不能让UILabel成为可能

1016
00:52:19,603 --> 00:52:23,438
你的视图的子视图，从而画出文字的方式。

1017
00:52:23,507 --> 00:52:26,074
好的，这是一个很好的方法来绘制，因为UILabel的

1018
00:52:26,143 --> 00:52:29,544
所有令人难以置信的中心文本对齐量，

1019
00:52:29,613 --> 00:52:30,812
你可以控制颜色，

1020
00:52:30,881 --> 00:52:33,181
您可以在该标签上放置一个属性字符串。

1021
00:52:33,250 --> 00:52:34,916
你有完全的控制。

1022
00:52:34,985 --> 00:52:38,988
唯一的是你必须确保你保持这一点

1023
00:52:39,056 --> 00:52:43,458
UILabels框架在您的子视图中的正确位置。

1024
00:52:43,527 --> 00:52:45,994
你知道，因为这是你的一个子视图，所以你必须做出

1025
00:52:46,063 --> 00:52:48,564
确定它的框架保存在正确的空间。但

1026
00:52:48,632 --> 00:52:49,731
这是绘制文本的好方法，所以

1027
00:52:49,800 --> 00:52:52,968
别忘了但是现在我会和你谈谈如何去做

1028
00:52:53,036 --> 00:52:58,106
绘制你的绘制矩形，并使用属性字符串。好的，

1029
00:52:58,175 --> 00:52:59,607
所以你只需创建AttributedString，

1030
00:52:59,676 --> 00:53:01,777
你发送信息画，和

1031
00:53:01,846 --> 00:53:06,448
它会根据您当前的情况说出

1032
00:53:06,517 --> 00:53:07,850
所以绘制文字并不容易，

1033
00:53:07,918 --> 00:53:09,818
你已经知道如何做一个属性的字符串，所以

1034
00:53:09,887 --> 00:53:11,420
你只需在这里创建属性字符串。

1035
00:53:11,488 --> 00:53:15,491
我的归因字符串没有任何属性

1036
00:53:15,559 --> 00:53:17,226
幻灯片空间问题。但

1037
00:53:17,294 --> 00:53:18,626
你可以把你的属性，无论什么，和

1038
00:53:18,695 --> 00:53:21,530
然后做绘制（你也可以绘制（in），然后绘制它

1039
00:53:21,599 --> 00:53:24,667
在矩形的左上角的矩形中。

1040
00:53:24,735 --> 00:53:27,603
然后你也可以通过获取文本的大小

1041
00:53:27,671 --> 00:53:31,340
只是问属性的字符串，宽度和

1042
00:53:31,408 --> 00:53:35,243
适合这个属性字符串的高度。所以

1043
00:53:35,312 --> 00:53:38,146
超级容易在你的绘制矩形中绘制文字，

1044
00:53:38,215 --> 00:53:41,750
你只需要使用AttributedString。现在我想要一点点

1045
00:53:41,819 --> 00:53:43,452
在这里关于AttributedString和

1046
00:53:43,520 --> 00:53:45,387
回到之前我所说的话。

1047
00:53:45,455 --> 00:53:48,323
记得我谈到了NSAttributedString是如何的

1048
00:53:48,392 --> 00:53:51,526
一个旧的客观的东西，它使用NSString然后，

1049
00:53:51,595 --> 00:53:54,697
我们正在使用字符串？和字符串使用一种不同的

1050
00:53:54,765 --> 00:53:57,566
编码的Unicode字符和有时

1051
00:53:57,635 --> 00:54:00,369
NSString和String之间的映射。索引是

1052
00:54:00,438 --> 00:54:03,138
不同，因为我们有古怪的字符，如表情符号，

1053
00:54:03,207 --> 00:54:05,040
实际上是多个Unicodes，

1054
00:54:05,109 --> 00:54:07,342
呃，那整个一团糟，你还记得吗？好，

1055
00:54:07,410 --> 00:54:09,545
我会告诉你一些如何解决这个问题。

1056
00:54:09,613 --> 00:54:11,446
你不需要它，你不需要它作业2，

1057
00:54:11,514 --> 00:54:12,113
你将不需要它

1058
00:54:12,182 --> 00:54:14,616
作业3.也许我会请你去做

1059
00:54:14,685 --> 00:54:18,253
作业5.但如果我想要设置属性

1060
00:54:18,322 --> 00:54:21,089
我的AttributedString中的某些字符和

1061
00:54:21,158 --> 00:54:23,826
这是一个字符串，而不是一个NSString，我该怎么做？

1062
00:54:23,894 --> 00:54:28,831
那么，答案是，这个班就在这里，NSRange。所以

1063
00:54:28,899 --> 00:54:32,600
NSRange是你指定一个范围到NSString的方式。

1064
00:54:32,669 --> 00:54:35,904
好的，这是一个古老的Objective-C方法

1065
00:54:35,973 --> 00:54:41,209
范围。在我们的世界里，我们做Range <String.Index>。

1066
00:54:41,278 --> 00:54:43,045
这就是我们如何索引一个字符串，正确的，

1067
00:54:43,113 --> 00:54:45,647
因为我们知道这些字符串是由String.Index索引的

1068
00:54:45,716 --> 00:54:48,783
不是由初始化。所以我们有完全不同的东西，

1069
00:54:48,852 --> 00:54:52,421
范围<String.Index>。这里AttributedString想要做的

1070
00:54:52,489 --> 00:54:56,091
init的NSRange，因为NSString被init索引。

1071
00:54:56,160 --> 00:54:59,661
好的，那么我们如何从String.Index的范围得到呢？

1072
00:54:59,730 --> 00:55:03,064
一个init匹配的NSRange，好吧，那么

1073
00:55:03,133 --> 00:55:05,667
NSAttributedString匹配我们的字符串。好，

1074
00:55:05,736 --> 00:55:11,240
我们用NSRange来做，我们在这里用这个做。

1075
00:55:11,309 --> 00:55:13,342
这是NSRange初始化器，你看到它，

1076
00:55:13,410 --> 00:55:17,379
NSRange初始值设定项。它需要这第一个WordRange，

1077
00:55:17,447 --> 00:55:21,883
这是一个Swift范围的string.index。你看到了

1078
00:55:21,952 --> 00:55:25,420
从startIndex到indexOf，所以它是一个范围。它的

1079
00:55:25,488 --> 00:55:30,925
得到了小...这是我们的好范围语法那里。

1080
00:55:30,994 --> 00:55:33,995
所以它需要一个范围，并将其转换为一个NSRange，

1081
00:55:34,064 --> 00:55:36,798
但是它需要知道那个字符串，

1082
00:55:36,867 --> 00:55:39,268
那些string.indexes进入，对不对？

1083
00:55:39,336 --> 00:55:41,403
所以知道字符串和

1084
00:55:41,472 --> 00:55:44,673
string.index范围。它可以紧缩，并改变它

1085
00:55:44,741 --> 00:55:48,109
转换成NSAttributedString中的NSRange。

1086
00:55:48,178 --> 00:55:49,778
所以这就是魔法。 NSRange，

1087
00:55:49,847 --> 00:55:53,381
使用取值范围为string.index和的初始化程序

1088
00:55:53,450 --> 00:55:55,984
一个字符串。它会让你回到NSRange。

1089
00:55:56,052 --> 00:55:59,655
现在你可以调用像AttributedString这样的方法，

1090
00:55:59,723 --> 00:56:02,524
像addAttribute，它添加一个单一的属性

1091
00:56:02,593 --> 00:56:05,593
一定范围的字符。看看参数，范围，

1092
00:56:05,662 --> 00:56:12,534
nsrange，现在你有一个nsrange给它。好吧，

1093
00:56:12,602 --> 00:56:17,372
字体。好的，iOS中的字体非常重要。我不能

1094
00:56:17,440 --> 00:56:20,375
夸大字体对外观的重要性

1095
00:56:20,443 --> 00:56:23,345
感觉iOS。这些都是我认为是iOS 10的截图，

1096
00:56:23,414 --> 00:56:26,281
和iOS 11的东西稍微改变了，但不是太多。

1097
00:56:26,349 --> 00:56:29,584
但即使在这些截图中，您也可以看到有多重要

1098
00:56:29,653 --> 00:56:32,921
字体是。他们真的对你的用户界面有所作用

1099
00:56:32,990 --> 00:56:35,390
看起来。所以你必须选择正确的字体。

1100
00:56:35,459 --> 00:56:38,794
那么我们如何选择字体呢？那么，在iOS中，

1101
00:56:38,862 --> 00:56:43,966
字体最重要的概念是首选的字体。

1102
00:56:44,034 --> 00:56:48,003
有大约十种类型的字体，如身体字体，

1103
00:56:48,072 --> 00:56:51,740
标题字体，标题字体，脚注字体。

1104
00:56:51,809 --> 00:56:53,942
所以有这些种类的字体和

1105
00:56:54,010 --> 00:56:56,678
您需要为其选择一种首选字体

1106
00:56:56,747 --> 00:57:00,015
无论你的文字环境在哪里，如果你正在展示

1107
00:57:00,083 --> 00:57:02,450
主要的信息，那么它可能是身体的字体。

1108
00:57:02,519 --> 00:57:06,355
如果这是一个图像的小标题，你会用

1109
00:57:06,423 --> 00:57:09,491
标题字体。好吧，所以你必须选择正确的字体和

1110
00:57:09,559 --> 00:57:12,527
用它。现在这个界面制作工具非常简单。

1111
00:57:12,596 --> 00:57:15,364
你只需选择你的标签，或按钮，或文本字段，或

1112
00:57:15,432 --> 00:57:18,166
无论你在做什么，你去检查，和

1113
00:57:18,235 --> 00:57:21,169
它说的字体，而不是使用系统字体，这是

1114
00:57:21,238 --> 00:57:24,072
我们一直选择，因为我没有谈过

1115
00:57:24,141 --> 00:57:27,109
你有关首选字体，你选择这些东西之一，

1116
00:57:27,177 --> 00:57:29,678
正文字体，标题字体，脚注字体等

1117
00:57:29,746 --> 00:57:33,382
在你的代码中，你可以做同样的事情

1118
00:57:33,450 --> 00:57:38,520
你使用这个静态的类类型方法来做到这一点

1119
00:57:38,589 --> 00:57:42,458
在UI字体中，称为文本样式的首选字体，以及

1120
00:57:42,526 --> 00:57:45,026
那个文字风格是标题，正文，脚注，

1121
00:57:45,095 --> 00:57:47,829
随你。这会让你回到你的UI字体

1122
00:57:47,898 --> 00:57:51,433
可以把你的NS属性的字符串字典。

1123
00:57:51,502 --> 00:57:54,168
其中的一个键是字体，你可以使用它

1124
00:57:54,237 --> 00:57:58,272
作为字体，当你在drawRect中绘制文本的时候。

1125
00:57:58,341 --> 00:58:02,511
现在有一件事要关心的是，大小

1126
00:58:02,579 --> 00:58:07,249
这个字体是可变的。但是，你得到像老人一样，

1127
00:58:07,317 --> 00:58:10,686
好的，我们开始像这样拿着我们的手机，

1128
00:58:10,754 --> 00:58:13,455
随着岁月的流逝，我们的眼睛正在放弃，所以

1129
00:58:13,524 --> 00:58:16,191
我们喜欢字体很大。那么我们就可以把握得更近一些

1130
00:58:16,259 --> 00:58:18,993
看到我们的字体。那么，我们这样做的方式是我们进入我们的

1131
00:58:19,062 --> 00:58:22,297
我们的手机上的设置，以及一般的设置之一

1132
00:58:22,365 --> 00:58:25,433
有无障碍，我们可以说更大的文字，和

1133
00:58:25,502 --> 00:58:27,102
我们移动小滑块，

1134
00:58:27,170 --> 00:58:29,705
现在所有的字体在所有的应用程序中都变大了，但是

1135
00:58:29,773 --> 00:58:32,074
只有玩这个游戏的应用程序，和

1136
00:58:32,142 --> 00:58:35,143
使用首选字体。所以你想成为这些应用程序之一，

1137
00:58:35,212 --> 00:58:37,846
否则，你会失去老年人

1138
00:58:37,915 --> 00:58:39,314
你的人口，

1139
00:58:39,382 --> 00:58:43,084
你的人买你的应用程序。所以这是重要的

1140
00:58:43,153 --> 00:58:46,054
确保你的用户界面也适用于字体变大和

1141
00:58:46,122 --> 00:58:50,592
更小，以及做到这一点的头号方式，自动布局。

1142
00:58:50,661 --> 00:58:52,494
你知道自动布局，你把约束，

1143
00:58:52,563 --> 00:58:55,697
把事情推到边缘。你想使用良好的自动布局

1144
00:58:55,766 --> 00:58:58,800
随着字体变大，文本字段变大，其他字体变大

1145
00:58:58,869 --> 00:59:01,836
东西推开，它使用屏幕房地产

1146
00:59:01,905 --> 00:59:03,805
正常。所以你只看到了一点自动布局。

1147
00:59:03,874 --> 00:59:06,608
星期三的开始我会给你看更多的自动布局

1148
00:59:06,676 --> 00:59:07,942
演讲。你会看到更多和

1149
00:59:08,011 --> 00:59:09,444
更多的季度过去了，但是

1150
00:59:09,512 --> 00:59:13,047
这是使其工作的一个好方法。现在如果你

1151
00:59:13,116 --> 00:59:17,418
要么使用一些其他的字体，这是一些特殊的字体

1152
00:59:17,487 --> 00:59:22,057
这可能是你的市场营销或其他方面的一部分，或者

1153
00:59:22,126 --> 00:59:25,293
你想要它变得更大或更小我想，

1154
00:59:25,362 --> 00:59:29,064
比标准大小的字体，具有一定的

1155
00:59:29,133 --> 00:59:32,467
首选字体。好吧，UIFont确实有办法

1156
00:59:32,536 --> 00:59:35,837
按名称创建一个字体，就像你想要Helvetica 36点一样，

1157
00:59:35,906 --> 00:59:39,841
你可以说UIFont（名称：“Helvetica”，大小：36.0），和

1158
00:59:39,909 --> 00:59:42,711
还有一个叫做UIFontDescriptor的类。

1159
00:59:42,780 --> 00:59:44,579
有很多很酷的方法，你可以采取一种字体和

1160
00:59:44,648 --> 00:59:46,380
说给我这个粗体版本，

1161
00:59:46,449 --> 00:59:49,084
给我斜体版，好吧所有这些东西。所以

1162
00:59:49,152 --> 00:59:51,787
你可以用这种方法得到你的字体。但是，如果你做你的字体

1163
00:59:51,855 --> 00:59:55,190
这样，当我进入我的设置时，你还是想要

1164
00:59:55,259 --> 00:59:58,427
使我的字体更大，你想让你的字体变大，而且

1165
00:59:58,495 --> 01:00:02,330
看这是什么字体大小，它是固定的。

1166
01:00:02,399 --> 01:00:04,899
所以我需要以某种方式缩放这个字体

1167
01:00:04,968 --> 01:00:08,069
如果用户把滑块放大了，

1168
01:00:08,137 --> 01:00:11,540
你用UIFontMetrics的方式。所以你创建

1169
01:00:11,608 --> 01:00:15,710
UIFontMetrics对象为文本样式正文，脚注，

1170
01:00:15,779 --> 01:00:19,080
标题，无论如何，然后它有非常酷的方法调用

1171
01:00:19,149 --> 01:00:22,283
scaledFont，你给它一个字体，像Helvetica 36，

1172
01:00:22,352 --> 01:00:27,121
它会给你一个新的字体，也许是Helvetica 42。

1173
01:00:27,190 --> 01:00:31,492
它根据用户的说法进行缩放。好的，不要跳过

1174
01:00:31,561 --> 01:00:34,528
这一步，否则，如果你使用自定义字体，

1175
01:00:34,597 --> 01:00:38,333
当人们移动滑块，你的应用程序不会工作，和

1176
01:00:38,402 --> 01:00:40,935
人们会喜欢，我讨厌那个应用程序。

1177
01:00:41,004 --> 01:00:45,373
我看不到任何文字，而且太小了。

1178
01:00:45,442 --> 01:00:48,776
还有系统字体。我们使用那些到目前为止我们的

1179
01:00:48,845 --> 01:00:51,780
浓度演示。这只是像按钮的东西

1180
01:00:51,848 --> 01:00:54,616
标题和类似的东西，这不是用户内容，

1181
01:00:54,685 --> 01:00:57,118
用户已经生成或请求的内容

1182
01:00:57,187 --> 01:00:59,454
类似的东西。这是首选的字体。

1183
01:00:59,523 --> 01:01:03,491
系统字体就像按钮，类似的东西。

1184
01:01:03,560 --> 01:01:05,826
怎么样的图像？我们知道如何绘制线条和弧线。

1185
01:01:05,895 --> 01:01:06,928
我们知道如何绘制文字。

1186
01:01:06,997 --> 01:01:11,032
怎么画图像？就像UILabel的文字一样，

1187
01:01:11,101 --> 01:01:13,868
还有一个叫UIImageView的，

1188
01:01:13,937 --> 01:01:17,839
它可以让你添加一个图像作为子视图。所以你可以使用

1189
01:01:17,907 --> 01:01:20,474
如果你想要在你的视图中画一幅图像，

1190
01:01:20,543 --> 01:01:23,711
只是做一个子视图。但如果你想绘制一个图像

1191
01:01:23,780 --> 01:01:26,481
在你的drawRect中，你也可以这样做。

1192
01:01:26,549 --> 01:01:29,784
你需要一个UIImage对象。 UIImage代表一个图像，

1193
01:01:29,852 --> 01:01:33,287
JPG，GIF，任何形式的图像，它代表一个形象。

1194
01:01:33,356 --> 01:01:36,457
现在，你怎么得到一个图像？有很多方法可以做

1195
01:01:36,526 --> 01:01:40,562
它。一种方法是将jpg文件或其他任何东西拖入

1196
01:01:40,630 --> 01:01:44,132
Assets.xcassets文件。请记住，当我们正在做我们的演示，

1197
01:01:44,201 --> 01:01:46,300
我把一些东西放在支持文件中？

1198
01:01:46,369 --> 01:01:48,937
我扔进去的地方之一就是那里的地方

1199
01:01:49,006 --> 01:01:51,539
应用程序图标是。那么，你可以拖动其他图像

1200
01:01:51,607 --> 01:01:54,308
在那里，左边将是所有的名字

1201
01:01:54,377 --> 01:01:57,012
的，然后你可以在这里调用这个方法，

1202
01:01:57,080 --> 01:01:59,881
UIImage将其命名为any，并且会查看该资产

1203
01:01:59,950 --> 01:02:01,950
的东西，并找到这个名字的形象。

1204
01:02:02,019 --> 01:02:04,386
现在，这是一个可靠的初始化程序。

1205
01:02:04,454 --> 01:02:08,089
它可以返回零，这是因为它可能找不到

1206
01:02:08,157 --> 01:02:11,927
在那里的特定图像。所以你不得不说

1207
01:02:11,995 --> 01:02:15,497
通常如果让那么做。还有什么可以得到一个图像？

1208
01:02:15,565 --> 01:02:16,965
那么，你可以从文件系统得到一个。

1209
01:02:17,034 --> 01:02:18,633
你在文件系统中有一个JPG格式。

1210
01:02:18,701 --> 01:02:20,568
我没有告诉你如何访问文件系统，所以

1211
01:02:20,637 --> 01:02:22,670
你不会这样做的。我会晚点给你看的

1212
01:02:22,739 --> 01:02:25,306
你也可以得到它，如果你有一袋你的

1213
01:02:25,375 --> 01:02:28,409
通过互联网。有一袋的数据

1214
01:02:28,478 --> 01:02:31,312
与jpg数据在那里。 UIImage知道如何查看

1215
01:02:31,381 --> 01:02:33,648
那一袋子的东西，弄清楚它是不是一个图像。

1216
01:02:33,717 --> 01:02:36,585
你甚至可以使用这个全局函数，

1217
01:02:36,653 --> 01:02:40,121
UIGraphicsBeginImageContext，然后绘制圆弧和

1218
01:02:40,190 --> 01:02:42,791
线，它会捕捉它作为一个图像。所以

1219
01:02:42,859 --> 01:02:46,127
你甚至可以绘制一个自定义的图像，如果你想。所以无论如何，

1220
01:02:46,196 --> 01:02:47,161
你做这些事情之一，和

1221
01:02:47,230 --> 01:02:49,897
现在你手里有一个UIImage，代表图像

1222
01:02:49,966 --> 01:02:51,967
你想画画。你怎么画的？

1223
01:02:52,035 --> 01:02:55,069
完全一样的NS属性字符串，你只是

1224
01:02:55,138 --> 01:02:58,839
使用draw（at），它将用左上角绘制图像

1225
01:02:58,908 --> 01:03:02,510
在这一点上的角落，但你也可以做画（直接和

1226
01:03:02,579 --> 01:03:05,146
它会缩放图像以适应该矩形。

1227
01:03:05,215 --> 01:03:08,049
所以这是一个很好的方式来扩大和缩小你的形象

1228
01:03:08,118 --> 01:03:10,585
你可以做drawAsPattern这将相当你的形象

1229
01:03:10,653 --> 01:03:14,089
反复，重复你的形象来填补矩形。

1230
01:03:15,892 --> 01:03:19,227
超容易绘制图像。

1231
01:03:19,295 --> 01:03:21,796
好吧，让我们谈谈你的bounds变化。

1232
01:03:21,865 --> 01:03:25,767
我有我的平局。它画得漂亮，但现在我的bounds

1233
01:03:25,836 --> 01:03:30,571
改变了，什么时候会发生？那么，第一的方式，

1234
01:03:30,640 --> 01:03:33,808
您的设备已旋转。他们正在看着你

1235
01:03:33,877 --> 01:03:37,345
肖像，他们旋转你。现在你也从这个高大的，

1236
01:03:37,414 --> 01:03:40,915
薄的看法，现在你是这个宽，很短的视图，好吧，

1237
01:03:40,984 --> 01:03:43,051
你的bounds已经完全改变了。

1238
01:03:43,120 --> 01:03:47,088
你从200的宽度走到700的宽度，

1239
01:03:47,156 --> 01:03:50,925
从3或400的高度到150的高度

1240
01:03:50,994 --> 01:03:53,327
200，所以这是一个重大的变化。

1241
01:03:53,396 --> 01:03:56,263
你必须真的重新绘制所有的东西，

1242
01:03:56,332 --> 01:04:00,401
通常。不幸的是，这不是默认的。在iOS中，

1243
01:04:00,470 --> 01:04:03,705
当你遇到这样的变化，它不会重绘你，

1244
01:04:03,773 --> 01:04:08,843
信不信由你。它需要你所有的东西，并挤压它们。

1245
01:04:08,912 --> 01:04:11,312
所以大部分时间看起来非常糟糕。

1246
01:04:11,381 --> 01:04:13,781
砸一下，把它们压扁，

1247
01:04:13,850 --> 01:04:17,351
伸出它们以适应你的新bounds。

1248
01:04:17,420 --> 01:04:20,588
你几乎从来不想这样做。那这个控制怎么样？

1249
01:04:20,657 --> 01:04:23,825
这是UIView中的一个名为contentMode的控件。

1250
01:04:23,893 --> 01:04:25,493
好的，contentMode的基本上只是说，

1251
01:04:25,562 --> 01:04:27,362
我有什么样的内容？我有那种

1252
01:04:27,430 --> 01:04:30,231
可以像这样挤压和挤压的内容

1253
01:04:30,300 --> 01:04:32,367
还是好看？或者我有我的那种内容

1254
01:04:32,435 --> 01:04:34,502
当我的余额变化时，必须重新绘制？

1255
01:04:34,571 --> 01:04:38,005
所以，三种不同的contentModes类别。

1256
01:04:38,074 --> 01:04:41,776
一个是，保持我的位，好吧，不要重绘我，但只是移动

1257
01:04:41,845 --> 01:04:46,281
我的位，未缩放，到一个新的位置，左上角，顶部，

1258
01:04:46,350 --> 01:04:48,616
右下，把它放在中间，不管。

1259
01:04:48,684 --> 01:04:51,486
这个几乎不会被使用。然后他们正在缩放

1260
01:04:51,555 --> 01:04:54,589
这就是scaleToFill的默认位置

1261
01:04:54,658 --> 01:04:57,958
为了适应新的空间，将这些比特缩小。它甚至不是

1262
01:04:58,027 --> 01:05:01,395
尊重宽高比。但是你可以设置contentMode

1263
01:05:01,464 --> 01:05:04,532
分数的位，但保持高宽比如此

1264
01:05:04,600 --> 01:05:07,635
你知道，一张脸不会从一个方向去

1265
01:05:07,704 --> 01:05:11,906
高高在上或其他。但是，你们大概可以

1266
01:05:11,975 --> 01:05:15,643
是要大部分时间是ContentMode重绘。

1267
01:05:15,712 --> 01:05:18,613
而这意味着，当我的界限发生变化时，

1268
01:05:18,682 --> 01:05:22,183
叫我的画Rect，让我再次画自己，和

1269
01:05:22,252 --> 01:05:24,552
这可能是你想要的。

1270
01:05:24,620 --> 01:05:26,754
你能不能画出正确的bounds呢？

1271
01:05:26,823 --> 01:05:29,023
当它被调用时，它可以绘制一些适合的东西

1272
01:05:29,092 --> 01:05:32,293
你阅读的bounds。所以就像你的作业一样，例如，

1273
01:05:32,361 --> 01:05:34,895
也许你的作业不是一个很好的例子，因为

1274
01:05:34,964 --> 01:05:37,231
可能是那些正在变化的大视图

1275
01:05:37,300 --> 01:05:39,800
这是你的子视图，你想要布置，

1276
01:05:39,869 --> 01:05:42,270
我将再次谈论。但是，如果你确实有一个东西

1277
01:05:42,339 --> 01:05:43,905
你在哪里画什么东西，

1278
01:05:43,973 --> 01:05:46,374
就像我们正在做我们的卡片和专注和

1279
01:05:46,442 --> 01:05:48,910
我们总是要他们，要有一定的长宽比，

1280
01:05:48,978 --> 01:05:52,781
无论如何，我们可以重绘，在我们的绘制矩形或任何，

1281
01:05:52,849 --> 01:05:54,783
这可能不是一个很好的例子。

1282
01:05:54,851 --> 01:05:56,651
事实上，让我们继续下面的例子，

1283
01:05:56,720 --> 01:05:58,319
如果我有子视图，会发生什么情况

1284
01:05:58,388 --> 01:06:00,955
我的bounds改变了？因为这会在你的作业中发生。

1285
01:06:01,024 --> 01:06:03,024
你会有一些意见，你只会有

1286
01:06:03,093 --> 01:06:06,460
一个子视图，这是很多卡，你的设置卡。因为

1287
01:06:06,529 --> 01:06:09,130
在任务三，现在没有数量上的限制

1288
01:06:09,199 --> 01:06:11,432
可以出现在屏幕上的卡片，对不对？

1289
01:06:11,501 --> 01:06:14,635
在作业二中，我们限制为最多24张卡片。

1290
01:06:14,704 --> 01:06:17,271
现在没有限制，所以你总是添加更多的卡。所以，

1291
01:06:17,340 --> 01:06:20,241
你将不得不使用，把它们作为一些观点的子视图。

1292
01:06:20,310 --> 01:06:22,744
换句话说，你无法堆叠视图。

1293
01:06:22,813 --> 01:06:24,345
那么当你的边界在那里改变时会发生什么？

1294
01:06:24,414 --> 01:06:25,980
那么，当你的界限改变了，

1295
01:06:26,048 --> 01:06:28,682
你会得到这个消息layoutSubviews。

1296
01:06:28,751 --> 01:06:32,486
这是您通过重置帧的机会

1297
01:06:32,555 --> 01:06:36,390
只是改变你的所有子视图的框架变种，好吧。

1298
01:06:36,459 --> 01:06:38,225
所以，如果你有子视图，

1299
01:06:38,294 --> 01:06:40,561
你几乎总是要实现这个方法。

1300
01:06:40,630 --> 01:06:43,931
不要忘了调用给父类做。现在，那是什么

1301
01:06:44,000 --> 01:06:46,067
当你不执行这个方法的时候？

1302
01:06:46,135 --> 01:06:49,137
如果你有子视图，你有自动布局

1303
01:06:49,205 --> 01:06:52,974
子视图，好吧。如果你的子视图有自动布局，

1304
01:06:53,042 --> 01:06:55,676
那么Autolayout约束将决定在哪里

1305
01:06:55,745 --> 01:06:59,013
新的frame，好吧。所以这只是为了

1306
01:06:59,082 --> 01:07:01,483
查看您未使用自动布局的位置。

1307
01:07:03,186 --> 01:07:05,386
这可能是你的任务三，

1308
01:07:05,454 --> 01:07:08,322
无论什么看法包含您的卡，可能不会使用

1309
01:07:08,391 --> 01:07:11,025
自动布局。写几乎是不可能的

1310
01:07:11,094 --> 01:07:12,726
约束，将工作

1311
01:07:12,795 --> 01:07:15,964
在任意边界上布置任意数量的卡片，

1312
01:07:16,032 --> 01:07:19,433
好的。你可能会想在代码中这样做。好的，

1313
01:07:19,502 --> 01:07:21,268
所以当你的边界改变时，你有两个不同的

1314
01:07:21,337 --> 01:07:23,504
要考虑的事情。如果你有任何子视图，

1315
01:07:23,572 --> 01:07:26,540
布局子视图或自动布局。如果你画一些东西，

1316
01:07:26,609 --> 01:07:28,342
那么你必须考虑你的内容模式是否

1317
01:07:28,411 --> 01:07:33,081
你想被要求重画。好吧，就这样

1318
01:07:33,149 --> 01:07:36,184
今天的幻灯片，我要在这里演示。

1319
01:07:36,252 --> 01:07:39,320
我要做的演示是一张纸牌。所以这是会的

1320
01:07:39,389 --> 01:07:41,655
成为一个新的应用程序，它只是要画一张纸牌，

1321
01:07:41,724 --> 01:07:44,158
你知道，像J，红桃6，不管，

1322
01:07:44,226 --> 01:07:46,928
它会去拿那张牌我们要画出这个习俗，

1323
01:07:46,996 --> 01:07:49,864
由我们自己。而今天，我将在演示中做的是

1324
01:07:49,932 --> 01:07:53,067
那个绘制扑克牌的MVC的模型

1325
01:07:53,136 --> 01:07:55,936
会是一张扑克牌和一副扑克牌。

1326
01:07:56,005 --> 01:07:58,673
而我要这样做的原因是我想告诉你枚举。

1327
01:07:58,741 --> 01:08:01,709
你还没有机会看到我演示枚举。所以

1328
01:08:01,777 --> 01:08:05,413
我们将在我们的模型实现中使用枚举。

1329
01:08:05,482 --> 01:08:08,316
星期三，我会继续这个的绘图部分

1330
01:08:08,385 --> 01:08:10,451
演示或我要画这张牌。

1331
01:08:10,520 --> 01:08:12,619
然后我会在多点触控上做一些幻灯片

1332
01:08:12,688 --> 01:08:15,589
那么我们将添加一些多点触摸扑克牌，刷卡

1333
01:08:15,658 --> 01:08:18,259
去下一张卡片，我们会点击翻转卡片

1334
01:08:18,328 --> 01:08:21,162
那种东西。好吧，你的任务二

1335
01:08:21,231 --> 01:08:22,930
如你所知，当然是星期三。

1336
01:08:22,999 --> 01:08:25,533
作业三将在星期三进行。

1337
01:08:25,601 --> 01:08:29,002
这只是让你的游戏定制卡，好吧，

1338
01:08:29,071 --> 01:08:30,204
用自定义视图绘制，

1339
01:08:30,272 --> 01:08:33,140
这就是三个基本的任务。我们没有

1340
01:08:33,209 --> 01:08:35,576
不幸的是，本周又有了一个星期五的节目，

1341
01:08:35,645 --> 01:08:37,244
由于一些调度冲突，但是

1342
01:08:37,313 --> 01:08:39,847
下周五我们会和它在源代码管理上。

1343
01:08:39,916 --> 01:08:44,886
好的，让我们在这里创建一个新的应用程序。

1344
01:08:46,689 --> 01:08:49,623
好吧，我只是要过去这里，使用这个

1345
01:08:49,692 --> 01:08:52,894
闪屏，但我会说创建一个新的Xcode项目，

1346
01:08:52,963 --> 01:08:55,930
这与专注于此无关。

1347
01:08:55,998 --> 01:08:57,631
与单一视图应用程序一样，

1348
01:08:57,700 --> 01:08:59,934
我要打这个应用程序的游戏卡。

1349
01:09:00,003 --> 01:09:01,369
这就是它显示它是一张纸牌。

1350
01:09:01,438 --> 01:09:04,571
我们没有做任何数据库，我们还没有做测试。

1351
01:09:04,640 --> 01:09:07,175
我们要放在同一个地方，我把浓度，

1352
01:09:07,244 --> 01:09:09,143
我们还没有做源代码控制，

1353
01:09:09,212 --> 01:09:11,011
虽然就像我下周五说的那样，

1354
01:09:11,080 --> 01:09:14,381
我们将了解这一点。这是我的项目，

1355
01:09:14,450 --> 01:09:16,784
现在这个时候我要保留我的xcassets，

1356
01:09:16,853 --> 01:09:19,887
对，这里是我的AppIcon在这里的xcassets。

1357
01:09:19,956 --> 01:09:22,090
我会保留，因为我要使用一些图像

1358
01:09:22,158 --> 01:09:25,259
面对卡片。所以你可以看到如何在那里绘制图像。

1359
01:09:25,328 --> 01:09:27,428
但我不会用我的发射屏幕或

1360
01:09:27,496 --> 01:09:29,930
我的应用程序在这里委托。所以我只是要把他们再次进入

1361
01:09:29,999 --> 01:09:33,401
支持文件。我只是喜欢让他们的方式如此

1362
01:09:33,470 --> 01:09:36,971
他们真的不需要我的注意。

1363
01:09:37,040 --> 01:09:42,543
现在，我甚至还没有去这里建立我的用户界面

1364
01:09:42,611 --> 01:09:45,779
我的扑克牌事情，我们先去做我们的模型。

1365
01:09:45,848 --> 01:09:47,181
所以我们不会做任何UI开始，

1366
01:09:47,250 --> 01:09:49,783
我们先做模型那么我们如何创建模型文件呢？

1367
01:09:49,852 --> 01:09:53,154
请记住，文件>新建>文件，我们选择这一个权利

1368
01:09:53,223 --> 01:09:56,123
在这里，Swift File是一个非UI，正确的UI

1369
01:09:56,192 --> 01:09:59,527
独立的事情。当我们这样做的时候，我们要求名字，

1370
01:09:59,596 --> 01:10:02,996
所以让我们先做一张纸牌。好，现在开始

1371
01:10:03,065 --> 01:10:05,266
我的模型，这只是一副扑克牌。

1372
01:10:05,335 --> 01:10:08,035
所以这些将会是UI独立的表示

1373
01:10:08,104 --> 01:10:10,338
扑克牌，一套。所以

1374
01:10:10,406 --> 01:10:12,240
我们将从扑克牌本身开始

1375
01:10:12,308 --> 01:10:14,575
那么我们会做这个套牌。所以这里就在这里，

1376
01:10:14,644 --> 01:10:17,144
导入基础，我只是要通过结构，

1377
01:10:17,213 --> 01:10:20,214
它真的没有理由成为一个参考类型。和

1378
01:10:20,283 --> 01:10:22,149
这将是一张纸牌。现在，

1379
01:10:22,218 --> 01:10:26,119
一张纸牌是由什么组成的？那么，它有一套衣服，

1380
01:10:26,188 --> 01:10:30,290
我将会有一些这样的类型，而且它有一个排名。

1381
01:10:30,359 --> 01:10:35,063
对，这就是所有的扑克牌，套装和等级。

1382
01:10:35,131 --> 01:10:37,765
那么我们如何代表西装和等级呢？

1383
01:10:37,833 --> 01:10:39,967
那当然，因为我想给你看enum，

1384
01:10:40,036 --> 01:10:43,537
我要用enum来做。所以，我们来创建一个枚举

1385
01:10:43,606 --> 01:10:47,408
西装。然后我们也将创建另一个枚举

1386
01:10:47,477 --> 01:10:51,412
等级。现在让我们来谈谈我们将如何做到这一点。

1387
01:10:51,480 --> 01:10:54,815
现在，西装可能是世界上最简单的枚举，对吧？

1388
01:10:54,884 --> 01:10:58,853
情况就是这样，它可以是黑桃，也可以是心脏，或者是

1389
01:10:58,922 --> 01:11:03,590
这是钻石，或者是俱乐部，就是这样。

1390
01:11:03,659 --> 01:11:06,427
这可能就够了。这是真的

1391
01:11:06,496 --> 01:11:09,496
我们需要做一个枚举。我要借这个机会

1392
01:11:09,565 --> 01:11:11,398
教你一点关于枚举

1393
01:11:11,467 --> 01:11:13,234
即使在幻灯片中我也没有提到。

1394
01:11:13,303 --> 01:11:17,071
但这是在你的作业阅读，所以希望你得到了

1395
01:11:17,139 --> 01:11:20,508
这是原始的值。枚举中的原始值是什么？

1396
01:11:20,576 --> 01:11:25,046
那么，事实证明，你可以关联一个固定的

1397
01:11:25,115 --> 01:11:30,117
你的每一个案例的原始值不变。

1398
01:11:30,186 --> 01:11:32,653
好吧，现在，Swift甚至会自动执行一些操作。

1399
01:11:32,722 --> 01:11:36,256
例如，如果我做我指定的原始值类型

1400
01:11:36,325 --> 01:11:40,294
只是说，冒号类型，枚举后，通过作为int然后

1401
01:11:40,363 --> 01:11:43,831
它会自动使这个原始值为0。

1402
01:11:43,899 --> 01:11:47,168
而且会让这个原始值为1等

1403
01:11:47,237 --> 01:11:50,838
好吧，1,2,3,4,5。因此，它只是按顺序，

1404
01:11:50,907 --> 01:11:54,375
出现在文件中的词法顺序。您可以

1405
01:11:54,443 --> 01:11:57,411
例如，也使你的原始值成为一个字符串。

1406
01:11:57,480 --> 01:12:00,447
如果我这样做，Swift会自动使这一个

1407
01:12:00,516 --> 01:12:03,684
黑桃，这一颗将会是心，这将是钻石。

1408
01:12:03,753 --> 01:12:06,753
换句话说，它使原始值成为一个字符串版本

1409
01:12:06,822 --> 01:12:10,090
的情况。现在，为什么你会想要原始值？

1410
01:12:10,159 --> 01:12:13,461
说实话，我觉得很多原始的观都支持

1411
01:12:13,530 --> 01:12:16,730
向后兼容，因为在Objective-C枚举中

1412
01:12:16,799 --> 01:12:19,600
本质上是整数，对不对？零，一，二，三，四，

1413
01:12:19,669 --> 01:12:22,636
五。所以原始值就像是原始值int。但

1414
01:12:22,705 --> 01:12:25,740
你可以想像，如果有一些可能会很有趣

1415
01:12:25,808 --> 01:12:28,776
有意义的一块数据与所有关联

1416
01:12:28,845 --> 01:12:32,279
案件。而且它也必须是固定的，不变的

1417
01:12:32,348 --> 01:12:35,249
独特。对于所有的情况，但你仍然可以想像。

1418
01:12:35,317 --> 01:12:42,089
例如，我有点看到这件衣服可能是生的，

1419
01:12:42,158 --> 01:12:45,660
这可能是一个好的。如果我把原始值设为字符串，

1420
01:12:45,728 --> 01:12:48,262
也许有代表的Unicode字符

1421
01:12:48,331 --> 01:12:51,699
西装。与每种情况都有关联，

1422
01:12:51,767 --> 01:12:54,602
可能是有价值的。现在，你如何使用原始价值？

1423
01:12:54,671 --> 01:12:57,971
两种方式，一种，你可以通过提供原料来创建一个西装

1424
01:12:58,040 --> 01:13:01,308
值。它看起来就像一个西装上的初始化者，

1425
01:13:01,377 --> 01:13:04,678
适合左括号的原始价值，这就是你如何做到这一点。

1426
01:13:04,747 --> 01:13:07,381
你在那里给它象一个心脏的象征，它会给

1427
01:13:07,450 --> 01:13:09,983
回来了。现在这是一个可以破解的初始化因素，你可能会给

1428
01:13:10,052 --> 01:13:14,254
它是一个像x这样的字符串，这不是这四个字符串之一。和

1429
01:13:14,323 --> 01:13:15,990
你也可以走另一条路。

1430
01:13:16,059 --> 01:13:18,992
你可以，如果你有西装，像suit.spades，你可以说，

1431
01:13:19,061 --> 01:13:20,461
什么是原始值？和

1432
01:13:20,530 --> 01:13:23,530
你可以得到这个字符串，所以也可能是有用的。

1433
01:13:23,599 --> 01:13:26,067
我们并不在乎这个演示，但是

1434
01:13:26,135 --> 01:13:28,936
我只想告诉你这个原始值的业务。

1435
01:13:29,005 --> 01:13:31,639
好的，让我们来看看Rank。现在，说实话，

1436
01:13:31,707 --> 01:13:34,876
如果我在做Rank的话， case ace，

1437
01:13:34,944 --> 01:13:39,447
case two, case three,  一直到case jack，

1438
01:13:39,516 --> 01:13:43,350
case queen, case king. 。现在这是什么，

1439
01:13:43,419 --> 01:13:45,753
所有的介于两者之间。那就是我会做的。

1440
01:13:45,821 --> 01:13:47,655
但我不会这样做，因为我想要

1441
01:13:47,724 --> 01:13:51,392
向您显示关联的数据。这主要是为了演示的目的，

1442
01:13:51,461 --> 01:13:53,494
我可能只是做这13件事情。

1443
01:13:53,562 --> 01:13:56,764
这可能是排名最好的代表。但

1444
01:13:56,833 --> 01:13:59,700
相反，我会用相关的数据来做

1445
01:13:59,769 --> 01:14:01,936
我会有case A，那么我也是

1446
01:14:02,005 --> 01:14:04,438
会有一张脸的脸，这是一张脸卡。

1447
01:14:04,507 --> 01:14:06,974
这将有一个相关的值，

1448
01:14:07,043 --> 01:14:10,778
这是一个字符串，它可以是J，Q或K.所以有

1449
01:14:10,846 --> 01:14:13,881
会成为一个jack，queen或king的面子卡。

1450
01:14:13,950 --> 01:14:15,349
可怕的代表性，

1451
01:14:15,418 --> 01:14:18,151
至少这应该是另一个枚举，

1452
01:14:18,220 --> 01:14:20,754
不是一个可以是任何东西的字符串。这有点傻，

1453
01:14:20,823 --> 01:14:24,525
但不管怎么说。然后，我也会有案件的数字，好吧，

1454
01:14:24,594 --> 01:14:28,162
为2,3,4,5,6,7,8,9,10。它会有，

1455
01:14:28,230 --> 01:14:30,931
当然是关联的数据int。现在，我可以投入

1456
01:14:30,999 --> 01:14:34,868
这里像点数一样，一个点子就是其中之一，

1457
01:14:34,937 --> 01:14:38,238
一张卡上的点子就是这些东西之一。所以一个数字

1458
01:14:38,307 --> 01:14:42,576
卡上有2个点，2个有2个点，3个有3个点，等等。

1459
01:14:42,645 --> 01:14:45,479
所以我可以把pipsCount作为文档。但你知道

1460
01:14:45,547 --> 01:14:48,115
什么，如果是完全的，你其实不想那样做

1461
01:14:48,183 --> 01:14:51,752
显而易见的是这将是什么。如果我有一个数字排名，

1462
01:14:51,820 --> 01:14:54,521
这是完全明显的数字，所以我这样做

1463
01:14:54,590 --> 01:14:57,624
不需要那个。现在，这是不是很明显，但是

1464
01:14:57,693 --> 01:15:00,193
正如我已经告诉过你的，反正这是一个糟糕的代表。

1465
01:15:00,262 --> 01:15:01,562
但我只是想告诉你看起来像什么

1466
01:15:01,631 --> 01:15:04,164
从这里获取关联的数据并使用它等

1467
01:15:04,233 --> 01:15:07,667
例如，rank是一个枚举，它可以有funcs，

1468
01:15:07,736 --> 01:15:11,872
我可以在这里有funcs和vars。所以我会有一个变种

1469
01:15:11,940 --> 01:15:16,210
所谓的顺序，这是一个int，这将返回，

1470
01:15:16,278 --> 01:15:19,780
排名顺序是哪个位置。所以

1471
01:15:19,848 --> 01:15:24,518
我要打开自己，如果我是一个王牌，我会

1472
01:15:24,587 --> 01:15:27,655
返回1 cuz这是第一，这是卡号1，

1473
01:15:27,723 --> 01:15:32,960
对？如果我是一个数字，那么我会去得到我的

1474
01:15:33,028 --> 01:15:37,831
点数。而且我会返回点数。

1475
01:15:37,900 --> 01:15:40,467
因为如果我是一个数字卡，那么我有很多点，

1476
01:15:40,536 --> 01:15:43,904
这是我的号码。然后面对，

1477
01:15:43,973 --> 01:15:47,775
我会说case.face，我会去的，哎呀，

1478
01:15:47,843 --> 01:15:53,113
得到那种，Q或者J，或者K。现在，我得到了那种，

1479
01:15:53,182 --> 01:15:57,952
我想我可以说，我要去下一条线

1480
01:15:58,021 --> 01:16:02,556
说，如果这种类型等于J，那么返回11.而且

1481
01:16:02,624 --> 01:16:06,359
那么我想我可以去别的，如果那种。好吧，但我是，

1482
01:16:06,428 --> 01:16:09,362
这太可怕了。这将是丑陋的，可怕的代码。

1483
01:16:09,431 --> 01:16:12,332
但是事实证明有更好的方法来做这一切

1484
01:16:12,401 --> 01:16:16,770
这是去这里说。如果是我面对的地方

1485
01:16:16,839 --> 01:16:23,677
种类等于J的那种，然后返回11。

1486
01:16:23,745 --> 01:16:26,613
所以这个开关的东西实际上是一个模式匹配

1487
01:16:26,682 --> 01:16:29,416
语言，你可以去学习。

1488
01:16:29,485 --> 01:16:32,219
但是它能做的其中一件事是在哪里。

1489
01:16:32,288 --> 01:16:35,055
哪里可以缩小这一点。

1490
01:16:35,124 --> 01:16:39,794
所以现在我可以在这里为Q和Q做三件事

1491
01:16:39,862 --> 01:16:43,264
国王，并返回。这就是为什么你可以看到

1492
01:16:43,332 --> 01:16:45,900
为什么我用这个可怕的字符串表示，所以

1493
01:16:45,968 --> 01:16:48,969
我可以告诉你在哪里。现在，请注意，当我这样做，

1494
01:16:49,038 --> 01:16:52,105
我仍然得到这个投诉，切换必须是详尽的。

1495
01:16:52,174 --> 01:16:54,341
这是什么？看我做王牌，我做数字，

1496
01:16:54,410 --> 01:16:56,643
我确实面对，怎么没有详尽？

1497
01:16:56,712 --> 01:16:58,545
那么，因为在哪里这样做

1498
01:16:58,614 --> 01:17:02,649
这些都不包括在哪里的每一个可能的组合。

1499
01:17:02,718 --> 01:17:05,719
它可能是，那种可能是别的东西。所以，当然，

1500
01:17:05,788 --> 01:17:08,121
我必须在这里添加一个默认的中断，或者

1501
01:17:08,190 --> 01:17:10,624
其实我必须返回一些东西，所以我会返回0。

1502
01:17:10,693 --> 01:17:13,994
这也是糟糕的设计。这可能要返回零，

1503
01:17:14,063 --> 01:17:16,697
这是想成为一个可选的。那会更好

1504
01:17:16,766 --> 01:17:19,233
设计，我不会这样做。但是就这样

1505
01:17:19,302 --> 01:17:23,170
你知道，那很糟糕。我也可以在这里有静态变量，

1506
01:17:23,239 --> 01:17:26,740
也许我有一个静态变量，这是所有的行列

1507
01:17:26,809 --> 01:17:30,510
返回每一个可能的排名数组。

1508
01:17:30,579 --> 01:17:33,047
而且我必须建立起来，因为我拥有所有的东西

1509
01:17:33,115 --> 01:17:35,883
这些奇怪的数据结构在这里。所以我会创造一些东西

1510
01:17:35,952 --> 01:17:40,955
称为allRanks可能是一个类型的排列数组。和

1511
01:17:41,023 --> 01:17:44,825
让我们开始和王牌，顺便注意这里

1512
01:17:44,893 --> 01:17:49,629
我必须在这里输入这一面它不能真的

1513
01:17:49,698 --> 01:17:52,633
演绎这一点。如果我在这里把这个拿走，那我们来吧

1514
01:17:52,701 --> 01:17:55,869
这些其他警告在这里，我会返回他们所有的排名。

1515
01:17:55,938 --> 01:17:59,039
如果我在这里输入这个静态输入，

1516
01:17:59,108 --> 01:18:01,975
我会得到一个错误，它不能推断这种类型。

1517
01:18:02,044 --> 01:18:05,012
那是因为可能会有另一个枚举

1518
01:18:05,081 --> 01:18:07,381
.ace的情况。那么它是如何知道的呢，

1519
01:18:07,450 --> 01:18:10,584
这是什么枚举数组？这就是为什么说类型

1520
01:18:10,653 --> 01:18:13,187
表达是不明确的，没有更多的上下文。所以

1521
01:18:13,255 --> 01:18:15,055
我可以通过添加更多的上下文。

1522
01:18:15,124 --> 01:18:19,160
我也可以说rank.ace，这将增加更多的上下文。

1523
01:18:19,228 --> 01:18:22,730
现在它知道这是一系列的行列。所以

1524
01:18:22,798 --> 01:18:27,234
现在让我们也做点2 ... 10点，记住点，点，

1525
01:18:27,303 --> 01:18:31,105
没有少于10的手段，包括10

1526
01:18:31,173 --> 01:18:35,976
现在我可以说，allRanks.append，Rank.numeric

1527
01:18:36,045 --> 01:18:40,748
与那个点子。所以现在我已经添加了所有的数字，和

1528
01:18:40,817 --> 01:18:43,784
那么也许是为了这件事，我会面对的

1529
01:18:43,853 --> 01:18:47,822
只是说allRanks加等于一个数组，有rank.face，

1530
01:18:47,890 --> 01:18:53,627
那种类型是J.然后我就复制和

1531
01:18:53,696 --> 01:18:58,999
粘贴，复制，哎呀，粘贴，复制，粘贴和

1532
01:18:59,068 --> 01:19:03,536
我们会做Q和国王。顺便说一句，如果我这样做，

1533
01:19:03,605 --> 01:19:06,440
我只是真的需要把这个Rank点放在第一个和

1534
01:19:06,509 --> 01:19:10,478
它可以推断其余的。

1535
01:19:12,047 --> 01:19:16,049
点虽然意味着点。所以我不需要排名点，因为

1536
01:19:16,118 --> 01:19:18,852
它很快就发现这是一系列的行列。

1537
01:19:18,920 --> 01:19:23,590
这些都是排名，所以它的工作。我可以做同样的事情

1538
01:19:23,659 --> 01:19:26,693
顺便也在这里的东西。我可以有一个静态的全部。

1539
01:19:26,762 --> 01:19:29,163
我把它变成静态的，因为我把它们全部放在这里。

1540
01:19:29,232 --> 01:19:30,764
我不是在谈论具体的一个

1541
01:19:30,832 --> 01:19:32,900
我想要他们。所以这将是，

1542
01:19:32,969 --> 01:19:37,037
我们会在这里做同样的事情。西装的等级，

1543
01:19:37,106 --> 01:19:42,042
.hearts，.diamonds和.clubs，

1544
01:19:42,110 --> 01:19:46,646
哎呀，你好。所以这真是太好了

1545
01:19:46,715 --> 01:19:49,416
这静态酒吧给了我所有的西装，所有的队伍。

1546
01:19:49,484 --> 01:19:52,586
这会让我们更容易创建我们的

1547
01:19:52,655 --> 01:19:55,989
打牌套牌，让我们这样做。所以我们有这个很好

1548
01:19:56,058 --> 01:19:58,492
代表，不是很好，但有点不错，

1549
01:19:58,561 --> 01:20:01,361
纸牌的表示。让我们继续

1550
01:20:01,430 --> 01:20:06,099
做一个套牌，所以我会做一个新的文件。一件新事物

1551
01:20:06,168 --> 01:20:10,737
这里将是一个PlayCardDeck。

1552
01:20:10,806 --> 01:20:15,075
在这里，结构也没有理由不成立

1553
01:20:15,143 --> 01:20:19,713
PlayingCardDeck。而且，我想玩什么卡牌。

1554
01:20:19,782 --> 01:20:21,982
那么，我当然需要一个变种

1555
01:20:22,051 --> 01:20:24,818
在甲板上的卡片。对，如此

1556
01:20:24,887 --> 01:20:28,322
我只是想让那一堆纸牌，

1557
01:20:29,791 --> 01:20:35,062
可能要这个私人设置。好的，

1558
01:20:35,130 --> 01:20:37,931
在那里我控制卡，因为它会被启动

1559
01:20:38,000 --> 01:20:41,168
是一个完整的甲板。然后我可能想要一些功能，

1560
01:20:41,237 --> 01:20:45,271
比如从中抽出一张纸牌。所以

1561
01:20:45,340 --> 01:20:48,341
这就是你如何从扑克牌中拿出一张牌。所以

1562
01:20:48,410 --> 01:20:51,712
我将如何执行从那里拉出卡？好，

1563
01:20:51,781 --> 01:20:54,548
我只是想说，让我们看看我记得，

1564
01:20:54,616 --> 01:20:58,252
我想我使用浓度来做这件事。

1565
01:20:58,321 --> 01:21:00,420
检查我做了。是啊，我做了。好的，在这里，

1566
01:21:00,489 --> 01:21:04,024
我只是要看看我是否有任何卡。

1567
01:21:04,093 --> 01:21:09,029
然后我要退卡了

1568
01:21:09,097 --> 01:21:13,667
卡我有.count.arc4random。所以，

1569
01:21:13,736 --> 01:21:18,939
我需要去浓度。

1570
01:21:19,007 --> 01:21:21,342
这里集中在这里的底部。

1571
01:21:21,410 --> 01:21:23,944
我们有arc4random。所以我只是要抓住这一点

1572
01:21:24,013 --> 01:21:28,648
在这里。把这个放在这里，所以我可以在那里使用arc4random，

1573
01:21:28,717 --> 01:21:33,286
如果我没有留下任何卡片，我将会返回零，所以

1574
01:21:33,355 --> 01:21:36,056
我最好把这个画回来一个可选的播放

1575
01:21:36,124 --> 01:21:39,426
卡。好吧，人们不能再添加更多

1576
01:21:39,495 --> 01:21:41,795
卡到我的套牌我刚刚开始了一个完整的甲板。

1577
01:21:41,864 --> 01:21:44,031
好吧，我开始有一个完整的甲板所以

1578
01:21:44,099 --> 01:21:47,200
我最好有一个init来做，init很简单

1579
01:21:47,269 --> 01:21:50,604
写给我们漂亮的普通卡结构，对不起，

1580
01:21:50,673 --> 01:21:54,041
这个警告在这里，不能使用不可变的成员

1581
01:21:54,110 --> 01:21:57,377
事情，大家都知道这是为什么。这是一个结构，

1582
01:21:57,446 --> 01:22:00,780
这是一个值类型，这是通过删除一个卡变异，

1583
01:22:00,849 --> 01:22:03,817
所以我们不得不说这是一个变异的标志，

1584
01:22:03,886 --> 01:22:07,187
另一个很好的例子。好，那么

1585
01:22:07,256 --> 01:22:10,991
在这里，我只是要穿过我所有的西装

1586
01:22:11,059 --> 01:22:15,462
在Suit.all中适合，并且在Rank.all中排名，没关系，

1587
01:22:15,531 --> 01:22:19,833
那么现在我们所做的所有这些，但当然是看

1588
01:22:19,902 --> 01:22:24,505
在那里我穿西装，如果你看看这里的玩具卡，我

1589
01:22:24,573 --> 01:22:28,508
把套装放在播放卡里面。看到我在里面宣布，

1590
01:22:28,577 --> 01:22:32,379
所以Swift允许你嵌套类型，把类型放在其他类型中

1591
01:22:32,447 --> 01:22:35,048
侧。这在这里很合理，因为西装

1592
01:22:35,117 --> 01:22:37,884
只有在扑克牌的背景下才有意义，

1593
01:22:37,953 --> 01:22:41,187
它只是非常有意义。但它确实改变了这个名字

1594
01:22:41,256 --> 01:22:44,324
西装，它不再叫西装，

1595
01:22:44,393 --> 01:22:49,563
它被称为PlayingCard.Suit。玩Card.Suit和

1596
01:22:49,631 --> 01:22:55,668
这是PlayCard.Rank，PlayingCard.Rank。

1597
01:22:55,737 --> 01:22:57,838
所以嵌套只是改变事物的名称和

1598
01:22:57,907 --> 01:22:59,572
可访问性可以做私人和

1599
01:22:59,641 --> 01:23:02,742
像你可能无法看到的东西。那么现在呢

1600
01:23:02,811 --> 01:23:07,214
我有我可以让我的卡片附加一张纸牌，

1601
01:23:07,283 --> 01:23:10,617
现在演奏，因为它是一个结构是要得到这个

1602
01:23:10,686 --> 01:23:13,820
自动初始化，你在那里看到，所以

1603
01:23:13,889 --> 01:23:16,823
我会双击这个来获得。和

1604
01:23:16,892 --> 01:23:20,460
西装就是我要做的西装

1605
01:23:20,529 --> 01:23:22,196
排名是我在进行的排名。

1606
01:23:22,264 --> 01:23:25,732
所以现在你也可以在这里看到漂亮的背景

1607
01:23:25,800 --> 01:23:27,167
for的很好的语法

1608
01:23:27,235 --> 01:23:30,904
在什么时候这是一个数组。这些是数组。

1609
01:23:30,973 --> 01:23:33,206
我们只是通过数组的每个元素，对。

1610
01:23:33,275 --> 01:23:35,041
请记住，这些数组是在这里？看到，

1611
01:23:35,110 --> 01:23:39,646
这是套装的阵列。这是我们制作的一个数组

1612
01:23:39,715 --> 01:23:44,218
等级。好吧。就是这样了。现在，我最后一件事了

1613
01:23:44,286 --> 01:23:46,953
要在这里做只是打印出一些卡在我的甲板上

1614
01:23:47,022 --> 01:23:50,057
确保它的工作。一个很酷的地方，把测试

1615
01:23:50,125 --> 01:23:52,759
代码返回到您的视图控制器。好的，如果你看

1616
01:23:52,827 --> 01:23:54,828
在你的视图控制器你有这两个框架的方法。

1617
01:23:54,897 --> 01:23:55,662
我会摆脱那一个。

1618
01:23:55,730 --> 01:23:58,031
但是我会保留你在这里提到的这个

1619
01:23:58,100 --> 01:24:01,468
家庭作业。这是，viewDidLoad是一个喜欢的好地方

1620
01:24:01,537 --> 01:24:02,869
初始化您的视图控制器。和

1621
01:24:02,938 --> 01:24:05,906
也只是像调试代码，检查出来的东西，

1622
01:24:05,974 --> 01:24:08,341
像这样的东西。所以，在这里我可以做，例如，

1623
01:24:08,410 --> 01:24:10,810
让我们打印出10张随机卡。我会说

1624
01:24:10,879 --> 01:24:13,313
下吧，因为我真的不在乎指数，

1625
01:24:13,381 --> 01:24:19,152
在1 ... 10 cuz我想要10张牌。我只是要让卡

1626
01:24:19,221 --> 01:24:23,290
等同于一张扑克牌，所以我需要一张扑克牌，

1627
01:24:23,359 --> 01:24:27,861
var deck = PlayingCardDeck。所以我只是

1628
01:24:27,930 --> 01:24:33,233
会让卡= deck.draw。

1629
01:24:34,703 --> 01:24:38,271
现在，这将是一个可选的扑克牌权利

1630
01:24:38,340 --> 01:24:40,840
这里，对吗？可选纸牌，因为甲板可能是

1631
01:24:40,909 --> 01:24:43,643
空，所以让我们去说，如果让，尽管我可能可以

1632
01:24:43,712 --> 01:24:45,912
把感叹号因为我只抓了10张牌。

1633
01:24:45,981 --> 01:24:48,982
我知道有一副牌有52张牌，但是我们会这样做。和

1634
01:24:49,051 --> 01:24:52,219
现在我打算把这张卡片打印出来。和

1635
01:24:52,287 --> 01:24:56,089
我可以通过使用这个反斜杠括号打印一张卡片。

1636
01:24:56,158 --> 01:25:00,093
Swift知道如何打印出具有的东西，

1637
01:25:00,162 --> 01:25:02,128
我们会看到它在什么时候打印出来，

1638
01:25:02,197 --> 01:25:05,666
当我们在这里这样做。所以让我们试试看看会发生什么

1639
01:25:05,734 --> 01:25:08,301
所以我没有用户界面，所以这可能是一个空白的用户界面，但

1640
01:25:08,370 --> 01:25:11,371
它会打印出我的控制台上的东西，所以我真的

1641
01:25:11,440 --> 01:25:16,276
只需要在这里看看我的控制台，对，如此

1642
01:25:16,344 --> 01:25:20,580
这里有我的东西，所以在这里打印出来

1643
01:25:20,649 --> 01:25:25,452
它打印出10张随机卡，好看，在这里看起来很丑，

1644
01:25:25,521 --> 01:25:29,223
它打印出所有的变量等。有一件事是真的

1645
01:25:29,291 --> 01:25:32,358
很酷，我没有时间显示不幸的是，

1646
01:25:32,427 --> 01:25:35,662
因为我们已经过去了，但我只是提到它，

1647
01:25:35,731 --> 01:25:38,632
是你可以把它打印出来

1648
01:25:38,700 --> 01:25:41,401
真的很好，当它有括号，

1649
01:25:41,469 --> 01:25:44,937
反斜杠括号，通过使其实现自定义

1650
01:25:45,006 --> 01:25:48,741
字符串可转换协议。所以如果我们做了纸牌

1651
01:25:48,810 --> 01:25:51,478
实现自定义字符串协议

1652
01:25:51,547 --> 01:25:54,848
唯一的问题是，如果我们确实解决了这个问题，

1653
01:25:54,916 --> 01:25:58,585
我们将看看它是什么，是这个var描述和

1654
01:25:58,654 --> 01:26:02,489
你可以返回，就像我在这里可以返回的例子

1655
01:26:02,558 --> 01:26:06,559
等级和套装的组合，然后我可以去

1656
01:26:06,628 --> 01:26:11,231
使自定义的字符串可以转换为Rank和Suit在这里。

1657
01:26:12,734 --> 01:26:18,104
逗号CustomStringConvertible。在中实现描述

1658
01:26:18,173 --> 01:26:23,309
那里也是。好的，我正在努力，所以

1659
01:26:23,378 --> 01:26:27,447
我们会去这里，我们会把描述，我们会去这里，

1660
01:26:27,515 --> 01:26:31,518
我们会把描述，我们会执行这些

1661
01:26:31,586 --> 01:26:35,989
两个变量，然后当我们打印出来，它会打印这个

1662
01:26:36,057 --> 01:26:39,392
漂亮的字符串与两个漂亮的字符串。

1663
01:26:39,461 --> 01:26:42,128
现在，我们不会得到所有真正详细的打印出来。

1664
01:26:42,197 --> 01:26:45,398
所以CustomStringConvertible是一个很好的协议来实现

1665
01:26:45,467 --> 01:26:49,902
如果你想在控制台打印好东西。可以，然后呢

1666
01:26:49,971 --> 01:26:52,105
而已。我星期三见。

1667
01:26:52,173 --> 01:26:56,009
我们将深入做M或V和C部分，

1668
01:26:56,078 --> 01:26:57,311
这是画一张纸牌。

1669
01:26:57,379 --> 01:26:58,678
我们将学习所有的自定义视图和

1670
01:26:58,747 --> 01:27:01,881
所有这一切，我知道在那之后还有更多的事情要做。

1671
01:27:01,950 --> 01:27:03,616
回头见。 >>对于

1672
01:27:03,685 --> 01:27:13,092
更多，请访问我们的stanford.edu。

