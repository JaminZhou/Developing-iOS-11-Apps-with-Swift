1
00:00:00,401 --> 00:00:04,736
[MUSIC]

2
00:00:04,804 --> 00:00:08,840
斯坦福大学。 >>好的，

3
00:00:08,909 --> 00:00:11,743
那么，欢迎来到第四讲？

4
00:00:11,812 --> 00:00:15,180
是的，斯坦福CS193P，2017年秋季。

5
00:00:15,249 --> 00:00:18,583
今天，我们将继续谈论Swift。

6
00:00:18,652 --> 00:00:21,019
这将是我们最后谈论的Swift。在这之后，

7
00:00:21,088 --> 00:00:23,655
我们几乎会假设你知道Swift。

8
00:00:23,724 --> 00:00:26,491
显然你会随时随地学习，但是

9
00:00:26,560 --> 00:00:27,592
从下周开始，

10
00:00:27,661 --> 00:00:29,861
我们将直接进入iOS，UI工具包和

11
00:00:29,930 --> 00:00:33,198
所有这一切。所以我会做推迟的快速演示

12
00:00:33,267 --> 00:00:36,968
从星期三我们有这个变异的关键字

13
00:00:37,037 --> 00:00:39,771
当我们做一个结构与一个类的时候添加。然后

14
00:00:39,840 --> 00:00:43,274
我们今天要谈两个非常重要的话题。

15
00:00:43,343 --> 00:00:45,910
协议和闭包。

16
00:00:45,979 --> 00:00:48,647
作为一般的那两种类型和之间的函数，我是

17
00:00:48,715 --> 00:00:52,384
要说一些重要的字符串，但是

18
00:00:52,452 --> 00:00:55,553
这不像像这样的重大话题

19
00:00:55,622 --> 00:01:00,859
原型和闭包是。所以开始进入该演示

20
00:01:00,928 --> 00:01:05,096
我有。请记住，我们当时正在谈论

21
00:01:05,165 --> 00:01:09,400
使事情成为一个结构，而且有点不同

22
00:01:09,469 --> 00:01:13,172
然后一个类，因为那个副本写。Swift需要知道

23
00:01:13,240 --> 00:01:15,674
当一个函数可能实际上修改的东西如此

24
00:01:15,743 --> 00:01:18,576
它知道实际上是一个真正的副本。所以

25
00:01:18,645 --> 00:01:22,147
让我们回到这里，我们的应用程序，浓度，我们在哪里。

26
00:01:22,216 --> 00:01:26,751
让我们去浓度，如果你记得，

27
00:01:26,820 --> 00:01:30,422
我们做了一个类。一个Concentration类。和

28
00:01:30,491 --> 00:01:32,857
这可能就像一个结构体一样简单。

29
00:01:32,926 --> 00:01:35,326
当我们做这件事的时候，我真的做了一堂课

30
00:01:35,395 --> 00:01:37,428
初始化和东西，你可以看到不同之处

31
00:01:37,497 --> 00:01:40,331
浓度和卡之间，因为卡是一个结构和

32
00:01:40,400 --> 00:01:42,267
集中是一个阶级。但是有

33
00:01:42,336 --> 00:01:44,136
没有理由集中不会是一个结构。

34
00:01:44,204 --> 00:01:47,572
很可能，这里的结构甚至可能更好。

35
00:01:47,641 --> 00:01:51,376
现在我们并没有通过集中游戏

36
00:01:51,445 --> 00:01:55,113
所有这一切，只是有点坐在我们的控制器。

37
00:01:55,182 --> 00:01:58,716
不是真的指向我们的模型，但这将嵌入

38
00:01:58,785 --> 00:02:01,320
那里的模型。所以这并不重要。

39
00:02:01,388 --> 00:02:06,124
但是，当我从类更改为结构，请注意这里

40
00:02:06,193 --> 00:02:09,194
我得到一个错误。我们向下滚动，在这里，

41
00:02:09,263 --> 00:02:11,363
这里的错误，这个错误是说，

42
00:02:11,431 --> 00:02:15,533
不能分配给属性，自己是不可改变的。为什么是这样

43
00:02:15,602 --> 00:02:18,970
说自己是不可改变的？我想在这里换卡

44
00:02:19,039 --> 00:02:21,273
比如说他们已经匹配了。

45
00:02:21,342 --> 00:02:24,442
那么，自我是不可变的，因为这个功能是正确的

46
00:02:24,511 --> 00:02:29,514
没有被标记为可变的，所以假定不会变异，

47
00:02:29,583 --> 00:02:34,152
不要改变这个浓度对象。所以

48
00:02:34,220 --> 00:02:37,722
当然我们需要选择卡来改变浓度

49
00:02:37,791 --> 00:02:40,325
对象因为这是主要的东西。游戏的变化，

50
00:02:40,394 --> 00:02:43,795
所以我们需要做的就是在这里添加可变的权利

51
00:02:43,864 --> 00:02:47,932
标记，抱歉，变异，不可变，你在这里添加和

52
00:02:48,001 --> 00:02:51,470
这是说这是一个变异功能，

53
00:02:51,538 --> 00:02:54,372
所有的错误消失了，我们都很好走。

54
00:02:54,441 --> 00:02:59,544
题？ >> [不可思议]

55
00:02:59,613 --> 00:03:00,479
>>好的，问题是为什么

56
00:03:00,547 --> 00:03:01,680
这不需要它吗？

57
00:03:01,749 --> 00:03:05,784
这是一个变种。而这个变量是得到和设置的，所以

58
00:03:05,852 --> 00:03:10,121
Swift已经知道这是变化，因为它是可以设置的。

59
00:03:10,190 --> 00:03:12,357
如果这只是获得，那么它不会变异

60
00:03:12,426 --> 00:03:16,028
Swift会知道的。所以对于vars，Swift知道。和

61
00:03:16,096 --> 00:03:19,264
如果它不是一个计算的变种，像看这个变种，

62
00:03:19,332 --> 00:03:22,701
这个怎么知道？那是因为这个是

63
00:03:22,770 --> 00:03:26,871
只读在外面，但对我们来说是可写的。这里，

64
00:03:26,940 --> 00:03:29,641
任何一个变种都假定它是可写的。如果它

65
00:03:29,709 --> 00:03:34,846
是一个让，一个让，那么它会认为这是不可写的。

66
00:03:34,914 --> 00:03:39,450
所以这就是你如何做变异，或可变。如果是变数

67
00:03:39,519 --> 00:03:42,620
不管他们是vars还是let，还是电脑属性，

68
00:03:42,689 --> 00:03:47,192
是否兼得。我们从哪里得到的？所以

69
00:03:47,260 --> 00:03:49,060
这只是功能funs，我们必须把它。

70
00:03:49,129 --> 00:03:52,297
是的，问题。 >> [不可思议]

71
00:03:52,366 --> 00:03:52,931
>>是的，所以问题是，

72
00:03:52,999 --> 00:03:55,733
为什么你需要一个结构体而不是一个类，为什么呢

73
00:03:55,802 --> 00:03:58,002
我需要结构体？这是非常重要的理解，

74
00:03:58,071 --> 00:04:02,974
非常好的问题。结构是值类型，而不是引用

75
00:04:03,043 --> 00:04:05,844
类型。所以结构不在堆中。当我们通过

76
00:04:05,913 --> 00:04:09,013
因为它是一个值类型的结构，它被复制。

77
00:04:09,082 --> 00:04:11,649
不断地复制到处。通过一个函数，

78
00:04:11,718 --> 00:04:14,486
复制。放入一个变量，复制。好，

79
00:04:14,554 --> 00:04:17,222
不久之后，如果真的这样，效率会非常低

80
00:04:17,291 --> 00:04:21,159
每次都复制这些东西的各个部分。所以与其，

81
00:04:21,228 --> 00:04:24,028
Swift聪明。它只是实际上复制的时候

82
00:04:24,097 --> 00:04:27,799
你改变它。这就是所谓的copy-on-write语义。

83
00:04:27,867 --> 00:04:29,434
这就是结构不同的原因，

84
00:04:29,503 --> 00:04:31,903
因为它们具有写入时复制语义。

85
00:04:31,972 --> 00:04:35,106
一个类没有，因为当你通过一个类，

86
00:04:35,175 --> 00:04:37,075
类上只是一次堆在一起，

87
00:04:37,144 --> 00:04:38,810
而你正在向它传递指针。

88
00:04:38,878 --> 00:04:41,213
可能有20个指向同一个对象的指针。

89
00:04:41,281 --> 00:04:44,683
内存完全不同的模型。所以这就是为什么，

90
00:04:44,751 --> 00:04:48,719
这是因为这是一个复制写入东西的值类型，

91
00:04:48,788 --> 00:04:51,523
这就是为什么我们关心它是变异的。

92
00:04:51,592 --> 00:04:56,828
让我们回到我们的幻灯片，谈谈第一个，

93
00:04:56,897 --> 00:05:01,900
协议是今天非常重要的话题。

94
00:05:01,968 --> 00:05:05,737
这是构建数据结构的第四大支柱

95
00:05:05,805 --> 00:05:09,307
在Swift里面。你现在已经对课堂了解了很多，

96
00:05:09,375 --> 00:05:14,679
结构和枚举。协议是在哪里

97
00:05:14,748 --> 00:05:18,382
它是一个非常简单的概念。一个协议基本上只是

98
00:05:18,451 --> 00:05:21,453
没有实现的方法和变量列表。但

99
00:05:21,522 --> 00:05:23,722
这是使用协议。就是这样

100
00:05:23,790 --> 00:05:27,025
在整个Swift语言中广泛使用

101
00:05:27,093 --> 00:05:30,529
运行时如此强大。所以首先我只是

102
00:05:30,597 --> 00:05:32,664
会通过一些为什么我们有协议。

103
00:05:32,733 --> 00:05:35,133
然后我会告诉你协议的语法。

104
00:05:35,201 --> 00:05:37,635
看起来像输入一个协议并定义一个协议。

105
00:05:37,704 --> 00:05:40,005
然后我们将开始谈论使用协议。

106
00:05:40,073 --> 00:05:43,674
我们在哪里使用它们？他们为什么如此有价值？所以

107
00:05:43,743 --> 00:05:47,178
首先，我们谈谈什么协议？

108
00:05:47,247 --> 00:05:51,616
协议实质上是一种方式

109
00:05:51,685 --> 00:05:55,219
调用者用他们想要的任何东西来调用一个API。

110
00:05:55,288 --> 00:05:57,122
任何结构，枚举，类，

111
00:05:57,190 --> 00:06:00,391
它可以通过任何他们想要的东西。而在同一时间

112
00:06:00,460 --> 00:06:04,596
接收方法可以指定它真正想要的。

113
00:06:04,665 --> 00:06:08,132
所以双方都可以做他们想做的事情。接收的东西

114
00:06:08,201 --> 00:06:10,868
可以说出你想要传递的东西

115
00:06:10,937 --> 00:06:13,772
做的事情，通过的东西可以通过任何想要的

116
00:06:13,840 --> 00:06:17,409
只要它做那件事。并做所有这一切

117
00:06:17,478 --> 00:06:22,380
一个协议是，是一个vars和函数的列表。

118
00:06:22,449 --> 00:06:24,649
这是一个协议。这只是一个列表。

119
00:06:24,718 --> 00:06:27,251
不是一个实现或任何东西，只是一个列表。

120
00:06:27,320 --> 00:06:30,622
这就是我们如何在API中使用它们，让我们得到这个

121
00:06:30,691 --> 00:06:33,558
有呼叫者和被呼叫者的行为。

122
00:06:33,626 --> 00:06:37,028
以他们想要的方式表达事物。怎么办

123
00:06:37,096 --> 00:06:40,532
协议好吗？他们使API非常灵活

124
00:06:40,600 --> 00:06:42,500
表现力，就像你将要看到的那样。

125
00:06:42,569 --> 00:06:45,870
对于盲人结构化的沟通而言，他们非常好

126
00:06:45,939 --> 00:06:48,439
回想一下我的MVC谈话。

127
00:06:48,508 --> 00:06:50,542
视图和控制器之间的通信。

128
00:06:50,611 --> 00:06:54,011
所有这些都会，应该。而数数据，

129
00:06:54,080 --> 00:06:56,982
视图控制器之间的那种通信。

130
00:06:57,050 --> 00:06:59,784
这一切都是盲目的，因为意见是通用的

131
00:06:59,853 --> 00:07:03,721
和控制器是非常具体的，协议是如何

132
00:07:03,790 --> 00:07:07,792
我们做这个工作。强制行为也很好，

133
00:07:07,861 --> 00:07:11,529
例如，在字典中，字典的哈希表，

134
00:07:11,597 --> 00:07:15,032
举起你的手，如果你知道什么是哈希表是我的时候

135
00:07:15,101 --> 00:07:19,037
比如说。好的，大家好。所以这是一个哈希表。

136
00:07:19,105 --> 00:07:22,407
因此，字典的关键字显然必须是可排除的。

137
00:07:22,476 --> 00:07:25,509
你必须能够得到一个哈希值，否则你不能

138
00:07:25,578 --> 00:07:28,580
对它们进行散列并将它们作为这个散列表的关键字。

139
00:07:28,649 --> 00:07:31,983
那么，协议让我们以这样的方式定义字典

140
00:07:32,052 --> 00:07:35,319
我们不使用任何不可哈希的密钥

141
00:07:35,388 --> 00:07:38,056
所以强制行为的可行性，例如，

142
00:07:38,125 --> 00:07:40,992
的关键，这是伟大的。这也是伟大的

143
00:07:41,061 --> 00:07:43,994
在非常不同的类型之间共享功能，

144
00:07:44,063 --> 00:07:47,064
类型，你永远不会使用面向对象的继承

145
00:07:47,133 --> 00:07:50,501
使他们分享一个基类，但他们是非常相似的

146
00:07:50,570 --> 00:07:54,472
例如，字符串，数组，可数范围。他们都是

147
00:07:54,540 --> 00:07:57,475
事物的集合。现在他们完全不同了。

148
00:07:57,544 --> 00:07:58,943
来吧，可数范围和

149
00:07:59,012 --> 00:08:01,446
一个字符串是完全不同的。但他们都是

150
00:08:01,515 --> 00:08:04,182
集合中，一个字符串是一个字符的集合，

151
00:08:04,251 --> 00:08:06,584
如果是负责范围，则是整数的集合

152
00:08:06,653 --> 00:08:09,487
int的可负责范围。所以他们分享一些和

153
00:08:09,555 --> 00:08:12,624
协议有一个机制，让你分享这种

154
00:08:12,693 --> 00:08:15,426
没有必要拥有所有这些东西

155
00:08:15,495 --> 00:08:18,763
从某种知道的通用基类继承而来

156
00:08:18,832 --> 00:08:21,666
事物的集合。你看我在说什么？所以

157
00:08:21,735 --> 00:08:25,536
在某种程度上，协议提供了多重继承。现在，

158
00:08:25,605 --> 00:08:28,873
因为协议只是做变数的声明

159
00:08:28,942 --> 00:08:32,277
和功能，没有这些东西的存储，

160
00:08:32,345 --> 00:08:34,378
所以没有数据的继承，

161
00:08:34,447 --> 00:08:36,447
它纯粹是继承的，

162
00:08:36,516 --> 00:08:41,152
功能的继承。好，我走了

163
00:08:41,221 --> 00:08:43,688
通过这个解释，理解是非常重要的

164
00:08:43,757 --> 00:08:47,258
该协议只是一个类型。就像一个类一样

165
00:08:47,327 --> 00:08:50,194
一个类型，一个结构，一个枚举，一个协议是一个类型。

166
00:08:50,263 --> 00:08:52,730
一流的类型，就像所有其他的类型一样，

167
00:08:52,799 --> 00:08:54,398
这是非常重要的理解。

168
00:08:54,467 --> 00:08:58,103
好，那我们来看看协议是什么。

169
00:08:58,171 --> 00:08:59,804
协议有三部分。

170
00:08:59,873 --> 00:09:02,974
第一，就像你一样，协议的声明

171
00:09:03,043 --> 00:09:05,443
有一个类或一个枚举或结构的声明。对于

172
00:09:05,511 --> 00:09:07,245
一个协议，这只是一个列表

173
00:09:07,313 --> 00:09:09,781
方法的参数和返回值和

174
00:09:09,850 --> 00:09:13,284
vars的名单。就是这样，这就是一个协议，

175
00:09:13,353 --> 00:09:16,620
这是一个声明。协议的第二部分虽然

176
00:09:16,689 --> 00:09:21,259
是一个类或一个结构或一个枚举举手

177
00:09:21,327 --> 00:09:24,628
声称在这方面实施那些方法

178
00:09:24,697 --> 00:09:27,832
协议。所以有要求实施一个协议，

179
00:09:27,901 --> 00:09:30,701
这是第二部分。因为有人必须实际上

180
00:09:30,770 --> 00:09:33,437
实现协议是一个列表的方法

181
00:09:33,506 --> 00:09:36,274
这是类，结构和枚举，所以他们不得不声称。

182
00:09:36,343 --> 00:09:39,377
第三部分是这些类的代码，

183
00:09:39,446 --> 00:09:42,246
结构和实际实现的枚举中

184
00:09:42,315 --> 00:09:45,115
在变量中的协议方法。可以，然后呢

185
00:09:45,184 --> 00:09:47,852
请注意我提到的变数。vars，

186
00:09:47,921 --> 00:09:51,289
变量的存储，如果他们不计算变量，

187
00:09:51,358 --> 00:09:54,592
必须在一些结构，枚举或类。因为，

188
00:09:54,661 --> 00:09:58,596
这是唯一的地方你可以有任何存储，好吗？

189
00:09:58,665 --> 00:10:00,364
好吧，就是这样，这是协议的三个部分。

190
00:10:00,433 --> 00:10:03,401
现在我要稍微放一下

191
00:10:03,470 --> 00:10:07,037
甚至不会花太多时间在这个，但是

192
00:10:07,106 --> 00:10:11,209
协议中的所有方法和变量都是强制的。

193
00:10:11,278 --> 00:10:12,810
如果你想举手和

194
00:10:12,879 --> 00:10:14,378
说，我执行这个协议。

195
00:10:14,447 --> 00:10:18,015
如果你是一个结构或枚举或类，你必须实现

196
00:10:18,084 --> 00:10:22,187
所有的方法和Swift中的所有变量。然而，

197
00:10:22,255 --> 00:10:27,024
在Objective-C中，这是不正确的。在Objective-C中，

198
00:10:27,093 --> 00:10:31,762
协议可以有可选的方法。方法或

199
00:10:31,831 --> 00:10:34,432
你可以选择实现协议中的变量

200
00:10:34,500 --> 00:10:38,970
不。现在，这是一个很大的区别和斯威夫特的方式

201
00:10:39,039 --> 00:10:42,306
处理这是它允许你把@objc，在前面

202
00:10:42,375 --> 00:10:45,276
你声明一个协议，使之成为这样

203
00:10:45,344 --> 00:10:48,746
是一个Objective-C协议，而不是一个交换协议。

204
00:10:48,815 --> 00:10:51,216
唯一的区别就是现在，

205
00:10:51,284 --> 00:10:54,252
您的协议内的方法可以被标记

206
00:10:54,321 --> 00:10:57,088
可选的。不是像你知道问号一样可选，

207
00:10:57,157 --> 00:10:59,057
感叹号，那种可选的枚举。

208
00:10:59,125 --> 00:11:01,292
我正在谈论可选，就像你可以选择

209
00:11:01,361 --> 00:11:03,728
实施的方法，但你不必实施，如果你

210
00:11:03,797 --> 00:11:07,498
不想要。好吧，这是一种特殊的倒退

211
00:11:07,567 --> 00:11:09,533
兼容模式到Objective-C，但是

212
00:11:09,602 --> 00:11:12,470
在Swift中，我们不这样做。所以我们唯一的一次会去

213
00:11:12,538 --> 00:11:15,673
在这个类中有这个是我们使用iOS的时候

214
00:11:15,742 --> 00:11:18,642
在Objective-C世界中设计的API。

215
00:11:18,711 --> 00:11:21,111
具体来说，

216
00:11:21,180 --> 00:11:24,348
这是对控制器通信的盲目看法。

217
00:11:24,417 --> 00:11:29,086
这就是所有的Objective-C风格的协议等等

218
00:11:29,155 --> 00:11:32,423
当你在接下来的几周里开始使用它的时候，

219
00:11:32,492 --> 00:11:34,191
你会看到这些标记的协议

220
00:11:34,260 --> 00:11:36,694
Objective-C和其中一些被标记为可选

221
00:11:36,763 --> 00:11:38,429
你不必实现一个方法。

222
00:11:38,497 --> 00:11:42,366
那不是Swift。这就是Objective-C的兼容性。

223
00:11:42,435 --> 00:11:44,502
所以把它放在你的大脑后面

224
00:11:44,571 --> 00:11:46,570
当你看到它时，你就像是，哇。我以为我必须

225
00:11:46,639 --> 00:11:48,973
实现协议中的所有方法。是的，你在做

226
00:11:49,042 --> 00:11:54,211
迅速。只有这个例外，没事，回到协议。

227
00:11:54,280 --> 00:11:57,682
好的，那我们如何申报协议呢？什么语法

228
00:11:57,750 --> 00:12:00,851
看起来像？那么，这看起来很像宣布一个类。

229
00:12:00,920 --> 00:12:05,022
Protocol，SomeProtocol，SomeProtocol就是这个名字

230
00:12:05,091 --> 00:12:07,858
就像在课堂上讲的那样

231
00:12:07,927 --> 00:12:09,627
那将是类的名字。

232
00:12:09,695 --> 00:12:12,897
注意还有冒号，InheritedProtocol1，

233
00:12:12,966 --> 00:12:16,667
InheritedProtocol2实际上可以是这些的任何数量。

234
00:12:16,736 --> 00:12:22,273
这些是SomeProtocol继承的其他协议。

235
00:12:22,342 --> 00:12:25,276
好的，所以在协议中有继承。它的意思是

236
00:12:25,344 --> 00:12:28,346
然后在课堂上有点不一样的东西。

237
00:12:28,415 --> 00:12:30,782
好吧，协议世界的继承意味着，

238
00:12:30,850 --> 00:12:34,219
如果你想要实现一些协议。您

239
00:12:34,287 --> 00:12:37,355
还必须实现InheritedProtocol1和

240
00:12:37,423 --> 00:12:41,759
InheritedProtocol2。所以这几乎就像是强制性的

241
00:12:41,827 --> 00:12:44,629
如果你想说的话，你必须实现额外的协议

242
00:12:44,697 --> 00:12:47,398
你实现这个协议。我们称之为协议

243
00:12:47,467 --> 00:12:52,270
遗产。我们称之为，因为一些协议继承

244
00:12:52,338 --> 00:12:57,842
实施这些其他协议的要求。现在，

245
00:12:57,911 --> 00:13:01,712
一旦进入协议的定义，

246
00:13:01,781 --> 00:13:05,483
你可以看到没有代码。协议没有代码，

247
00:13:05,552 --> 00:13:06,884
他们不是实现，

248
00:13:06,953 --> 00:13:10,854
他们纯属宣言。而且，实际上，当你声明的时候

249
00:13:10,923 --> 00:13:13,925
你将有一个变种是你的协议的一部分，

250
00:13:13,994 --> 00:13:16,894
所有你能说的是它是否是只读变量，

251
00:13:16,962 --> 00:13:18,296
这将得到或

252
00:13:18,364 --> 00:13:20,865
读取和写入变种与这样设置。

253
00:13:20,934 --> 00:13:24,435
所以这个这里的一些属性会被获取和设置。

254
00:13:24,504 --> 00:13:27,104
所以如果你想实施这个协议，你的类或者

255
00:13:27,173 --> 00:13:29,640
结构体，你想实现这一点，你将不得不有

256
00:13:29,709 --> 00:13:36,013
一个可以获取和设置的变种。好吧，那就是这个意思。

257
00:13:36,082 --> 00:13:39,283
你在协议中有任何方法

258
00:13:39,352 --> 00:13:43,321
这可能是由一个结构实现的，并修改了这个东西

259
00:13:43,389 --> 00:13:46,791
当然必须标记突变，对吗？

260
00:13:46,860 --> 00:13:50,361
因为Swift又需要知道哦

261
00:13:50,430 --> 00:13:53,264
这个方法可能会改变实现它的东西。

262
00:13:53,332 --> 00:13:56,534
如果你知道的话，现在有一个小窍门

263
00:13:56,602 --> 00:13:59,436
这个协议永远不会被一个结构体实现，

264
00:13:59,505 --> 00:14:02,339
那么你不需要变异。但是你必须标记

265
00:14:02,408 --> 00:14:06,143
该协议说这是一个只有类的协议。你做

266
00:14:06,212 --> 00:14:09,914
通过说冒充类作为第一件事后

267
00:14:09,982 --> 00:14:13,251
协议声明。你看我是怎么把黄色的

268
00:14:13,319 --> 00:14:16,253
那里有冒号类吗？好的，那么如果你这样做的话

269
00:14:16,322 --> 00:14:18,456
当然，你不需要进行变异，

270
00:14:18,525 --> 00:14:20,224
你不必在课堂上进行变异，但是

271
00:14:20,292 --> 00:14:22,426
那么这个协议不能被一个结构体实现。

272
00:14:22,495 --> 00:14:25,829
它只能由一个类来实施，我们很少这样做。

273
00:14:25,898 --> 00:14:28,732
好的，我们通常不会制定一个协议，仅限于

274
00:14:28,801 --> 00:14:31,435
一个类，实际上99％的所有协议你会看到

275
00:14:31,504 --> 00:14:36,207
在iOS中可以由任何人实施。好的，

276
00:14:36,276 --> 00:14:40,544
还有什么我们在这里。是，

277
00:14:40,613 --> 00:14:44,748
你甚至可以添加一个init到你的协议。这意味着

278
00:14:44,817 --> 00:14:47,551
如果您是一个实现此协议的类或结构，

279
00:14:47,620 --> 00:14:49,086
你必须实现这个init。

280
00:14:49,155 --> 00:14:53,056
所以，我必须能够初始化你。以便

281
00:14:53,125 --> 00:14:57,194
是我们如何声明一个协议，现在让我们看看如何一个类或

282
00:14:57,263 --> 00:15:00,965
一个结构说，举起他的手，说是的，我会的

283
00:15:01,033 --> 00:15:03,968
执行这个协议。它所做的一切就是在类之后

284
00:15:04,036 --> 00:15:07,505
超类(父类)，你只要说你所有的协议逗号

285
00:15:07,574 --> 00:15:12,243
声称执行。当然，就这么简单

286
00:15:12,312 --> 00:15:15,279
一个结构体没有父类，所以

287
00:15:15,347 --> 00:15:19,717
你只要说枚举或结构，不管，冒号

288
00:15:19,786 --> 00:15:24,055
你实现的协议。好吧，这就是你要求的。

289
00:15:24,123 --> 00:15:26,657
这是你举手，说我执行。

290
00:15:26,726 --> 00:15:28,759
只要你说源代码编译器会检查

291
00:15:28,828 --> 00:15:30,961
确保你确实实现了这些方法

292
00:15:31,030 --> 00:15:33,397
该议定书中的变数。如果你不这样做，你会得到

293
00:15:33,466 --> 00:15:36,734
错误。它会说你不遵守协议

294
00:15:36,803 --> 00:15:41,338
方法什么的。你必须这样做，好吗？

295
00:15:41,407 --> 00:15:43,240
你可以做任何你想要的协议。

296
00:15:43,309 --> 00:15:46,310
有时候这就是我们说协议可以提供的原因

297
00:15:46,379 --> 00:15:48,546
多重继承，因为你可以有许多这样的

298
00:15:48,615 --> 00:15:51,616
啊，就像你想要去的那样。啊，顺便说一句，

299
00:15:51,685 --> 00:15:53,551
如果在协议中有一个init，

300
00:15:53,620 --> 00:15:56,487
你是一个类，你说，实施该协议，

301
00:15:56,555 --> 00:15:59,623
你必须在那里标记，你的init需要。

302
00:15:59,692 --> 00:16:01,859
那是因为你不想要一个子类来。

303
00:16:01,927 --> 00:16:05,696
子类你，子类init那里是可能的。

304
00:16:05,765 --> 00:16:07,131
可以继承和实现它

305
00:16:07,199 --> 00:16:09,867
一个init不能从你的超类中运行。

306
00:16:09,936 --> 00:16:11,935
你不想让子类来这样做

307
00:16:12,004 --> 00:16:14,972
那么一个子类将不再实现这个协议

308
00:16:15,041 --> 00:16:17,374
但人们可能会认为它是因为它继承而来

309
00:16:17,443 --> 00:16:21,445
一些事情。所以，一旦一个类实现了协议，

310
00:16:21,514 --> 00:16:24,248
所有它的子类也必须如此，所以所有的init都会有

311
00:16:24,317 --> 00:16:26,684
被要求。 Cuz init有点特别，

312
00:16:26,753 --> 00:16:28,719
因为在你的子类中可以这样做

313
00:16:28,788 --> 00:16:30,921
你不再执行一定的init

314
00:16:30,990 --> 00:16:35,393
参数。顺便说一句，在你的阅读中，有一大堆

315
00:16:35,461 --> 00:16:39,229
关于在类的初始化。可能是

316
00:16:39,298 --> 00:16:42,266
这是你本周阅读中最复杂的部分。

317
00:16:42,334 --> 00:16:46,303
你将不得不通过它斗争，因为它很漂亮

318
00:16:46,372 --> 00:16:49,607
复杂。继承确实使初始化

319
00:16:49,676 --> 00:16:51,809
很难，因为你有自己的变数，你有你的

320
00:16:51,877 --> 00:16:54,511
父类vars。你必须把事情初始化

321
00:16:54,580 --> 00:16:57,882
所有这一切都是相当复杂的。

322
00:16:57,950 --> 00:17:00,584
所以，不幸的是你子类化的一天

323
00:17:00,653 --> 00:17:03,086
可以做到这一点，所以你不必再形成一个初始化。

324
00:17:03,155 --> 00:17:09,060
所以这就是为什么你必须标记它的要求。一件事

325
00:17:09,128 --> 00:17:13,097
你不需要将你的一致性添加到协议中。

326
00:17:13,166 --> 00:17:14,865
你不必添加所有的方法，

327
00:17:14,934 --> 00:17:17,968
该议定书中的变数。在你实际的类声明中，或者

328
00:17:18,037 --> 00:17:20,671
你的结构声明你可以添加一个扩展名，

329
00:17:20,740 --> 00:17:23,073
你知道我们如何扩展Int来添加arc4random。

330
00:17:23,142 --> 00:17:27,144
那么我们可以扩展Int以符合一些协议。

331
00:17:27,212 --> 00:17:29,013
好吧，那会很好。

332
00:17:29,081 --> 00:17:31,682
我们只会说扩展诠释：，

333
00:17:31,751 --> 00:17:35,653
我们想要的协议实现，然后在那里，

334
00:17:35,721 --> 00:17:39,556
和扩展我们会把所有的实现

335
00:17:39,625 --> 00:17:42,926
该议定书中的变数和方法。和

336
00:17:42,995 --> 00:17:46,163
这实际上是相当普遍的使用扩展只是为了

337
00:17:46,232 --> 00:17:49,700
代码簿。那么一些使用扩展来实现

338
00:17:49,769 --> 00:17:53,304
整个协议。这很好，它很好地组合。

339
00:17:54,740 --> 00:17:57,441
好的，我们来看一个使用类似协议的例子

340
00:17:57,510 --> 00:18:01,045
他们的类型。好的，协议是类型的。所以

341
00:18:01,113 --> 00:18:04,114
让我们来看看，在这里我有一个名为Moveable的协议。

342
00:18:04,183 --> 00:18:08,018
它有一个方法叫做移动到，好吗？

343
00:18:08,087 --> 00:18:11,188
我创建了一个叫Car的类，可以移动

344
00:18:11,257 --> 00:18:14,024
和另一个叫Shape的类，就像三角形或者

345
00:18:14,093 --> 00:18:16,694
广场，也可以移动。现在一辆车和

346
00:18:16,763 --> 00:18:20,263
一个形状，难以置信的不同的东西，一个是类和

347
00:18:20,332 --> 00:18:24,335
一个是结构，但他们都实现这个相同的协议。

348
00:18:24,404 --> 00:18:26,070
好的，我们要看代码中的样子，

349
00:18:26,139 --> 00:18:27,738
当你有这种情况时，

350
00:18:27,806 --> 00:18:29,940
这是完全合法的。所以

351
00:18:30,008 --> 00:18:31,842
我在那里创造了几个vars，

352
00:18:31,910 --> 00:18:36,980
一个prius，一个car，一个square，形状。

353
00:18:37,049 --> 00:18:39,249
好吧，现在我要宣布一个变种，移动的东西。

354
00:18:39,318 --> 00:18:44,288
这将是可移动的类型。记得我说过，

355
00:18:44,356 --> 00:18:47,391
协议是类型的。所以我把东西变成了类型

356
00:18:47,459 --> 00:18:50,862
可移动并将其分配给prius，这是允许的吗？

357
00:18:52,198 --> 00:18:54,898
我可以指派prius移动的东西吗？当然，

358
00:18:54,967 --> 00:18:58,168
因为prius实现了可移动协议。

359
00:18:58,237 --> 00:19:00,304
它实现了移动到那边，它和

360
00:19:00,372 --> 00:19:02,273
它也宣称实施了Moveable。所以

361
00:19:02,342 --> 00:19:05,075
这是一个完美的法律声明，但是

362
00:19:05,144 --> 00:19:09,847
这做了一个不是Car类型的变量

363
00:19:09,916 --> 00:19:13,851
像这样的，这是类型可移动的。所以，我可以发送

364
00:19:13,920 --> 00:19:18,655
像thingToMove.move这样的消息是完全合法的，但是

365
00:19:18,724 --> 00:19:21,625
我不能说thingToMove.changeOil，

366
00:19:21,694 --> 00:19:25,930
即使普锐斯是汽车和汽车实施changeOil。

367
00:19:25,998 --> 00:19:29,200
你明白为什么我不能发送到thingToMove？

368
00:19:29,268 --> 00:19:33,937
因为thingToMove是一个可移动的。这不是一辆车，

369
00:19:34,006 --> 00:19:36,673
这是一个可移动的。所以即使这辆车发生了

370
00:19:36,742 --> 00:19:40,311
在这个变量中，它可以做changeOil，我不能发送它。

371
00:19:40,380 --> 00:19:42,947
Swift不会允许我发送这个消息，因为

372
00:19:43,015 --> 00:19:44,282
thingToMove在Swift的

373
00:19:44,350 --> 00:19:47,751
头脑只是一个可移动的。 Swift唯一知道的

374
00:19:47,820 --> 00:19:50,421
它可以做的是移动到，对吗？

375
00:19:50,490 --> 00:19:53,056
所以这是整个幻灯片中最重要的事情，

376
00:19:53,125 --> 00:19:57,394
是那件红色的东西如果你有一个变种，你不能做改变

377
00:19:57,463 --> 00:20:02,033
这是类型thingToMove。但是你有什么东西呢？

378
00:20:02,101 --> 00:20:05,169
可以做？那么，我可以说thingToMove等于平方。

379
00:20:05,237 --> 00:20:08,272
Cuz一个正方形是一个Shape，一个Shape实现可移动。

380
00:20:08,341 --> 00:20:11,375
我甚至可以有一个可移动的数组，并把prius和

381
00:20:11,443 --> 00:20:14,311
它内部的一个正方形。因为即使是一个prius和

382
00:20:14,380 --> 00:20:15,579
square是完全不同的，

383
00:20:15,648 --> 00:20:17,882
一个结构，一个类，一个汽车，一个形状。

384
00:20:17,951 --> 00:20:20,150
他们完全没有什么不同，

385
00:20:20,219 --> 00:20:23,320
他们可以在同一个数组中，因为他们都是可移动的，

386
00:20:23,389 --> 00:20:26,957
你看到了吗？当然，我可以有功能

387
00:20:27,026 --> 00:20:29,226
可移动作为参数。这是幻灯片，

388
00:20:29,295 --> 00:20:32,029
这需要一个滑块，这是一种可移动的。和

389
00:20:32,097 --> 00:20:35,132
里面我可以说滑块移动到positionToSlideTo，

390
00:20:35,201 --> 00:20:37,501
然后我可调用给prius，

391
00:20:37,570 --> 00:20:40,637
滑动广场。完全合法地说，因为那些

392
00:20:40,706 --> 00:20:43,473
是可移动的。是的，问题？ >>这是否意味着这一举措

393
00:20:43,542 --> 00:20:44,842
去汽车和汽车的地方

394
00:20:44,911 --> 00:20:47,044
形状必须做同样的事情，或

395
00:20:47,113 --> 00:20:48,479
他们只是 -  >>你的意思是，

396
00:20:48,548 --> 00:20:51,482
做同样的事情就像执行相同的操作？好的，

397
00:20:51,551 --> 00:20:55,452
所以问题是，这是否意味着要在汽车和汽车

398
00:20:55,521 --> 00:20:58,321
移动到形状，他们必须做同样的事情吗？

399
00:20:58,390 --> 00:21:00,824
答案是，不。他们可以做任何他们想要的。

400
00:21:00,893 --> 00:21:03,760
他们可以采取任何行动，使一辆汽车或汽车有意义

401
00:21:03,829 --> 00:21:05,162
无论什么举动都是有道理的

402
00:21:05,231 --> 00:21:07,898
一个形状。 >>如果你把它分配给

403
00:21:07,967 --> 00:21:10,434
广场。你调用move to，

404
00:21:10,503 --> 00:21:13,404
它如何决定使用哪一种移动？

405
00:21:13,473 --> 00:21:14,237
>>好的，那么

406
00:21:14,306 --> 00:21:17,340
问题是如果我宣布这个Movable协议和

407
00:21:17,409 --> 00:21:19,142
那么我说的东西是可移动的。

408
00:21:19,211 --> 00:21:21,311
他们被称为移动，它如何知道使用哪一个？

409
00:21:21,380 --> 00:21:25,883
那么，因为下面的Swift知道它是哪种类型，好吧。

410
00:21:25,951 --> 00:21:28,919
当我们说thingToMove.something

411
00:21:28,988 --> 00:21:30,587
在那个层面上，我们是程序员和

412
00:21:30,656 --> 00:21:33,023
Swift正在执行，它必须是一个可移动的。

413
00:21:33,092 --> 00:21:36,393
但是现在Swift实际执行代码

414
00:21:36,462 --> 00:21:40,030
看起来和说，哦，这是一辆汽车，所以我要用汽车的moveTo。

415
00:21:40,099 --> 00:21:42,232
所以幕后的Swift就是这样做的。

416
00:21:42,301 --> 00:21:44,801
但是，我们正在打字的东西移动的全部原因

417
00:21:44,870 --> 00:21:47,538
是类型的事情是因为我们告诉每个人

418
00:21:47,607 --> 00:21:50,207
谁在阅读我们的代码，我只是用这个东西

419
00:21:50,276 --> 00:21:53,611
一个可移动的东西。我不在乎它是一辆汽车。

420
00:21:53,679 --> 00:21:56,480
我的代码适用于任何可移动的东西。所以

421
00:21:56,549 --> 00:22:00,183
我只是与阅读我的代码的人沟通

422
00:22:00,252 --> 00:22:03,387
对于我自己而言，除了Swift之外

423
00:22:03,455 --> 00:22:07,090
当然知道要执行哪一步。这是可能的

424
00:22:07,159 --> 00:22:10,561
具有必要的参数的函数的方式

425
00:22:10,630 --> 00:22:13,964
实现多个协议。所以这里slipAndSlide是

426
00:22:14,033 --> 00:22:17,968
它的功能是参数x。那些东西必须执行

427
00:22:18,036 --> 00:22:20,503
动起来，他们必须实施一些所谓的

428
00:22:20,572 --> 00:22:23,574
滑的没有显示在幻灯片上。所以现在我不能说

429
00:22:23,643 --> 00:22:26,543
slipAndSlide（prius）因为prius是可移动的，

430
00:22:26,612 --> 00:22:29,512
它不滑。所以这是不允许的，

431
00:22:29,581 --> 00:22:34,518
Swift会在这里抱怨。但这就是这样的。这就是如何

432
00:22:34,586 --> 00:22:40,123
你这样做，所以它需要多个协议遵守者。

433
00:22:40,192 --> 00:22:43,561
所以你感觉到我们如何使用一个协议init

434
00:22:43,629 --> 00:22:46,897
向函数声明变量和参数。所以

435
00:22:46,966 --> 00:22:49,633
它只是抓住协议的表面。

436
00:22:49,702 --> 00:22:51,301
是的，问题。 >> [不可思议]

437
00:22:51,370 --> 00:22:54,004
移动的东西[INAUDIBLE]

438
00:22:54,073 --> 00:22:55,405
广场。 >>是的。

439
00:22:55,474 --> 00:22:56,240
>>所以，当你

440
00:22:56,309 --> 00:22:58,876
调用函数[INAUDIBLE] >>这里让我回到

441
00:23:05,618 --> 00:23:06,816
好的，那是什么？

442
00:23:06,885 --> 00:23:09,019
>> [不可思议] >>是的。

443
00:23:09,088 --> 00:23:09,686
>> [听不清]

444
00:23:09,755 --> 00:23:11,321
>>是的，在那里。

445
00:23:11,390 --> 00:23:13,790
>>所以当你调用方法

446
00:23:13,859 --> 00:23:18,328
thingToMove。 [听不懂]好吧，他说，

447
00:23:18,397 --> 00:23:23,500
看，我设置thingToMove成为一个普鲁士人。然后我调用来，

448
00:23:23,569 --> 00:23:24,334
哪一个做了？

449
00:23:24,403 --> 00:23:28,038
显然是普鲁士人。然后我把thingToMove设置成方形。

450
00:23:28,107 --> 00:23:31,307
现在，如果我来调用，它会使用广场的一个。

451
00:23:31,376 --> 00:23:34,211
所以无论最后一件事情是什么，这就是它会

452
00:23:34,279 --> 00:23:37,848
使用。题？ >> [不可思议]

453
00:23:37,917 --> 00:23:38,515
必须在这里把它拿起来，

454
00:23:38,584 --> 00:23:40,284
实际上不需要变异？

455
00:23:40,352 --> 00:23:42,886
你可以放弃，只要有效 -

456
00:23:42,955 --> 00:23:44,120
>>很好的问题，

457
00:23:44,189 --> 00:23:48,025
他在这里说着看着Car，移到了，没有变异。

458
00:23:48,094 --> 00:23:50,627
看，在Shape这里，我们有变化。上面这儿，

459
00:23:50,696 --> 00:23:55,131
我们没有变化，那是因为Car是一个类。

460
00:23:55,200 --> 00:23:58,101
类是一个参考网站，他们不需要变异，所以

461
00:23:58,170 --> 00:24:03,407
这很好。还有其他的问题吗？好的，

462
00:24:03,475 --> 00:24:07,244
优秀。那么现在我们来谈谈协议的用法。

463
00:24:07,313 --> 00:24:09,646
现在我们知道什么协议和

464
00:24:09,715 --> 00:24:12,782
我们如何将它们放入我们的API中，我们如何使用它？好，

465
00:24:12,851 --> 00:24:16,086
超级重要的是使用这个MVC的代表事情，

466
00:24:16,155 --> 00:24:18,656
对？我们有这些通用的视图，

467
00:24:18,724 --> 00:24:21,324
像滚动视图和表格视图和类似的东西。

468
00:24:21,393 --> 00:24:24,227
然后我们有这些非常具体的控制器的东西，

469
00:24:24,296 --> 00:24:26,897
一个通用的东西如何与没有特定的东西进行交流？

470
00:24:26,966 --> 00:24:29,132
知道有关具体事情的任何事情？

471
00:24:29,201 --> 00:24:31,902
因为显然，当滚动视图从苹果转移时，

472
00:24:31,971 --> 00:24:34,704
它对浓度游戏一无所知。所以

473
00:24:34,773 --> 00:24:36,673
我们该怎么做？那么，我们使用协议，好吧，

474
00:24:36,742 --> 00:24:40,044
所以就像简单，所以这是意志，做了，应该和

475
00:24:40,112 --> 00:24:41,378
那么让我们来看看我们如何做到这一点，好吗？所以

476
00:24:41,379 --> 00:24:42,645
数据在。

477
00:24:42,715 --> 00:24:46,050
有六个步骤。首先是一个视图，像滚动视图或

478
00:24:46,118 --> 00:24:49,285
表视图，它声明它是委托协议。

479
00:24:49,354 --> 00:24:51,721
这只是一个协议，列出了所有的好的，已经做好的

480
00:24:51,790 --> 00:24:55,225
应该要发送。记住协议只是一个列表

481
00:24:55,294 --> 00:24:58,161
的方法，对不对？所以它创建该协议。然后

482
00:24:58,230 --> 00:25:01,465
视图，滚动视图，它本身创建一个var，

483
00:25:01,534 --> 00:25:05,669
一个公共变量，它很弱，事实证明。所以

484
00:25:05,737 --> 00:25:10,573
它是一个可选的，并且是该协议的类型。好的，

485
00:25:10,642 --> 00:25:13,711
现在，这是伟大的，因为现在的视图，只要它想

486
00:25:13,779 --> 00:25:16,980
发送意志，做，应该，它只是把它发送到该变种。

487
00:25:17,049 --> 00:25:19,083
而这个工作，因为该变种的协议类型，

488
00:25:19,151 --> 00:25:20,918
所以当然可以理解所有的意愿，

489
00:25:20,986 --> 00:25:24,855
应该。然后控制器来说，提高它的

490
00:25:24,924 --> 00:25:27,824
手和说，我实现了滚动视图委托

491
00:25:27,893 --> 00:25:31,395
协议，把它放在这个小类上。

492
00:25:31,464 --> 00:25:35,765
而控制器将自己设置为该委托var，

493
00:25:35,834 --> 00:25:38,802
它从字面上说，委托变量等于自我。

494
00:25:38,870 --> 00:25:41,939
所以它将自己定位为代表，这是合法的。

495
00:25:42,008 --> 00:25:43,940
因为管制员声称，嘿，

496
00:25:44,009 --> 00:25:47,844
我实现了这个委托，所以这个委托是

497
00:25:47,913 --> 00:25:51,715
键入该协议，一切都很好，好吧。接着，

498
00:25:51,784 --> 00:25:54,384
当然，控制器必须执行所有的方法

499
00:25:54,453 --> 00:25:56,886
在协议中。但是因为这是一个Objective-C

500
00:25:56,955 --> 00:25:59,790
协议，它实际上只需要实现none选项

501
00:25:59,858 --> 00:26:02,659
那些。好的，实际上在iOS的委托中，

502
00:26:02,728 --> 00:26:05,261
几乎所有的方法都是可选的。所以通常，

503
00:26:05,330 --> 00:26:08,699
你只需要实现你真正想要的。但

504
00:26:08,767 --> 00:26:11,135
控制器实现了他们所做的方法

505
00:26:11,203 --> 00:26:14,004
成功地填补了它实施它的说法。

506
00:26:14,073 --> 00:26:17,808
就是这样。现在视图连接到控制器。

507
00:26:17,877 --> 00:26:19,943
观点可以发送意志，做了，应该是所有想要的。

508
00:26:20,012 --> 00:26:22,980
它不知道什么样的班级正在做这件事。

509
00:26:23,048 --> 00:26:25,015
所有它知道，它甚至不知道它是否是一个类，

510
00:26:25,083 --> 00:26:26,884
可能是一个结构，它对此一无所知。

511
00:26:26,952 --> 00:26:29,219
它只知道这个东西实现了它的协议，

512
00:26:29,287 --> 00:26:30,955
所以它知道它可以发送好，做，和

513
00:26:31,023 --> 00:26:33,790
应该通过该委托var。好的，

514
00:26:33,859 --> 00:26:37,761
合理？所以让我们来看看代码

515
00:26:37,830 --> 00:26:41,098
这与一个滚动视图的例子，好吧。哦耶，

516
00:26:41,166 --> 00:26:45,368
抱歉。是的，你在iOS上到处都能找到这个代表团，

517
00:26:45,437 --> 00:26:49,840
它是在Objective-C世界中设计的。在斯威夫特，我们有

518
00:26:49,909 --> 00:26:52,375
关闭，我将在稍后的演讲中讨论这个问题。

519
00:26:52,444 --> 00:26:56,846
你可以使用闭包来处理这些东西。但

520
00:26:56,915 --> 00:27:00,451
即使闭包，代表团也是很酷的方式来做到这一点，

521
00:27:00,519 --> 00:27:03,653
有这种盲目的沟通。好，那么

522
00:27:03,722 --> 00:27:06,824
我们来看一下UIScrollView的例子。所以这是什么

523
00:27:06,892 --> 00:27:10,527
该滚动视图本身将具有的变种。

524
00:27:10,595 --> 00:27:13,363
好的，这是一个滚动视图var。这是一个weak，

525
00:27:13,431 --> 00:27:17,034
为什么它弱，顺便说一下？因为这里的视图

526
00:27:17,103 --> 00:27:19,236
将有一个指向控制器，和

527
00:27:19,305 --> 00:27:21,838
我们知道控制器有很多指针

528
00:27:21,907 --> 00:27:25,141
视图。他们会把自己留在堆里。好的，

529
00:27:25,210 --> 00:27:28,478
所以这个视图在这里说的是，我想指出

530
00:27:28,547 --> 00:27:32,483
谁接受我的意志，做了什么，应该如何。但如果这样做，

531
00:27:32,551 --> 00:27:34,684
做了，应该是男人想离开堆，

532
00:27:34,753 --> 00:27:36,787
这很好，只要把它设置为零和

533
00:27:36,856 --> 00:27:40,190
我会停止发送消息。好的，这样，

534
00:27:40,259 --> 00:27:42,759
该视图不会使控制器处于高温状态。

535
00:27:42,828 --> 00:27:45,495
无论如何，注意这是可选的，因为它很弱。

536
00:27:45,564 --> 00:27:47,430
这是委托，它是类型的UIScrollview委托。

537
00:27:47,499 --> 00:27:49,332
这是协议的样子，

538
00:27:49,401 --> 00:27:52,769
这是一个Objective-C协议。它被称为UIScrollDelegate，

539
00:27:52,838 --> 00:27:54,338
那里有所有的funcs。

540
00:27:54,406 --> 00:27:57,207
ScrollView滚动到这里。给我看看

541
00:27:57,276 --> 00:28:00,010
放大这里。这里面约有15个，

542
00:28:00,079 --> 00:28:02,212
如果你去看文档。所以

543
00:28:02,281 --> 00:28:05,148
现在控制器来了，MyViewController，

544
00:28:05,217 --> 00:28:09,920
它把逗号，UIViewCont，UIScrollViewDelegate

545
00:28:09,989 --> 00:28:13,157
结束并声称我执行该协议。

546
00:28:13,225 --> 00:28:15,893
那么，在它可能在其出口二传手，

547
00:28:15,961 --> 00:28:19,530
我们今天会看到一个例子。当那个scrollView

548
00:28:19,598 --> 00:28:22,499
得到迷恋在iOS上，在didSet的，

549
00:28:22,568 --> 00:28:26,036
它可能会说，scrollView.delegate = self。

550
00:28:26,105 --> 00:28:29,706
这是一个法律声明，因为委托，这是说

551
00:28:29,774 --> 00:28:34,111
这个东西在这里，是类型UIScrollViewDelegate。和

552
00:28:34,179 --> 00:28:38,315
MyViewController在这里说，它实现了。

553
00:28:38,384 --> 00:28:42,252
所以将它自己设置为委托是合法的。好的，

554
00:28:42,321 --> 00:28:44,655
一旦这样做了，他们就连上了

555
00:28:44,723 --> 00:28:47,524
现在看来可以发送意愿了，对控制器说了

556
00:28:47,593 --> 00:28:50,894
一次全部。好的，这是代表团，

557
00:28:50,962 --> 00:28:54,765
可能是协议最明显的用途之一。

558
00:28:54,833 --> 00:28:57,066
什么是另一个？好的，记住，我谈到了这个

559
00:28:57,135 --> 00:28:59,803
在可排序的业务字典键，对不对？

560
00:28:59,872 --> 00:29:02,406
所以当然，字典中的关键字必须是可排除的。

561
00:29:02,475 --> 00:29:05,442
我们如何在API中执行此操作？好，

562
00:29:05,511 --> 00:29:08,211
有一个叫做Hashable的协议。

563
00:29:08,280 --> 00:29:10,781
它从另一个称为Equatable的协议继承而来

564
00:29:10,849 --> 00:29:13,149
那是因为你知道什么关于哈希表。

565
00:29:13,218 --> 00:29:16,319
当你散列的东西，它可能是一个独特的散列，但

566
00:29:16,388 --> 00:29:17,888
它不能保证。

567
00:29:17,956 --> 00:29:21,324
你必须通过实际使用equals来追踪它

568
00:29:21,393 --> 00:29:25,529
如果这两件事实际上是平等的，那么我们在作品中散列。

569
00:29:25,598 --> 00:29:28,332
所以这就是为什么Hashable从Equatable继承的原因。

570
00:29:28,400 --> 00:29:30,333
所以如果你想成为Hashable，你也必须能够

571
00:29:30,402 --> 00:29:32,702
检查你是否等于别的东西。现在这是

572
00:29:32,771 --> 00:29:35,606
超级简单的协议，它只有一个变种。

573
00:29:35,674 --> 00:29:40,176
这是一个只有var，这是哈希值。

574
00:29:40,245 --> 00:29:44,314
有些整数，希望唯一地代表你，

575
00:29:44,382 --> 00:29:47,918
这就是这个。现在我们来看一下Equatable，好吧，

576
00:29:47,986 --> 00:29:50,453
这是因为另一个协议是继承的

577
00:29:50,522 --> 00:29:53,022
因此，这里需要。这是什么样子？

578
00:29:53,091 --> 00:29:55,258
这也是一个非常简单的协议。

579
00:29:55,327 --> 00:29:57,861
它有一个功能，一个方法，

580
00:29:57,930 --> 00:30:01,431
这是静态的。这意味着它的类型，就像获得独特的一样

581
00:30:01,500 --> 00:30:05,401
标识符在卡中，请记住？它的名字是

582
00:30:05,470 --> 00:30:09,506
==。在Swift中，请记住，方法的名称可以像表情符号一样。

583
00:30:09,575 --> 00:30:12,709
所以不需要是字母数字字符

584
00:30:12,777 --> 00:30:17,080
他们选择被称为==，这是一种很酷。和

585
00:30:17,149 --> 00:30:20,283
参数是左边和右边，

586
00:30:20,352 --> 00:30:24,454
注意到类型本身，这是一个类型方法，所以自我

587
00:30:24,523 --> 00:30:27,824
是类型。所以如果这是由int实现的，如果int

588
00:30:27,893 --> 00:30:32,262
实现公平，自我将是int。好的，

589
00:30:32,331 --> 00:30:34,498
因为它将是一个int类型的函数，等等

590
00:30:34,566 --> 00:30:35,231
左侧和

591
00:30:35,300 --> 00:30:37,233
当然，右边是整数。所以

592
00:30:37,302 --> 00:30:40,503
这基本上是说，你的类型必须有一个==

593
00:30:40,572 --> 00:30:44,173
与整数相比较的方法，或者任何你是。并看到

594
00:30:44,242 --> 00:30:48,111
如果他们是平等的，并返回一个布尔，是或否。好吧，现在，

595
00:30:48,180 --> 00:30:51,047
这就是，这就是你必须做Hashable。

596
00:30:51,116 --> 00:30:55,485
但真的很酷，Swift中的==运算符，

597
00:30:55,553 --> 00:30:59,389
好的，当你像x == y一样说的时候，那其实不是

598
00:30:59,457 --> 00:31:02,125
内置到Swift或任何东西。所有这一切是寻找

599
00:31:02,194 --> 00:31:06,162
这个方法好的所以任何两个，任何一个类都可以使用，

600
00:31:06,231 --> 00:31:10,200
可以做==，只要你实现这个协议。所以

601
00:31:10,268 --> 00:31:13,069
这个协议是需要做的哈希工作，但是

602
00:31:13,138 --> 00:31:16,506
它也使==运算符工作。我们将看到这个

603
00:31:16,575 --> 00:31:20,977
在我的集中演示中，当我去实现这个。所以，

604
00:31:21,046 --> 00:31:25,048
现在我们知道Hashable意味着你可以成为一把钥匙

605
00:31:25,116 --> 00:31:27,750
在字典中，这是如何表达的？好，

606
00:31:27,819 --> 00:31:31,054
这是一个泛型类型的字典，对不对？它有这些

607
00:31:31,122 --> 00:31:33,256
两种类型，键的类型和值的类型。

608
00:31:33,325 --> 00:31:37,693
它声明自己是Dictionary <Key：Hashable，

609
00:31:37,762 --> 00:31:42,031
Value>，这意味着key只能在那里工作

610
00:31:42,100 --> 00:31:47,237
它是Hashable。所以这就是我们如何使用协议来约束

611
00:31:47,305 --> 00:31:50,874
这些泛型类型，对不对？现在价值，在那里

612
00:31:50,943 --> 00:31:53,343
在字典中，它没有任何冒号，所以

613
00:31:53,412 --> 00:31:54,645
价值可以是任何类型。

614
00:31:54,713 --> 00:31:57,147
你可以把任何类型的value

615
00:31:57,216 --> 00:32:01,918
在字典里。但关键是要实现可排序性。所以

616
00:32:01,987 --> 00:32:07,324
让我们去集中，做这个事情。

617
00:32:07,392 --> 00:32:09,992
我们在字典里有什么？那么，我们有一个

618
00:32:10,061 --> 00:32:13,530
字典，这是表情符号的东西。它的键是int，

619
00:32:13,599 --> 00:32:16,366
整数是可散的，所以我们是好的，values

620
00:32:16,434 --> 00:32:19,802
是表情符号。 int是我们的卡片标识符。

621
00:32:19,871 --> 00:32:22,839
请记住，卡的标识符？所以，我不想这样做。

622
00:32:22,907 --> 00:32:27,210
我希望我的表情符号字典中的key是卡片。

623
00:32:27,279 --> 00:32:29,046
我想直接查找卡片，

624
00:32:29,114 --> 00:32:30,980
我不希望有任何看待这个事情的东西，

625
00:32:31,049 --> 00:32:34,183
这是荒谬的。所以，如果我去这里查看控制器。

626
00:32:34,252 --> 00:32:35,518
实际上，这里就在这里。

627
00:32:35,587 --> 00:32:39,489
看，这里是我的表情符号的东西，int到字符串，int键，

628
00:32:39,557 --> 00:32:43,627
字符串值，这必须是可散列的，现在是。

629
00:32:43,695 --> 00:32:44,594
但我不想那样

630
00:32:44,663 --> 00:32:46,329
我只想直接查看卡片。

631
00:32:46,398 --> 00:32:47,531
我不想使用标识符，

632
00:32:47,599 --> 00:32:51,134
我只是想把这个标识符从这里开始

633
00:32:51,203 --> 00:32:54,036
当我这样做，我会得到错误。

634
00:32:54,105 --> 00:32:58,508
为什么我会得到错误？因为卡在这里见？

635
00:32:58,577 --> 00:33:01,811
我们来看看是否可以做得更宽一些

636
00:33:01,880 --> 00:33:06,683
你可以在这里看到更好一点。

637
00:33:06,752 --> 00:33:11,421
它在这里说，我们不能取代，

638
00:33:11,490 --> 00:33:14,691
哦对不起。好吧，它说不能下标的值

639
00:33:14,760 --> 00:33:16,993
整数字符串与卡。当然可以，

640
00:33:17,062 --> 00:33:20,530
我说的关键是int，在这里我正在尝试这样做

641
00:33:20,599 --> 00:33:22,031
卡。所以我只会说好，

642
00:33:22,100 --> 00:33:25,001
我会让他们成为卡片。所以我只是

643
00:33:25,070 --> 00:33:28,772
会有我的字典，有卡的钥匙，字符串的值。

644
00:33:30,175 --> 00:33:36,979
那么现在我们到了什么地方？它说类型卡

645
00:33:37,048 --> 00:33:40,449
不符合协议可排序，它的工作，好吧。

646
00:33:40,518 --> 00:33:44,221
我试图让一张卡成为我的字典的关键

647
00:33:44,289 --> 00:33:47,290
它说，不，卡不符合协议可排除。

648
00:33:47,359 --> 00:33:50,293
那么你可以去查阅的声明字典

649
00:33:50,362 --> 00:33:52,028
文件，

650
00:33:52,097 --> 00:33:55,465
它说卡，关键必须是可以哈哈，而不是。所以

651
00:33:55,533 --> 00:33:58,368
我们去做卡是可以的，那么

652
00:33:58,437 --> 00:34:00,303
我们不会再有这个错误了，所以

653
00:34:00,371 --> 00:34:03,740
我要去卡，在这里。这里是卡，

654
00:34:03,808 --> 00:34:09,912
我只是说，好吧，卡可哈。

655
00:34:09,981 --> 00:34:12,983
所以我只是把卡片拆散了，现在Swift当然会

656
00:34:13,051 --> 00:34:16,486
看看这个，然后说这个卡在这里等第二个错误

657
00:34:16,555 --> 00:34:19,222
不符合可排除性。卡不符合

658
00:34:19,290 --> 00:34:22,058
到不相等的地方，因为我没有执行

659
00:34:22,127 --> 00:34:25,528
这些方法的哈希值或等于等于事物。

660
00:34:25,596 --> 00:34:28,264
Swift中真的很酷，看看这里的修复按钮。

661
00:34:28,333 --> 00:34:32,669
你想添加协议存根（stub）吗？哦，是的，请。和

662
00:34:32,737 --> 00:34:35,538
看看它做了什么。它添加了一个可散列的存根，而且

663
00:34:35,607 --> 00:34:38,808
公平的一个存根。现在我只需要实现这些。

664
00:34:38,877 --> 00:34:41,611
所以，做散列值，只能得到，

665
00:34:41,679 --> 00:34:46,149
这很容易。我只是要回我的标识符。那是

666
00:34:46,217 --> 00:34:50,987
一张非常好的散列，因为它是唯一的

667
00:34:51,056 --> 00:34:54,291
那张牌。而平等，平等也很容易

668
00:34:54,359 --> 00:34:56,526
太。我只需要比较这两张牌。

669
00:34:56,594 --> 00:34:59,462
如果左侧的标识符，我会返回

670
00:34:59,530 --> 00:35:03,433
等于右侧的标识符。所以我们走了。

671
00:35:03,501 --> 00:35:06,069
我已经实现了可拆分和可比较的。所以

672
00:35:06,138 --> 00:35:08,538
现在，如果我回到我的视图控制器，

673
00:35:08,607 --> 00:35:11,507
那个错误会消失吗？这是这里的错误。

674
00:35:11,576 --> 00:35:15,611
所以让我们让Xcode重新编译，果然看起来，

675
00:35:15,680 --> 00:35:19,015
没问题。这是完全正确的，好吧，和

676
00:35:19,084 --> 00:35:23,053
那是因为我做了这个可排序的现在，

677
00:35:23,121 --> 00:35:24,787
我们可以从中获得另一个好处。

678
00:35:24,856 --> 00:35:28,291
让我回去卡。我之前告诉过你，我不喜欢

679
00:35:28,360 --> 00:35:30,861
这个标识符是公开的。我看不出有什么理由

680
00:35:30,929 --> 00:35:32,495
它是公开的。而且我们知道我们不需要它

681
00:35:32,564 --> 00:35:35,064
现在看看我们的表情符号，所以我只是要做

682
00:35:35,133 --> 00:35:38,534
它是私人的。让我们看看这是否会工作。

683
00:35:38,603 --> 00:35:40,069
私人会怎么样？

684
00:35:40,138 --> 00:35:43,139
让我们建立并看看。哦，不，我们在这里有一些错误。

685
00:35:43,207 --> 00:35:45,942
所以我们来看看他们。这里有一个错误，它说，

686
00:35:46,011 --> 00:35:49,512
标识符由于私人保护级别而不可访问。

687
00:35:49,581 --> 00:35:51,714
没错，我把标识符设为私人。

688
00:35:51,783 --> 00:35:56,086
这里试图做什么？哦，在这里我想看看是否

689
00:35:56,154 --> 00:36:01,390
两张卡相配，哦，现在卡好实行等值。

690
00:36:01,459 --> 00:36:05,328
所以我可以像这个卡matchIndex

691
00:36:05,397 --> 00:36:10,033
=cards[index]，因为我可以直接比较卡，

692
00:36:10,102 --> 00:36:12,268
现在。他们实施equatable，对吗？

693
00:36:12,337 --> 00:36:15,305
现在，如果我们建立，那就消失了。所以

694
00:36:15,373 --> 00:36:17,440
我们通过使这个可以等同的方法获得了巨大的利益

695
00:36:17,508 --> 00:36:20,943
哈希的。我们必须直接在我们的emoji中使用它

696
00:36:21,012 --> 00:36:24,147
使代码看起来不错，看看这个代码看起来有多漂亮。

697
00:36:24,216 --> 00:36:26,549
相比之下，如何使用该标识符来查看，

698
00:36:26,618 --> 00:36:30,020
对，所以我们在使用方面清理了我们的代码

699
00:36:30,088 --> 00:36:31,354
我们能够回到卡片上

700
00:36:31,423 --> 00:36:33,789
做一些真的不需要公开的东西，

701
00:36:33,858 --> 00:36:38,194
完全私密。这很酷吗？好的，

702
00:36:38,263 --> 00:36:41,164
所以你开始看到建筑物的协议的力量

703
00:36:41,233 --> 00:36:45,402
这里。那么让我们回头看看更多的协议

704
00:36:45,470 --> 00:36:50,139
很酷的东西好的，那里

705
00:36:50,208 --> 00:36:54,610
是演示，好吧，让我们谈一谈这个倍数

706
00:36:54,679 --> 00:36:59,782
继承的一种伎俩。考虑可数范围，

707
00:36:59,851 --> 00:37:02,652
记得可数范围零点小于点的东西

708
00:37:02,720 --> 00:37:06,055
创建这个可数范围的int从零开始

709
00:37:06,123 --> 00:37:10,293
减1。可数范围实现了很多协议。

710
00:37:10,362 --> 00:37:14,063
如果你去看可数范围，它可能有12或

711
00:37:14,132 --> 00:37:16,866
15种不同的协议。那么，最有趣的两个

712
00:37:16,935 --> 00:37:19,135
它实现的是序列。

713
00:37:20,772 --> 00:37:22,088
对？可数范围是从零开始的数字序列

714
00:37:22,089 --> 00:37:23,405
这是有道理的，

715
00:37:23,474 --> 00:37:26,643
到别的东西。还收集，

716
00:37:26,711 --> 00:37:29,345
因为责任范围也是一个东西的集合。

717
00:37:29,413 --> 00:37:30,713
如果是int的可责任范围，

718
00:37:30,782 --> 00:37:32,815
它是一个int或其他的集合。和

719
00:37:32,884 --> 00:37:36,819
所以这两个协议定义了很多有趣的东西

720
00:37:36,888 --> 00:37:41,057
序列确实只有一个方法，

721
00:37:41,125 --> 00:37:44,127
接下来，这是顺序中的下一件事。

722
00:37:44,196 --> 00:37:46,862
但是，这可以让你做任何实现的东西

723
00:37:46,931 --> 00:37:49,799
序列协议可以做，好吧，就像

724
00:37:49,867 --> 00:37:53,269
任何可散列的东西都可以成为字典中的关键。

725
00:37:53,338 --> 00:37:55,571
然后，收集更多的方法，

726
00:37:55,640 --> 00:37:59,509
所有的索引，子脚本，所有的东西都是

727
00:37:59,578 --> 00:38:03,345
在收集协议。现在，我们为什么这样做呢？

728
00:38:03,414 --> 00:38:06,216
为什么我们有可数范围实现所有这些协议？

729
00:38:06,284 --> 00:38:09,652
那么，因为数组实现了所有这些，所以

730
00:38:09,721 --> 00:38:13,990
做字典和设置和字符串。所有这些类

731
00:38:14,059 --> 00:38:17,593
那是事物的序列或事物的集合

732
00:38:17,662 --> 00:38:20,129
执行所有这些完全相同的事情。和

733
00:38:20,198 --> 00:38:23,799
所以我作为程序员只需要一次学习这些东西。

734
00:38:23,868 --> 00:38:26,902
好的，我只需要一次学习。和

735
00:38:26,971 --> 00:38:29,672
所有我需要知道的是我想要的东西

736
00:38:29,741 --> 00:38:32,641
在结束必须是一个序列。所以我只能看看是不是

737
00:38:32,710 --> 00:38:34,243
这个东西实现那个协议？要么

738
00:38:34,312 --> 00:38:37,947
我甚至可以发明我自己的东西，我可以在里面。

739
00:38:38,016 --> 00:38:40,750
我所要做的就是执行排序顺序

740
00:38:40,819 --> 00:38:43,820
协议最终只有一个方法。

741
00:38:45,423 --> 00:38:49,392
所以这就是为什么因为我学习了索引，

742
00:38:49,461 --> 00:38:52,662
indexOf得到的东西，我现在可以做indexOf

743
00:38:52,731 --> 00:38:54,630
在一个字符串上，并找到一个字符串或字符

744
00:38:54,699 --> 00:38:57,667
我可以在数组中做indexOf并在那里找到。

745
00:38:57,736 --> 00:39:01,070
我甚至可以做indexOf责任范围不超

746
00:39:01,139 --> 00:39:04,273
有价值的，但如果一个范围的数量不是int，

747
00:39:04,342 --> 00:39:06,976
那么做索引试试可能会很有趣

748
00:39:07,044 --> 00:39:10,847
找到它在范围内的东西，好吧。但

749
00:39:10,915 --> 00:39:13,816
我们为什么这样做有一个更大更好的理由。

750
00:39:13,885 --> 00:39:17,854
那是因为有一点魔法，或者不是

751
00:39:17,923 --> 00:39:21,590
魔术，但在Swift中的设计实现非常好。

752
00:39:21,659 --> 00:39:25,061
协议就是这样，可以提供默认值

753
00:39:25,130 --> 00:39:31,868
方法的实现。默认实现

754
00:39:31,937 --> 00:39:37,006
的方法。所以这使得它成为可能

755
00:39:37,075 --> 00:39:39,709
我们来执行indexOf

756
00:39:39,777 --> 00:39:45,014
所有这些课程在一个地方。所以这就是为什么，

757
00:39:45,082 --> 00:39:47,617
再次，我们认为这就像多重继承因为

758
00:39:47,686 --> 00:39:51,120
他们实际上会继承实现。那么在哪里呢

759
00:39:51,188 --> 00:39:53,623
你把这个实现？因为我们知道协议是公正的

760
00:39:53,691 --> 00:39:56,525
一个没有实现的声明方法。好，

761
00:39:56,594 --> 00:39:59,962
答案是你把他们放在你的协议的扩展。

762
00:40:00,031 --> 00:40:03,066
你知道我们怎么能有扩展int？你也可以做

763
00:40:03,134 --> 00:40:07,336
扩展协议。在这个扩展中，你可以

764
00:40:07,405 --> 00:40:10,206
实现许多其他协议方法，只要你想。

765
00:40:10,275 --> 00:40:12,709
现在你有点受限制，因为

766
00:40:12,777 --> 00:40:14,877
扩展程序不能有任何存储。

767
00:40:14,946 --> 00:40:17,713
我们知道，对吗？没有变数，所以这当然

768
00:40:17,782 --> 00:40:21,117
限制。在扩展中，也是唯一的

769
00:40:21,186 --> 00:40:24,119
你可以使用的方法来实现它的方法

770
00:40:24,188 --> 00:40:26,990
在协议中或在您继承的协议中。

771
00:40:27,058 --> 00:40:30,126
所以，像收集一样，恰好从序列继承

772
00:40:30,194 --> 00:40:32,729
很多收集方法都可以实现

773
00:40:32,797 --> 00:40:35,364
通过整个顺序来使用顺序

774
00:40:35,433 --> 00:40:39,301
收集和查找事物的顺序，或其他。

775
00:40:39,370 --> 00:40:44,173
所以如果你看这里，顺序有一个重要的方法

776
00:40:44,242 --> 00:40:46,609
接下来是序列中的下一个事物。但

777
00:40:46,678 --> 00:40:48,711
序列也有所有这些其他的方法，

778
00:40:48,779 --> 00:40:51,414
包含哪些东西在序列中找到，

779
00:40:51,483 --> 00:40:54,783
对于哪一种做n做什么。加入

780
00:40:54,852 --> 00:40:57,586
分隔符，它将序列中的所有东西，

781
00:40:57,655 --> 00:41:00,356
将其转换为字符串并创建一个大的字符串

782
00:41:00,425 --> 00:41:04,293
由逗号或空格分隔符加入。它有分钟，

783
00:41:04,362 --> 00:41:06,729
在这个序列中找到我最小的东西，最大，

784
00:41:06,798 --> 00:41:10,133
最大的事情。甚至有封闭的功能，

785
00:41:10,201 --> 00:41:12,001
我将尽快讨论过滤器和

786
00:41:12,070 --> 00:41:15,171
地图，即对序列进行重大操作。

787
00:41:15,240 --> 00:41:17,740
那么所有这些东西的执行都包含在内，

788
00:41:17,808 --> 00:41:19,909
forEach，加入，min，max所有这些东西。

789
00:41:19,978 --> 00:41:23,512
这些都是在扩展中实现的

790
00:41:23,581 --> 00:41:27,583
苹果提供了如此，如果你想有一个序列，

791
00:41:27,652 --> 00:41:30,586
只要你把下一件事情落实到下一个

792
00:41:30,655 --> 00:41:33,222
顺序中的东西你得到所有这些的实现

793
00:41:33,291 --> 00:41:36,892
其他的东西是免费的。这也意味着数组，并设置

794
00:41:36,961 --> 00:41:39,595
和字典，可数范围都是共享的

795
00:41:39,663 --> 00:41:42,398
最小和最大以及所有这些东西的实现。

796
00:41:42,466 --> 00:41:45,134
现在，这些只是默认的实现。

797
00:41:45,203 --> 00:41:48,337
如果一个数组实际上实现了min或max或

798
00:41:48,405 --> 00:41:50,740
类似的东西。也许你可以更有效地做到这一点

799
00:41:50,808 --> 00:41:51,941
比默认实现还是

800
00:41:52,010 --> 00:41:55,978
随你。你能行的。但它取代了默认值

801
00:41:56,047 --> 00:41:58,915
在扩展中的实现。

802
00:41:58,983 --> 00:42:00,983
好吧，但你是否感觉到我在说什么？

803
00:42:01,052 --> 00:42:03,385
为什么这是有价值的这些默认模仿。

804
00:42:03,454 --> 00:42:05,921
你可以有这些非常强大的协议和

805
00:42:05,990 --> 00:42:07,690
你只需要实现其中的一种方法

806
00:42:07,759 --> 00:42:08,690
你会得到的实现

807
00:42:08,759 --> 00:42:11,293
他们全部。然后他们在所有这些奇怪的共享

808
00:42:11,362 --> 00:42:13,061
像数组，字符串，

809
00:42:13,130 --> 00:42:16,765
可数范围。他们都得到所有这些实现他们

810
00:42:16,834 --> 00:42:18,801
不必执行任何这些，他们可以免费获得。

811
00:42:20,971 --> 00:42:23,739
现在我谈论泛型的所有这些，

812
00:42:23,808 --> 00:42:28,678
价值打字，var与让不变性

813
00:42:28,746 --> 00:42:33,750
控制，通过协议，扩展或约束来约束事物

814
00:42:33,818 --> 00:42:36,685
协议。所有这些东西加起来支持一种

815
00:42:36,754 --> 00:42:39,322
编程称为函数式编程。多少人

816
00:42:39,391 --> 00:42:42,591
这里听说过函数式编程吗？

817
00:42:42,660 --> 00:42:43,993
大约一半的人，看？所以

818
00:42:44,062 --> 00:42:46,062
我鼓励你在斯坦福职业生涯中，

819
00:42:46,130 --> 00:42:48,765
去上课并学习函数式编程。

820
00:42:48,833 --> 00:42:51,467
有人会说这是一种进化，

821
00:42:51,535 --> 00:42:54,270
面向对象编程。这是一点点

822
00:42:54,339 --> 00:42:56,538
不同的思维方式分开。

823
00:42:56,607 --> 00:42:58,774
它可以让你得到多重继承的东西

824
00:42:58,843 --> 00:43:00,977
没有事情完全失去控制。

825
00:43:01,046 --> 00:43:02,744
由于事情不是堆积如山，

826
00:43:02,813 --> 00:43:05,414
你没有20个指针，你不确定

827
00:43:05,483 --> 00:43:07,950
谁来修改东西，所以你的程序要多得多

828
00:43:08,018 --> 00:43:10,552
可证明的，对不对？你可以证明他们做他们做的事情。

829
00:43:10,621 --> 00:43:13,322
你不必担心是什么指针搞乱了这个

830
00:43:13,390 --> 00:43:15,758
它堆的好处很多。现在，

831
00:43:15,827 --> 00:43:17,560
Swift真的很酷，

832
00:43:17,629 --> 00:43:20,329
它支持这两种编程模型。

833
00:43:20,397 --> 00:43:22,898
面向对象的编程，这就是我要的

834
00:43:22,967 --> 00:43:24,967
因为这是这个课程的先决条件

835
00:43:25,036 --> 00:43:27,203
这个类，和函数式编程，

836
00:43:27,271 --> 00:43:31,373
这几乎是所有的基础

837
00:43:31,442 --> 00:43:35,545
基础框架如字典，数组，字符串，

838
00:43:35,613 --> 00:43:38,380
所有这些事情。这些都是建立一个功能

839
00:43:38,449 --> 00:43:42,117
编程模型。 Swift同样支持它们，

840
00:43:42,186 --> 00:43:44,219
这真的很棒。所以这是你最好的，

841
00:43:44,288 --> 00:43:46,088
这是Haskell等语言的混合，

842
00:43:46,156 --> 00:43:48,457
你们有多少人听说过Haskell的语言？

843
00:43:48,525 --> 00:43:51,160
好吧，那些了解函数式编程的人，

844
00:43:51,229 --> 00:43:53,863
对，所以Haskell是一个纯粹的函数式编程

845
00:43:53,932 --> 00:43:56,532
语言，你知道，就像纯粹的对象Java

846
00:43:56,600 --> 00:44:01,137
面向语言。这是两个很好的组合。这就是我

847
00:44:01,205 --> 00:44:03,773
关于函数式编程，就这么说吧

848
00:44:03,841 --> 00:44:07,509
你知道它在那里。这就是协议。

849
00:44:07,578 --> 00:44:11,113
当你看到这一切的行动，将会更有意义。

850
00:44:11,181 --> 00:44:12,114
希望这是很有道理的。

851
00:44:12,183 --> 00:44:14,016
现在的确是，协议非常简单。

852
00:44:14,085 --> 00:44:16,485
只是列表，但我们可以用强大的方式使用它们，

853
00:44:16,553 --> 00:44:20,522
好吧。现在我们来简单谈谈一些事情

854
00:44:20,591 --> 00:44:23,459
这不是非常重要的，但几乎是弦乐

855
00:44:23,528 --> 00:44:26,028
每个应用程序我只想谈谈我们如何

856
00:44:26,097 --> 00:44:28,531
索引到字符串，因为它不是你会的

857
00:44:28,599 --> 00:44:33,035
认为这是乍一看。除了字符串，

858
00:44:33,104 --> 00:44:36,572
结构体字符串，还有另外一个结构体

859
00:44:36,641 --> 00:44:40,543
所谓的性格。现在，一个角色就是我们人类

860
00:44:40,611 --> 00:44:44,580
会认为是一个字符。在屏幕上或

861
00:44:44,649 --> 00:44:49,519
随你。但是，一个字符串不是一个序列。一个字符串是

862
00:44:49,587 --> 00:44:52,355
一个由角色构建的底层，它是用内置的

863
00:44:52,423 --> 00:44:56,659
统一码。好的，unicodes只是一些小块

864
00:44:56,728 --> 00:45:00,162
这几乎可以代表地球上的任何语言。好的，

865
00:45:00,231 --> 00:45:02,631
这是国际性的。你知道，像ASCII。

866
00:45:02,700 --> 00:45:05,501
我们曾经有ASCII，你只能真正做英文。

867
00:45:05,569 --> 00:45:07,870
Unicodes在地球上做所有的语言。

868
00:45:07,939 --> 00:45:10,773
所以这是一个字符串。所以我们有一点点

869
00:45:10,841 --> 00:45:13,976
试图跨越Unicodes和世界之间的桥梁

870
00:45:14,045 --> 00:45:17,212
字符。所以让我以身作则，

871
00:45:17,281 --> 00:45:22,351
如果我们有CAFE这个词，对不对？

872
00:45:22,419 --> 00:45:25,054
我们认为有四个字符，C，A，

873
00:45:25,122 --> 00:45:27,290
F和E都带有口音。但

874
00:45:27,358 --> 00:45:30,526
它可能由五个Unicodes代表，因为有

875
00:45:30,595 --> 00:45:33,162
一个Unicode的重音在前面

876
00:45:33,231 --> 00:45:38,434
人物，好的，所以，它可以有五个Unicodes。那么，那么

877
00:45:38,503 --> 00:45:41,704
我们如何处理这个？那么，主要的问题还是

878
00:45:41,772 --> 00:45:46,175
这是主要的分支

879
00:45:46,243 --> 00:45:50,980
不能通过int索引。因为如果我们有一个短语，

880
00:45:51,049 --> 00:45:54,449
咖啡香蒜酱，就在那里。我最喜欢的披萨关节之一

881
00:45:54,518 --> 00:45:58,020
夏威夷，咖啡香蒜。 p是在索引5或

882
00:45:58,088 --> 00:46:02,925
是在索引6？这取决于e是否是

883
00:46:02,993 --> 00:46:07,029
一个e口音或两个Unicode这里有e和

884
00:46:07,097 --> 00:46:11,634
口音。那么，呃，我们要在这里做什么？所以

885
00:46:11,702 --> 00:46:16,138
我们所做的是我们不用int来索引字符串。

886
00:46:16,207 --> 00:46:19,708
相反，字符串是由它们自己的特殊类型索引的，

887
00:46:19,777 --> 00:46:23,979
String.Index。这是唯一的方法

888
00:46:24,048 --> 00:46:26,215
在String上使用下标，

889
00:46:26,283 --> 00:46:30,285
你需要一个String.Index，而不是一个Int。所以这使得这个，

890
00:46:30,354 --> 00:46:33,022
人们不喜欢这个。他们想索引Strings和Int

891
00:46:33,090 --> 00:46:36,358
我明白为什么，但你不能那样做。所以

892
00:46:36,427 --> 00:46:39,362
那是什么意思？那么，我们必须得到一个指数，所以

893
00:46:39,430 --> 00:46:42,565
我们如何获得索引？那么，你可以得到startIndex

894
00:46:42,633 --> 00:46:45,834
的字符串，你可以得到一个字符串的endIndex。

895
00:46:45,903 --> 00:46:49,438
您也可以使用索引（of :)一个字符来查找第一个字符

896
00:46:49,506 --> 00:46:52,241
该字符的索引。所以有一些不同的

897
00:46:52,309 --> 00:46:55,144
方法和字符串变量来获得索引。

898
00:46:55,212 --> 00:46:58,814
一旦你有了一个索引，现在你可以抵消

899
00:46:58,883 --> 00:47:02,951
该指数由一个Int。所以如果你想获得第四名

900
00:47:03,020 --> 00:47:05,454
字符串中的字符，你必须得到startIndex和

901
00:47:05,522 --> 00:47:08,323
然后将它抵消三，从而得到第四个指数

902
00:47:08,392 --> 00:47:11,960
第一到第四。所以，让我们来看看这个代码

903
00:47:12,029 --> 00:47:14,597
使这项工作。所以这里是我的披萨咖啡香蒜酱

904
00:47:14,665 --> 00:47:17,733
我会说第一个字符的索引

905
00:47:17,802 --> 00:47:20,769
pizzaJoint.startIndex不是一个Int。

906
00:47:20,838 --> 00:47:23,438
它是String.Index类型的。

907
00:47:23,507 --> 00:47:25,374
现在我要拿第四个字

908
00:47:25,443 --> 00:47:28,010
第一个字符，并抵消它三。

909
00:47:28,079 --> 00:47:29,444
现在我已经得到了第四个字符的索引。

910
00:47:29,513 --> 00:47:32,881
现在我要通过使用实际的第四个字符

911
00:47:32,950 --> 00:47:36,952
下标。 PizzaJoint，下标，第四个字符，

912
00:47:37,021 --> 00:47:40,222
索引，子类型String.index的第四个字符索引，

913
00:47:40,290 --> 00:47:43,525
不是int类型的。而且我也可以做索引（:)的，所以

914
00:47:43,594 --> 00:47:46,695
在这里，我要说的是firstSpace角色

915
00:47:46,764 --> 00:47:50,032
咖啡香蒜是pizzaJoint.index（of：“”）。

916
00:47:50,101 --> 00:47:51,767
现在我不得不说的原因是，

917
00:47:51,836 --> 00:47:53,836
当然，索引（“：”）可以返回零。

918
00:47:53,904 --> 00:47:56,672
披萨可能没有任何空格。

919
00:47:56,740 --> 00:47:58,507
碰巧有，但可能没有。

920
00:47:58,575 --> 00:48:01,410
那么它将返回零。所以我现在要做的就是让现在，

921
00:48:01,479 --> 00:48:03,412
我有这个空间的索引。

922
00:48:03,480 --> 00:48:06,181
现在我要把索引拿到第二个开头

923
00:48:06,250 --> 00:48:08,417
词，那里有香蒜酱这个词。和

924
00:48:08,485 --> 00:48:12,054
我们通过将第一个空间索引到一个索引来完成。

925
00:48:12,123 --> 00:48:15,390
我会假设在词语之间有一个空格，

926
00:48:15,459 --> 00:48:18,593
去下一个。而现在，我要说出全部的话

927
00:48:18,662 --> 00:48:25,201
香草通过索引字符串与范围，好吧。索引

928
00:48:25,269 --> 00:48:27,903
的字符串不一定是一个单独的索引。

929
00:48:27,972 --> 00:48:31,040
这可能是一系列的索引。现在你注意到了

930
00:48:31,109 --> 00:48:35,511
做一个范围，我使用完全相同的点，

931
00:48:35,580 --> 00:48:38,247
小点，小于我做这个可数时做的事情

932
00:48:38,315 --> 00:48:42,585
INTs的范围。范围是泛型类型。他们没有

933
00:48:42,653 --> 00:48:45,787
成为INTs。它们可以是一个string.index的范围。

934
00:48:45,856 --> 00:48:50,325
完全合法。就像我们之前看到的，我们有一个范围，

935
00:48:50,394 --> 00:48:52,727
可计数范围，双精度浮点。

936
00:48:52,796 --> 00:48:55,196
请记住，在最后一次讲座的开始？所以

937
00:48:55,265 --> 00:48:58,767
范围是泛型类型。所以

938
00:48:58,836 --> 00:49:02,738
在下标中使用范围是完全合法的

939
00:49:02,806 --> 00:49:05,441
在任何有收藏下标的地方都是如此。

940
00:49:07,011 --> 00:49:08,844
顺便说一句，这些方法，这些索引，

941
00:49:08,913 --> 00:49:11,646
offsetBy，那些不是字符串中的方法，

942
00:49:11,715 --> 00:49:13,582
那些是收集的方法。好的，

943
00:49:13,651 --> 00:49:15,284
选择协议，字符串可能或

944
00:49:15,352 --> 00:49:18,087
可能不会自行实现，取决于字符串。

945
00:49:18,155 --> 00:49:21,156
收集协议也是通用的，所以索引

946
00:49:21,225 --> 00:49:25,160
你在集合中使用是可配置的。对于

947
00:49:25,229 --> 00:49:28,664
一个字符串，它是一个string.index。顺便说一句，另一种方式

948
00:49:28,733 --> 00:49:31,634
得到第二个字，也许我们会用，是

949
00:49:31,702 --> 00:49:35,570
一个更复杂的方法，如组件分隔。所以

950
00:49:35,639 --> 00:49:39,508
被分隔的组件是一个收集方法。你给它

951
00:49:39,577 --> 00:49:42,979
一个元素，将在该集合和

952
00:49:43,047 --> 00:49:46,282
它会创建一个包含所有东西的数组，

953
00:49:46,351 --> 00:49:48,751
数组中的所有元素分组

954
00:49:48,819 --> 00:49:52,588
被那东西隔开。所以这会给你一个数组

955
00:49:52,656 --> 00:49:55,857
所有由空格隔开的单词。然后我会抓住

956
00:49:55,926 --> 00:49:59,294
索引一，这将是第二个字。好的，

957
00:49:59,363 --> 00:50:02,031
所以我告诉你如何直接做索引，但是

958
00:50:02,100 --> 00:50:04,000
很多时候我们使用更高的水平

959
00:50:05,302 --> 00:50:09,871
东西在字符串中。好，那么字符串，

960
00:50:09,940 --> 00:50:14,109
就像我说的，是一个字符的集合。就像一个数组

961
00:50:14,178 --> 00:50:15,978
是任意东西的集合，

962
00:50:16,046 --> 00:50:19,214
int的可负责范围是int的集合，等等

963
00:50:19,283 --> 00:50:22,017
所有的东西都来自收藏。和集合是

964
00:50:22,086 --> 00:50:24,686
我们知道的一个序列，所以你当然可以做

965
00:50:24,755 --> 00:50:28,657
c如果s是一个字符串c将是一个严格的字符，你

966
00:50:28,725 --> 00:50:31,460
可以迭代所有字符的四个循环。

967
00:50:31,529 --> 00:50:34,930
还有一个非常酷的数组初始化器

968
00:50:34,998 --> 00:50:39,067
以一个序列作为参数。所以你可以说，

969
00:50:39,136 --> 00:50:42,638
任何序列的数组以及它将要做的是通过这个

970
00:50:42,706 --> 00:50:45,774
序列并把每个元素放入数组中。

971
00:50:45,842 --> 00:50:47,209
所以它为你创造了一个大数组，

972
00:50:47,277 --> 00:50:48,978
因为它是一个数组初始值设定项。和

973
00:50:49,046 --> 00:50:52,214
在数组中将是序列的所有元素。所以

974
00:50:52,283 --> 00:50:54,883
因为一个字符串是一个字符序列，如果你说

975
00:50:54,952 --> 00:50:59,321
字符串数组，你将得到它的字符数组。和

976
00:50:59,390 --> 00:51:03,592
现在你可以使用int来索引他们，如果你想。所以有时候

977
00:51:03,661 --> 00:51:06,194
人们，他们厌倦了所有这些字符串索引的东西。

978
00:51:06,263 --> 00:51:08,229
他们只是创建一个字符数组。和

979
00:51:08,298 --> 00:51:11,967
那么现在他们可以使用整数来获得各种字符。

980
00:51:13,204 --> 00:51:16,071
这也是一个窍门。

981
00:51:16,140 --> 00:51:19,374
啊，记住一个字符串是一个值类型，它是一个结构体，

982
00:51:19,443 --> 00:51:22,177
我们几乎总是使用不变的字符串，比如let s equal

983
00:51:22,246 --> 00:51:24,213
东西，我们正在不断改进，

984
00:51:24,281 --> 00:51:26,781
但当然有可变的版本，可变的

985
00:51:26,850 --> 00:51:30,519
方法。还有另一种称为范围的协议

986
00:51:30,587 --> 00:51:33,121
可替换的收藏。这是一个集合

987
00:51:33,190 --> 00:51:37,793
可以被突变。事情的范围可以被取代。所以

988
00:51:37,862 --> 00:51:40,862
这里是插入内容的一种方法

989
00:51:40,931 --> 00:51:45,233
字符的集合，该字符串在索引处，

990
00:51:45,302 --> 00:51:47,336
所以在这种情况下它是空间的索引，

991
00:51:47,404 --> 00:51:49,871
这是一个string.index就在那里。

992
00:51:49,940 --> 00:51:54,477
所以我可以将foo这个单词插入Cafe Pastel。所以

993
00:51:54,545 --> 00:51:56,111
你可以做到这一点，我们不这么做。

994
00:51:56,180 --> 00:51:58,814
我们倾向于坚持不懈地使用它们，我们使用plus

995
00:51:58,882 --> 00:52:04,052
把它们加在一起，就像那样。所以这是字符串，

996
00:52:04,121 --> 00:52:06,088
这是对索引的一点古怪。

997
00:52:06,156 --> 00:52:09,858
现在，字符串中还有很多其他的方法，我想要

998
00:52:09,927 --> 00:52:11,427
告诉你一个有趣的事情之一。

999
00:52:11,495 --> 00:52:16,265
所以这里是替换范围，其中，我的指针不工作

1000
00:52:16,333 --> 00:52:18,133
任何更多，但如果你看替换范围，

1001
00:52:18,201 --> 00:52:21,069
你看到哪里是红色的，在那里？那就是那个点

1002
00:52:21,138 --> 00:52:23,905
点小于东西，看，我忘了把东西

1003
00:52:23,974 --> 00:52:28,076
左边。那么这个范围是从哪里来的呢？好的，

1004
00:52:28,145 --> 00:52:31,613
我们知道它去了s.endIndex。那么，Swift足够聪明

1005
00:52:31,682 --> 00:52:35,150
知道这是一个str的范围，字符串索引，

1006
00:52:35,219 --> 00:52:38,854
所以它会自动把开始索引放在开头。

1007
00:52:38,923 --> 00:52:40,155
如果你离开另一边，

1008
00:52:40,224 --> 00:52:43,659
它会自动把结束索引在最后。所以

1009
00:52:43,728 --> 00:52:46,228
你可以哦，把那些安排好的东西放开。

1010
00:52:46,297 --> 00:52:48,764
但是Swift必须能够推断出最新的类型

1011
00:52:48,833 --> 00:52:50,065
在那里。所以你不能总是这样做，

1012
00:52:50,134 --> 00:52:53,702
但在这种情况下，你可以。可以，然后呢

1013
00:52:53,771 --> 00:52:58,274
这是字符串。我想我们会这样走。所以，

1014
00:52:58,342 --> 00:53:02,611
让这一切都可以理解让我们回到我们的，

1015
00:53:02,679 --> 00:53:08,249
恩，浓度。我们要做这个

1016
00:53:08,318 --> 00:53:12,421
事情就在这里，这个表情符号的选择，

1017
00:53:12,489 --> 00:53:15,424
这是当前的表情符号字符串数组。

1018
00:53:15,492 --> 00:53:17,759
我会改变这一点。我要复制并粘贴在这里。

1019
00:53:17,828 --> 00:53:21,730
我要把它从一个数组改成一个字符串。

1020
00:53:21,799 --> 00:53:24,433
所以我要脱掉阵列的东西。

1021
00:53:24,501 --> 00:53:29,304
而且我会摆脱所有这些小逗号。和

1022
00:53:29,373 --> 00:53:32,707
现在emojiChoices将会是一个字符串。

1023
00:53:32,776 --> 00:53:35,577
而且我会让我的代码是相同的，

1024
00:53:35,646 --> 00:53:38,179
但不是把它从阵列中拿出来，而是要抓住它

1025
00:53:38,248 --> 00:53:41,250
出来的字符串。现在，只要我将其更改为一个字符串，

1026
00:53:41,319 --> 00:53:44,853
看看会发生什么。无法转换类型的值

1027
00:53:44,921 --> 00:53:49,625
int到期望的参数，string.index。好吧，

1028
00:53:49,694 --> 00:53:52,027
在这里，我们移动去除的东西，

1029
00:53:52,095 --> 00:53:57,365
你认为在哪里宣布？任何人都想猜？

1030
00:53:57,434 --> 00:54:02,437
这是一个数组的东西？一个字符串？没有，

1031
00:54:02,506 --> 00:54:04,973
这是在收藏，范围可替换的收藏，对吧？

1032
00:54:05,042 --> 00:54:07,142
所以它是在一个协议的地方，这两个字符串和

1033
00:54:07,211 --> 00:54:07,976
数组实现。所以

1034
00:54:08,045 --> 00:54:10,178
你会认为它应该在这里工作，

1035
00:54:10,247 --> 00:54:13,315
因为表情符号的选择，是的，现在它是一个字符串，但删除

1036
00:54:13,384 --> 00:54:15,884
在范围内可更换的收藏品，他们是范围

1037
00:54:15,952 --> 00:54:18,454
可替换的收藏。为什么这个工作？好，

1038
00:54:18,522 --> 00:54:21,823
因为字符串不是通过ints索引的。和

1039
00:54:21,892 --> 00:54:25,494
所以这是行不通的。所以我们必须创建一个string.index，

1040
00:54:25,562 --> 00:54:29,465
我会这样做的。我要创建一个随机字符串索引

1041
00:54:29,533 --> 00:54:34,002
而且我会通过使用索引抵消的东西来做到这一点。

1042
00:54:34,070 --> 00:54:38,172
我会说，表情符号给了我一个索引，我会

1043
00:54:38,241 --> 00:54:41,276
在这里使用这第一个，索引offsetBy，这让我们

1044
00:54:41,344 --> 00:54:44,446
采取一个已知的指数，并用别的东西抵消它。

1045
00:54:44,515 --> 00:54:47,716
我将要开始的已知索引是起始索引

1046
00:54:47,785 --> 00:54:51,219
这个东西，所以，emojiChoices.startIndex和

1047
00:54:51,288 --> 00:54:54,989
我会用随机int来抵消。所以这个抵消，

1048
00:54:55,058 --> 00:54:58,627
那可以通过int。那恰好是因为

1049
00:54:58,696 --> 00:55:01,797
这个特定的收藏进展，或距离

1050
00:55:01,865 --> 00:55:05,434
索引之间是一个int。即使索引

1051
00:55:05,503 --> 00:55:08,503
他们自己是字符串点索引。所以我这样做。

1052
00:55:08,572 --> 00:55:11,273
所以现在我要在这里和随机的字符串索引

1053
00:55:11,341 --> 00:55:14,476
一切都会好的，对吗？因为删除，

1054
00:55:14,544 --> 00:55:17,979
哦，不，还是不行。这个错误是什么？

1055
00:55:18,048 --> 00:55:23,451
不能将类型字符的值赋给字符串。

1056
00:55:23,520 --> 00:55:25,054
好的，这是一本字典，这是寻找

1057
00:55:25,122 --> 00:55:29,124
字符串。好的？为什么这是一个字符？好，

1058
00:55:29,192 --> 00:55:32,894
因为一个字符串是一个字符的集合。所以

1059
00:55:32,963 --> 00:55:37,565
如果删除，我删除一个字符。所以这里没问题，

1060
00:55:37,634 --> 00:55:40,168
我们知道我们可以转换类型。和

1061
00:55:40,237 --> 00:55:42,704
我们将通过使用一个字符串初始化程序来做到这一点

1062
00:55:42,773 --> 00:55:44,606
以一个角色作为参数和

1063
00:55:44,675 --> 00:55:47,409
返回一个字符串，其中只有该字符。所以现在

1064
00:55:47,478 --> 00:55:51,313
我们转换它。就是这样了。这就是我们需要做的。

1065
00:55:51,381 --> 00:55:55,684
而我这样做只是为了让你能看到所有的抵消

1066
00:55:55,752 --> 00:55:57,653
所有的东西，所以你可以看到我们将如何索引这一点

1067
00:55:57,721 --> 00:56:00,121
成一个字符串，而不是在这里做。所以，希望

1068
00:56:00,190 --> 00:56:02,991
这还在工作。是的。它还在工作。

1069
00:56:04,261 --> 00:56:09,397
好的？知道每个人？关于这个问题？所以

1070
00:56:09,466 --> 00:56:11,767
这是这里编码的重要线。和

1071
00:56:11,835 --> 00:56:14,102
也有一点理解，即使

1072
00:56:14,170 --> 00:56:17,973
在收藏范围内取出，可更换收藏，

1073
00:56:18,042 --> 00:56:21,075
类型很重要，因为它是一个通用类型。

1074
00:56:21,144 --> 00:56:25,347
集合是一个通用类型的协议。好吧，

1075
00:56:25,416 --> 00:56:29,251
我们回去吧。哎呀，不在那里。在这里，没有。这里。

1076
00:56:29,319 --> 00:56:33,755
好吧，让我们来谈谈另一个类

1077
00:56:33,823 --> 00:56:37,425
做与NSAttributedString的字符串。对于

1078
00:56:37,494 --> 00:56:41,429
NSAttributedString是一个字符串，每个字符

1079
00:56:41,498 --> 00:56:43,765
有一个小字典与它相关联。和

1080
00:56:43,834 --> 00:56:46,067
该词典可以有很多小键和

1081
00:56:46,136 --> 00:56:50,471
说明如何在屏幕上绘制该字符的值。

1082
00:56:50,540 --> 00:56:53,741
那么这些字典可以有字体，颜色，

1083
00:56:53,810 --> 00:56:57,179
所有这些事情。好的，这是一个属性字符串，

1084
00:56:57,247 --> 00:57:00,249
对？一个字符串与每个字符的属性，

1085
00:57:00,317 --> 00:57:04,652
对？每个人物都可以拥有的词典。

1086
00:57:04,721 --> 00:57:06,354
钥匙是众所周知的，

1087
00:57:06,423 --> 00:57:08,256
你可以在文档中查找它们。

1088
00:57:08,325 --> 00:57:12,260
值取决于事物的类型，所以

1089
00:57:12,328 --> 00:57:14,796
有时这些值是UI字体，这是一个字体的东西，

1090
00:57:14,865 --> 00:57:15,998
有时价值是颜色，

1091
00:57:16,066 --> 00:57:19,267
有时他们是浮点数等等。

1092
00:57:19,336 --> 00:57:23,471
现在很多时候，我们使用相同的字典很长

1093
00:57:23,540 --> 00:57:27,342
人物的范围，对吧？你知道，如果用户选择

1094
00:57:27,411 --> 00:57:30,478
屏幕上的一些文字，他们说，使它橙色，然后我们

1095
00:57:30,547 --> 00:57:33,215
会有一个所有这些字符的字典，所以不是

1096
00:57:33,283 --> 00:57:36,618
像每个字符都必须有不同的字典。

1097
00:57:36,686 --> 00:57:37,919
而在你的作业中，

1098
00:57:37,988 --> 00:57:40,856
整个String将会有一个Dictionary。所以

1099
00:57:40,924 --> 00:57:43,758
我给你一个非常容易使用的归因字符串和

1100
00:57:43,827 --> 00:57:47,629
你会明白为什么我会在这一刻做到这一点。

1101
00:57:47,698 --> 00:57:50,398
一旦你有一个所有这些字体和

1102
00:57:50,467 --> 00:57:51,700
每个角色的颜色，

1103
00:57:51,769 --> 00:57:55,604
现在你可以用它来设置UI标签中的文字，或者

1104
00:57:55,672 --> 00:57:58,539
设置一个UIButton的标题。或者下周我们

1105
00:57:58,608 --> 00:58:01,209
要学习如何直接在屏幕上绘制它，在我们自己的

1106
00:58:01,278 --> 00:58:06,214
绘图班。好的？这是你如何创建和

1107
00:58:06,283 --> 00:58:08,383
使用一个AttributedString，它变成了红色。

1108
00:58:08,451 --> 00:58:10,919
任何时候你在我的幻灯片上都看到红色，就像是哦，

1109
00:58:10,988 --> 00:58:15,123
小心。这是红色的，因为它真的很奇怪。

1110
00:58:15,192 --> 00:58:18,426
好的？为什么这真的很奇怪？那真的很奇怪

1111
00:58:18,495 --> 00:58:22,263
因为这是一个试图生存的Objective-C API

1112
00:58:22,332 --> 00:58:25,166
在Swift的世界里，这需要一点点

1113
00:58:25,235 --> 00:58:27,602
妥协。这里没有太多的API。

1114
00:58:27,671 --> 00:58:30,372
每当iOS出来，我总是希望在那里下一个

1115
00:58:30,441 --> 00:58:33,174
可以有Non NSAttributedString，只是

1116
00:58:33,243 --> 00:58:36,445
常规的AttributedString现在可以解决这个问题，但他们没有

1117
00:58:36,513 --> 00:58:39,214
做了呢。所以，当你声明这些属性时，

1118
00:58:39,282 --> 00:58:41,482
每个字符上的小字典，

1119
00:58:41,551 --> 00:58:43,919
你必须给它一个明确的类型。

1120
00:58:43,988 --> 00:58:45,920
你不能让这个类型被推断出来

1121
00:58:45,989 --> 00:58:48,289
那是因为这些值可能是字体，

1122
00:58:48,358 --> 00:58:50,959
颜色，不管。所以，一个来源不能推断出什么价值

1123
00:58:51,028 --> 00:58:53,795
字典是。所以他们打字，你会用

1124
00:58:53,864 --> 00:58:56,965
这里是Keys NSAttributedString键。

1125
00:58:57,033 --> 00:58:59,134
你可以在文档中查看，

1126
00:58:59,203 --> 00:59:02,470
看看有什么选择。这是像字体，下划线，

1127
00:59:02,539 --> 00:59:04,840
彻底打破所有你认为是的事情。

1128
00:59:04,908 --> 00:59:08,876
然后值是Any。可以，然后呢

1129
00:59:08,945 --> 00:59:12,413
任何一个特殊的Swift都意味着什么

1130
00:59:12,482 --> 00:59:15,083
任何东西都可以在这里，任何结构，任何类，任何类型。

1131
00:59:15,152 --> 00:59:17,652
所以这是非常非Swift强烈

1132
00:59:17,721 --> 00:59:20,621
键入，这里没有类型。所以

1133
00:59:20,690 --> 00:59:24,792
在Swift中你永远不会有这样的API。好的，

1134
00:59:24,861 --> 00:59:27,295
如果这不是Objective-C API提出的，那么

1135
00:59:27,364 --> 00:59:28,396
你永远不会拥有它。

1136
00:59:28,465 --> 00:59:30,232
任何人都可以想到我们会有什么，而不是

1137
00:59:30,300 --> 00:59:33,268
那里有吗？为什么要选择什么类型的东西？

1138
00:59:35,472 --> 00:59:39,808
如何与关联值的枚举？对？

1139
00:59:39,877 --> 00:59:43,077
如果你有一个枚举，其中一个枚举的东西是字体，

1140
00:59:43,146 --> 00:59:45,113
那么关联的值可能是一个字体。

1141
00:59:45,182 --> 00:59:47,815
或者如果事情是文本的颜色呢？

1142
00:59:47,884 --> 00:59:49,050
那么相关的价值可能

1143
00:59:49,119 --> 00:59:51,553
是一个用户界面的颜色，你看？我们如何在Swift中做到这一点？好，

1144
00:59:51,621 --> 00:59:54,723
当Objective-C这样做时，我们没有那些枚举，

1145
00:59:54,792 --> 00:59:56,657
我们坚持任何。好的？

1146
00:59:56,726 --> 01:00:00,895
切勿在数据结构中使用任何数据结构任何一个都是纯粹的

1147
01:00:00,964 --> 01:00:05,567
我们可以处理这些旧的Objective-C的东西。好的，

1148
01:00:05,635 --> 01:00:08,870
所以，现在我已经声明这个类型是一个字典

1149
01:00:08,939 --> 01:00:12,874
用Any作为值的NSAttributeString键，然后我

1150
01:00:12,943 --> 01:00:16,511
可以使我的字典，所以StrokeColor显然

1151
01:00:16,579 --> 01:00:19,648
它触及文本的外部的颜色。

1152
01:00:19,716 --> 01:00:22,050
还有前景色是它所放的颜色

1153
01:00:22,119 --> 01:00:25,921
文本的内部，填充颜色。还有

1154
01:00:25,989 --> 01:00:28,756
背景颜色，就像你有一个荧光笔，

1155
01:00:28,825 --> 01:00:32,059
这是它的背景。还有StrokeWidth。

1156
01:00:32,128 --> 01:00:33,961
StrokeWidth，如果它是一个正数，

1157
01:00:34,030 --> 01:00:38,867
它概述。好的？如果这是一个负数，它的坚实。

1158
01:00:38,936 --> 01:00:41,870
人物是坚实的。好的？你会看到的。本来打算

1159
01:00:41,939 --> 01:00:44,505
做一个演示。好的？所以你可以做到这一点。你可以放

1160
01:00:44,574 --> 01:00:47,142
这些东西在这里作为你的功课。你会用中风，

1161
01:00:47,210 --> 01:00:50,479
颜色中风也许一些其他人。在提示我

1162
01:00:50,547 --> 01:00:52,047
有点告诉你需要使用的东西。

1163
01:00:52,115 --> 01:00:54,515
所以，我不希望你浪费太多的时间查找所有的东西

1164
01:00:54,584 --> 01:00:57,652
这些东西。然后你可以创建一个属性字符串

1165
01:00:57,721 --> 01:01:00,822
与该字典的所有字符串中的字符串

1166
01:01:00,891 --> 01:01:03,491
只是说使用初始化的NSAttributedString

1167
01:01:03,560 --> 01:01:07,028
字符串的文本和属性。所以创造

1168
01:01:07,097 --> 01:01:09,430
一个归属字符串，然后我可以把这个归因于

1169
01:01:09,499 --> 01:01:12,901
字符串，并把它放在我的flipCountLabel，对不对？

1170
01:01:12,969 --> 01:01:15,470
现在我的flipCountLabel，所以这个特殊的，因为我

1171
01:01:15,539 --> 01:01:19,107
使用正笔画宽度，这将是概述文本。

1172
01:01:19,175 --> 01:01:20,708
在我的翻转计数。所以我会做一个演示和

1173
01:01:20,777 --> 01:01:23,277
看看在这里看起来像什么。

1174
01:01:23,346 --> 01:01:25,380
我只想简单地谈一谈这个特性

1175
01:01:25,449 --> 01:01:27,716
NSAttributed字符串，因为有一个NS。

1176
01:01:27,784 --> 01:01:29,551
你知道，你看到NS在一开始就知道，

1177
01:01:29,619 --> 01:01:32,654
嗯，这是一个较旧的API。

1178
01:01:32,722 --> 01:01:36,124
这不是一个字符串。这是完全不同的事情，好吧。

1179
01:01:36,192 --> 01:01:37,992
一个NSAttributedString是一个完全的类

1180
01:01:38,061 --> 01:01:41,796
不同。然后String完全不同。

1181
01:01:41,864 --> 01:01:44,332
因为它是类不是一个结构体，

1182
01:01:44,401 --> 01:01:47,468
你不能通过使用var来制作一个可变的。

1183
01:01:47,537 --> 01:01:49,670
你实际上必须使用不同的课程。

1184
01:01:49,739 --> 01:01:52,074
它是可变的Attribut字符串。如果你真的

1185
01:01:52,142 --> 01:01:54,342
想要确定字典

1186
01:01:54,410 --> 01:01:57,345
字符，你将需要使用可变的

1187
01:01:57,414 --> 01:02:00,048
Attributable String是一个完全不同的类

1188
01:02:00,116 --> 01:02:03,151
那里。另外NSAttributedString是建立和

1189
01:02:03,220 --> 01:02:07,088
在内部用NSString构建。 NSString是

1190
01:02:07,157 --> 01:02:10,892
旧的Objective-C字符串。 NSString和String有

1191
01:02:10,961 --> 01:02:14,262
下面有一些不同的Unicode和编码。所以，

1192
01:02:14,331 --> 01:02:18,032
当你有古怪的字符，如表情符号或咖啡厅在那里，

1193
01:02:18,101 --> 01:02:21,703
进入他们的索引可能不太匹配。和

1194
01:02:21,771 --> 01:02:24,873
有字符串和NSString之间的自动桥接

1195
01:02:24,942 --> 01:02:27,175
如果你有任何需要NSString的iOS API

1196
01:02:27,243 --> 01:02:29,477
作为一个参数，你可以传递一个字符串。

1197
01:02:29,546 --> 01:02:32,114
它只是自动工作。

1198
01:02:32,182 --> 01:02:34,415
这个小编码并不总是得到

1199
01:02:34,484 --> 01:02:39,020
修好了，所以这里的底线是如果你是

1200
01:02:39,089 --> 01:02:42,057
将试图成为一个NSAttibutedString和索引

1201
01:02:42,125 --> 01:02:46,194
你有古怪的字符，如表情符号或咖啡馆，索引

1202
01:02:46,263 --> 01:02:49,330
可能排队不好。现在在你的作业中，你没有

1203
01:02:49,399 --> 01:02:50,932
不得不担心，因为我只会问

1204
01:02:51,001 --> 01:02:53,868
你让整个String都有属性。所以

1205
01:02:53,937 --> 01:02:56,538
你甚至没有做任何索引到那里。

1206
01:02:56,606 --> 01:02:58,873
但是在将来，如果你曾经使用过AttributedString，

1207
01:02:58,941 --> 01:02:59,674
只是要小心

1208
01:02:59,743 --> 01:03:02,043
那里有索引，如果你有古怪的字符。

1209
01:03:02,112 --> 01:03:07,282
好的，演示所以，我会做这个倒计数

1210
01:03:07,350 --> 01:03:11,353
事情，并告诉你在这里看起来像真正的快速。

1211
01:03:13,023 --> 01:03:14,555
我们在哪里做？这就对了，

1212
01:03:14,624 --> 01:03:17,091
对？以下是我们将flipCountLabel设置为Flip的位置：

1213
01:03:17,160 --> 01:03:19,794
\（flipCount）。所以我会把归因的文字放在那里所以

1214
01:03:19,863 --> 01:03:22,430
我要让我的属性，我必须

1215
01:03:22,498 --> 01:03:29,671
类型为[NSAttributedStringKey：

1216
01:03:29,740 --> 01:03:34,642
任何] =。现在我可以把我想要的东西，所以

1217
01:03:34,711 --> 01:03:40,415
我想StrokeWidth为5.0。

1218
01:03:40,483 --> 01:03:44,552
好吧，这是一个相当厚的抚摸宽度。

1219
01:03:44,621 --> 01:03:47,055
然后，我说我想要的另外一件事，哦，

1220
01:03:47,124 --> 01:03:50,692
颜色。所以strokeColor和我会继续前进

1221
01:03:50,761 --> 01:03:54,195
使用这里的颜色文字。用我们最喜欢的颜色，

1222
01:03:54,264 --> 01:03:59,000
这是橙色的。万圣节颜色。好的，

1223
01:03:59,069 --> 01:04:02,403
所以现在如果我想使用这些属性来绘制文本

1224
01:04:02,472 --> 01:04:05,039
我的标签，我只是要创建一个attributesString。

1225
01:04:05,108 --> 01:04:08,710
所以我会说，让String等于。通过

1226
01:04:08,778 --> 01:04:11,412
用它的构造函数创建一个属性字符串，

1227
01:04:11,481 --> 01:04:13,414
我想要在这里的底部。

1228
01:04:13,483 --> 01:04:15,816
它需要属性和字符串。可以，然后呢

1229
01:04:15,885 --> 01:04:18,352
你要做什么你的家庭作业-2。我把字符串，

1230
01:04:18,421 --> 01:04:22,356
这就是这个字符串。和

1231
01:04:22,425 --> 01:04:26,627
属性是我刚刚在那里创建的这些属性。和

1232
01:04:26,696 --> 01:04:29,564
那么不要说flipCountLabel.text，

1233
01:04:29,633 --> 01:04:33,335
我说归属文本。而对于一个按钮，你会说设置

1234
01:04:33,403 --> 01:04:36,838
归因于状态而不是setTitle

1235
01:04:36,906 --> 01:04:40,141
状态，并等于这个归属的String。

1236
01:04:40,209 --> 01:04:43,945
好吧，这就是你需要做的。所以让我们运行这个和

1237
01:04:44,013 --> 01:04:46,581
我们会看到一些有点奇怪的东西

1238
01:04:46,650 --> 01:04:51,052
这个，虽然。有点意外，我想。

1239
01:04:51,121 --> 01:04:54,522
所以我们走了嘿，它没有画任何不同的东西。

1240
01:04:54,591 --> 01:04:55,823
看看，翻转：0。

1241
01:04:55,892 --> 01:04:58,893
这看起来和我们做这个改变之前一模一样。

1242
01:04:58,962 --> 01:05:03,497
但是，哦，看，如果我点击，现在我正在获取轮廓字体。

1243
01:05:03,566 --> 01:05:05,833
看看它是如何概述我的翻转？

1244
01:05:05,902 --> 01:05:10,338
那么为什么一开始就没有这个工作，在这里呢？

1245
01:05:12,709 --> 01:05:15,843
是啊，因为在这里，这个小= 0，

1246
01:05:15,912 --> 01:05:19,414
这个初始化，那不会导致didSet

1247
01:05:19,483 --> 01:05:22,650
发生。好的，所以这是一个重要的事情要知道。

1248
01:05:22,718 --> 01:05:26,554
当你初始化一个var时，它不会调用didSet，

1249
01:05:26,623 --> 01:05:30,525
只有后来的flipCount设置。所以

1250
01:05:30,593 --> 01:05:32,693
我们如何解决这个问题？好吧，我要把这个和

1251
01:05:32,762 --> 01:05:37,265
把它放在它自己的小功能。好吧，私人func，

1252
01:05:37,334 --> 01:05:43,471
我会把它叫做updateFlipCountLabel。

1253
01:05:43,540 --> 01:05:45,006
我会把它放在那里

1254
01:05:45,074 --> 01:05:47,441
我要在这里调用这个updateFlipCountLabel。

1255
01:05:47,510 --> 01:05:49,176
updateFlipCountLabel和

1256
01:05:49,245 --> 01:05:52,814
哪里需要更新FlipCountLabel？

1257
01:05:52,882 --> 01:05:56,217
那么，还有一件事是要学习的，那就太酷了。

1258
01:05:56,286 --> 01:05:58,653
这就在这里，是标签，对吧？

1259
01:05:58,721 --> 01:06:03,991
如果你还记得我们在这里的UI，那这个就在这里

1260
01:06:04,060 --> 01:06:09,330
连接到那，对，它连接。现在，

1261
01:06:09,399 --> 01:06:12,767
当你启动你的用户界面的时候，这个连接是由iOS进行的，

1262
01:06:12,836 --> 01:06:14,869
正确的，它使这种联系。

1263
01:06:14,938 --> 01:06:19,473
那么，当它连接，它是设置这个。

1264
01:06:19,542 --> 01:06:24,745
所以猜猜看，我们可以在这里使用didSet。

1265
01:06:24,814 --> 01:06:26,648
当你有一个插座，

1266
01:06:26,716 --> 01:06:30,885
doSet在iOS设置的时候会被调用，

1267
01:06:30,954 --> 01:06:34,955
当这个连接在这里得到时，就会得到

1268
01:06:35,024 --> 01:06:39,693
调用。所以在这里我们可以在这里更新我们的flipCountLabel。好的，

1269
01:06:39,762 --> 01:06:43,697
所以现在flipCountLabel会在我们第一时间被更新

1270
01:06:43,766 --> 01:06:47,268
连接那个翻转零，也每次我们改变它

1271
01:06:47,337 --> 01:06:52,974
之后。得到它了？好的，回到我们的幻灯片。所以，

1272
01:06:53,043 --> 01:06:55,843
你在那里学到了两件事，对吧？你了解到了

1273
01:06:55,912 --> 01:06:59,280
等于零并没有导致没有发生，你了解到

1274
01:06:59,348 --> 01:07:02,449
在一个outlet上，你可以设置。你可以设置的东西，因为

1275
01:07:02,518 --> 01:07:04,652
那个出口刚刚被你吸引住了。

1276
01:07:04,721 --> 01:07:08,022
好的，这里真的很重要。我们需要

1277
01:07:08,090 --> 01:07:09,724
真的很急，因为我们已经没时间了。

1278
01:07:09,792 --> 01:07:12,994
这是非常重要的，这是关于功能的类型。

1279
01:07:13,062 --> 01:07:16,097
所以我相信几年前的最高法院

1280
01:07:16,165 --> 01:07:19,667
功能也是人。所以功能得到充分

1281
01:07:19,735 --> 01:07:22,236
治疗任何其他类型获得的类型。

1282
01:07:22,305 --> 01:07:25,039
你可以在任何地方使用一个函数，好吗？和

1283
01:07:25,107 --> 01:07:28,009
你只是通过声明一个函数的参数来做到这一点

1284
01:07:28,078 --> 01:07:30,378
var，无论如何，都是类型的函数。

1285
01:07:30,446 --> 01:07:31,645
而你指定的参数和

1286
01:07:31,714 --> 01:07:33,147
该函数的返回值。所以

1287
01:07:33,215 --> 01:07:35,883
这将是一个变量。所以你可以在任何地方这样做

1288
01:07:35,952 --> 01:07:38,853
类型是允许的。我们来看一个例子。我有一个变种

1289
01:07:38,921 --> 01:07:43,390
这里称为操作。它是类型的功能

1290
01:07:43,459 --> 01:07:47,862
一个double并返回一个double。所以这里的语法很棒。

1291
01:07:47,931 --> 01:07:50,999
它看起来就像声明一个需要双倍的函数

1292
01:07:51,067 --> 01:07:54,302
并返回它，只是没有参数的名称，但类型

1293
01:07:54,370 --> 01:07:58,572
都在那里所以这就是你如何声明一个函数。

1294
01:07:58,641 --> 01:08:00,375
你声明一个var是一个函数。

1295
01:08:00,443 --> 01:08:02,911
你可以做变量，传递给函数，

1296
01:08:02,979 --> 01:08:06,113
参数，一切。你总是可以做到这一点。所以

1297
01:08:06,182 --> 01:08:09,917
你可以指定这个var，就像你想的那样。

1298
01:08:09,986 --> 01:08:12,853
我要分配操作= sqrt。好的，

1299
01:08:12,922 --> 01:08:16,724
sqrt是一个函数，它需要一个double并返回一个double。

1300
01:08:16,792 --> 01:08:20,161
所以对我来说，运算= sqrt是完全合法的，

1301
01:08:20,230 --> 01:08:24,198
好吧？我怎样称呼它？好吧，我就这样称呼它

1302
01:08:24,266 --> 01:08:27,969
一个功能。 4.0的操作会调用，在这种情况下，

1303
01:08:28,037 --> 01:08:31,872
平方根为4.0，因为操作是一个函数var，

1304
01:08:31,941 --> 01:08:33,974
这是持有一个运作。

1305
01:08:34,043 --> 01:08:37,144
那个函数是平方根，好吧。不能更简单。

1306
01:08:37,213 --> 01:08:40,114
大家都很酷吗？现在，其他语言有功能

1307
01:08:40,182 --> 01:08:43,017
指针和所有这些东西，但都是非常曲折的

1308
01:08:43,086 --> 01:08:46,020
使用。但在斯威夫特，这是一流的公民，好吧。

1309
01:08:46,089 --> 01:08:47,355
职能是一流的公民。

1310
01:08:47,424 --> 01:08:50,358
他们将成为许多iOS方法的参数，

1311
01:08:50,426 --> 01:08:53,628
功能会。好吧，现在很多时候，

1312
01:08:53,696 --> 01:08:57,665
你想过去的功能还不存在。

1313
01:08:57,734 --> 01:09:00,701
所以强迫你去写一个函数来传入

1314
01:09:00,770 --> 01:09:04,639
例如，假设我有函数changeSign，好的。所以

1315
01:09:04,707 --> 01:09:07,942
没有改变迹象的平方根之类的东西。

1316
01:09:08,010 --> 01:09:10,878
所以我必须在这里写一个非常简单的小函数，

1317
01:09:10,946 --> 01:09:11,896
而所有这一切，需要一倍，并返回一个双，

1318
01:09:11,897 --> 01:09:12,847
changeSign。

1319
01:09:12,915 --> 01:09:15,983
就像平方根一样。它返回减去操作数。

1320
01:09:16,051 --> 01:09:19,020
所以我在这里改变操作符的符号。所以，我可以

1321
01:09:19,088 --> 01:09:21,588
以相同的方式使用它。我有一个手术。我会的

1322
01:09:21,657 --> 01:09:24,358
说操作= changeSign而不是操作= sqrt。

1323
01:09:24,427 --> 01:09:26,527
但是这是很多打字和

1324
01:09:26,596 --> 01:09:29,630
烦恼要去打造一个完整的功能去做

1325
01:09:29,699 --> 01:09:33,300
当所有我想要的是改变签名。

1326
01:09:33,369 --> 01:09:35,703
所以我们可以做，使用所谓的闭包。

1327
01:09:35,772 --> 01:09:37,738
有多少人听到这句话闭包，

1328
01:09:37,807 --> 01:09:39,307
知道闭包是什么？

1329
01:09:39,375 --> 01:09:43,577
好的，大概还有一半。好的，所以封闭是真的

1330
01:09:43,646 --> 01:09:46,580
就像一个内联函数。它有点特别

1331
01:09:46,649 --> 01:09:49,784
捕捉周围的状态，但它本质上是一个内联

1332
01:09:49,852 --> 01:09:52,620
功能。那么，如果我们想要什么语法看起来像

1333
01:09:52,689 --> 01:09:55,522
采取changeSign，并把它放在中间

1334
01:09:55,591 --> 01:09:58,192
这里而不是有一个单独的功能？好的，

1335
01:09:58,261 --> 01:10:00,061
我们怎么做呢？好吧，

1336
01:10:00,130 --> 01:10:02,830
我们只是要拿起所有的changeSign除外

1337
01:10:02,899 --> 01:10:04,365
它的名字，并把它下移。

1338
01:10:04,433 --> 01:10:07,635
看，好吧，所以我把它放在那里。现在我

1339
01:10:07,704 --> 01:10:11,072
这里必须做一个句法变化，非常重要。

1340
01:10:11,141 --> 01:10:14,275
我必须移动第一个大括号，右边一个

1341
01:10:14,344 --> 01:10:17,345
在返回之前。我不得不把它移到开始和

1342
01:10:17,413 --> 01:10:20,948
用它替换它，所以看看这种情况。

1343
01:10:21,017 --> 01:10:24,318
这移动到前面，把这个词。但是，这是它。

1344
01:10:24,387 --> 01:10:27,654
一旦你做了小的语法变化，你可以放弃

1345
01:10:27,723 --> 01:10:31,359
任何功能在那里。但是它变得更好了

1346
01:10:31,427 --> 01:10:35,629
这是因为我们在Swift中有类型推理。和Swift

1347
01:10:35,698 --> 01:10:39,734
因为知道很多，所以绝对可以到这里来

1348
01:10:39,802 --> 01:10:44,138
这里发生了什么。例如，Swift知道这一点

1349
01:10:44,207 --> 01:10:47,775
操作事情返回一个double。它知道，所以

1350
01:10:47,843 --> 01:10:50,645
你不需要说返回double，所以只要拿

1351
01:10:50,713 --> 01:10:54,849
那个。它也知道操作数是double的，所以

1352
01:10:54,918 --> 01:10:58,052
你不需要说那个操作数是double的，

1353
01:10:58,121 --> 01:11:00,454
你可以把它拿出来，对吧？

1354
01:11:00,523 --> 01:11:03,224
它也知道这个函数返回的东西，所以

1355
01:11:03,292 --> 01:11:07,595
那里你不需要关键字return minus操作数。所以

1356
01:11:07,663 --> 01:11:10,698
我们也可以解决这个问题。好的，甚至更多，

1357
01:11:10,766 --> 01:11:13,835
Swift知道你想拥有这些嵌入式功能

1358
01:11:13,903 --> 01:11:16,938
那个时候，想起来有些恼人

1359
01:11:17,006 --> 01:11:19,740
这个东西的参数的名字。好的，那个

1360
01:11:19,808 --> 01:11:23,210
操作数的话，我不得不想在那里。所以它可以让你

1361
01:11:23,279 --> 01:11:27,681
第一个替代$ 0，第二个替换$ 1，第二个替换$ 3

1362
01:11:27,750 --> 01:11:32,920
第三个所以我要用$ 0替换操作数。

1363
01:11:32,988 --> 01:11:35,556
而当我这样做的时候，我也不再需要这个了。

1364
01:11:38,461 --> 01:11:42,096
现在你看到闭包的力量。好的，

1365
01:11:42,165 --> 01:11:45,265
我想要一个改变标志的操作。

1366
01:11:45,334 --> 01:11:47,868
而我几乎不得不输入更多的字符

1367
01:11:47,937 --> 01:11:52,973
changeSign，只是它周围的花括号。就是这样

1368
01:11:53,042 --> 01:11:56,911
还是要做，操作4.0还是要做-4.0。好的，

1369
01:11:56,979 --> 01:11:59,380
所以你会一直在使用闭包

1370
01:11:59,449 --> 01:12:01,949
你将会使用这些$ 0，1，$ 1，$ 2，

1371
01:12:02,017 --> 01:12:04,552
作为参数名称。它会让你这么做

1372
01:12:04,620 --> 01:12:07,187
必须输入非常少的代码来放置这些东西。

1373
01:12:07,256 --> 01:12:09,990
现在我为什么要闭包，为什么我需要功能

1374
01:12:10,059 --> 01:12:12,626
参数呢？那通常是因为你，

1375
01:12:12,695 --> 01:12:15,196
你正在传递一些想知道的函数

1376
01:12:15,264 --> 01:12:18,365
该怎么办。一个函数是告诉它该怎么做的好方法

1377
01:12:18,434 --> 01:12:21,335
做。现在为什么要知道该怎么做？好，

1378
01:12:21,404 --> 01:12:24,638
也许它想知道如果有错误该怎么办。

1379
01:12:24,707 --> 01:12:27,541
我会做点什么，可能会产生一个错误

1380
01:12:27,610 --> 01:12:30,110
我想调用一个函数，以防出现错误

1381
01:12:30,179 --> 01:12:33,080
你可以处理这个功能。也许它想知道该怎么做

1382
01:12:33,149 --> 01:12:35,382
如果要做一些需要很长时间的事情。

1383
01:12:35,451 --> 01:12:37,184
它会在网络上

1384
01:12:37,253 --> 01:12:40,754
在后台下载东西，完成后，

1385
01:12:40,823 --> 01:12:44,525
它想告诉你。好的，我们调用一个函数来做到这一点。

1386
01:12:44,594 --> 01:12:47,060
另一件事是，它可能会反复做一些事情，

1387
01:12:47,129 --> 01:12:49,997
它希望一遍又一遍地做同样的事情。所以这是问

1388
01:12:50,066 --> 01:12:53,100
你要告诉它一遍又一遍地做什么。所以让我们来看看

1389
01:12:53,169 --> 01:12:55,937
以最后一个例子来说，做一些事情

1390
01:12:56,005 --> 01:13:00,074
并结束。所以数组，自然就是一个集合。

1391
01:13:00,143 --> 01:13:04,378
无论如何，数组有一个叫做map的方法。和

1392
01:13:04,447 --> 01:13:08,816
什么地图做，只需要一个参数，一个函数。和

1393
01:13:08,885 --> 01:13:12,586
它将该函数应用于数组中的每个元素

1394
01:13:12,655 --> 01:13:15,088
创建一个新的数组。所以

1395
01:13:15,157 --> 01:13:19,160
map返回一个新的数组，其中数组中的每个元素都是你的

1396
01:13:19,228 --> 01:13:21,995
发送它由一些功能操作。

1397
01:13:22,064 --> 01:13:24,131
换句话说，这是一种将函数传递给数组的方法

1398
01:13:24,200 --> 01:13:26,534
告诉它在每个元素上执行它。好的，

1399
01:13:26,602 --> 01:13:29,370
这是地图的功能，那么这是如何工作的？在这里，我有

1400
01:13:29,439 --> 01:13:32,673
一个浮点数的数组。他们碰巧是

1401
01:13:32,742 --> 01:13:35,910
前5个素数，在这里2,3,5,7,11。

1402
01:13:35,978 --> 01:13:39,714
而如果我想要一个负数2的数组，

1403
01:13:39,782 --> 01:13:43,317
负面的3？那么我只会说negativePrimes =

1404
01:13:43,386 --> 01:13:47,354
prime.map，唯一的参数是一个不会改变的函数

1405
01:13:47,423 --> 01:13:48,989
标志，对吗？就像我们在上一张幻灯片中所看到的那样

1406
01:13:49,058 --> 01:13:51,692
改变标志。现在我们得到一个新的数组，

1407
01:13:51,761 --> 01:13:56,163
negativePrimes将会是一个新的阵列-2，-3，-5。

1408
01:13:56,231 --> 01:13:59,934
你看我在那里用地图吗？现在再列举一个例子，

1409
01:14:00,002 --> 01:14:02,770
也许倒置素数。所以我会去争取

1410
01:14:02,839 --> 01:14:06,507
关闭，1.0除以$ 0。现在我得到0.5,0.33，

1411
01:14:06,575 --> 01:14:09,810
也许我甚至想把它转换成一个字符串。

1412
01:14:09,878 --> 01:14:11,946
完全合法，不一定是相同的类型。

1413
01:14:12,015 --> 01:14:15,516
我可以返回字符串数组。现在注意黄色

1414
01:14:15,584 --> 01:14:18,519
在那里的东西，每一行都改变了一点。你看

1415
01:14:18,587 --> 01:14:22,256
第一张地图用括号括起来。下一个

1416
01:14:22,325 --> 01:14:25,025
映射开括号，闭括号，然后闭包。

1417
01:14:25,094 --> 01:14:28,129
第三个地图，没有括号和闭包。

1418
01:14:28,197 --> 01:14:31,632
好的，这是使用什么叫尾随闭包

1419
01:14:31,701 --> 01:14:35,670
语法，好吧，我们几乎总是使用这个。这里的规则是，

1420
01:14:35,738 --> 01:14:39,907
如果任何函数的最后一个参数是闭包，

1421
01:14:39,975 --> 01:14:43,343
你可以移动括号外的闭包

1422
01:14:43,412 --> 01:14:46,981
参数。那么在第二行看到倒置的素数？

1423
01:14:47,049 --> 01:14:50,217
我是如何将封闭物移到外面的？此外，

1424
01:14:50,286 --> 01:14:52,519
如果这是唯一的说法，

1425
01:14:52,588 --> 01:14:54,955
那么你可以完全摆脱括号。

1426
01:14:55,023 --> 01:14:57,991
这是第三行，好的。这只是为了使我们的

1427
01:14:58,060 --> 01:15:00,627
代码看起来不错。所以我们没有外部的括号

1428
01:15:00,696 --> 01:15:03,364
那里我们没有，因为我们有花括号，

1429
01:15:03,433 --> 01:15:05,900
我们不需要那些括号。好的，

1430
01:15:05,968 --> 01:15:10,204
所以你会在iOS中看到一个函数的参数

1431
01:15:10,273 --> 01:15:13,274
是一个函数，它通常是最后一个参数。所以

1432
01:15:13,343 --> 01:15:15,242
如果你愿意，你可以把它移到外面。

1433
01:15:15,311 --> 01:15:16,844
这是可选的，你不需要。

1434
01:15:16,912 --> 01:15:19,079
所有这三个都是完全有效的语法正确

1435
01:15:19,148 --> 01:15:23,417
那里。好吧，另一个很酷的闭包使用，

1436
01:15:23,485 --> 01:15:27,354
属性初始化。如果你有一个属性和

1437
01:15:27,423 --> 01:15:29,356
你想初始化它，但是

1438
01:15:29,425 --> 01:15:32,159
这不像你不能做一件事，对。

1439
01:15:32,227 --> 01:15:35,862
你不能说等于五或等于简单的东西。您

1440
01:15:35,931 --> 01:15:38,432
需要做两到三行代码才能初始化。

1441
01:15:38,501 --> 01:15:42,002
没问题，你可以设置属性等于

1442
01:15:42,071 --> 01:15:45,205
执行一个闭包。现在闭包是自动的

1443
01:15:45,274 --> 01:15:47,675
将成为一个闭包，不采取任何参数和

1444
01:15:47,744 --> 01:15:51,412
返回正确的类型来初始化该属性。

1445
01:15:51,480 --> 01:15:53,347
所以你可以做任何你想要的闭包和

1446
01:15:53,415 --> 01:15:55,182
只是返回一些正确的类型。和

1447
01:15:55,251 --> 01:15:58,652
那么你马上用左括号执行它，关闭

1448
01:15:58,720 --> 01:16:01,522
插入语。看看有多少小括号，

1449
01:16:01,590 --> 01:16:04,625
闭包的最后有没有闭包的括号？

1450
01:16:04,694 --> 01:16:06,761
那就是在那里执行那个闭包。

1451
01:16:06,829 --> 01:16:09,830
这是非常酷的懒惰lazy属性。因为它

1452
01:16:09,898 --> 01:16:12,433
意思是，这个封闭不会被执行，直到有人问

1453
01:16:12,502 --> 01:16:16,036
对于这个属性。可以，然后呢

1454
01:16:16,105 --> 01:16:18,638
你在闭包懒惰结合。所以

1455
01:16:18,707 --> 01:16:22,342
闭包对于初始化属性非常酷。现在，

1456
01:16:22,411 --> 01:16:25,079
关于闭包的一点要小心。

1457
01:16:25,147 --> 01:16:29,483
他们确实抓住了周围的变数。

1458
01:16:29,552 --> 01:16:32,386
所以如果我有一个闭包，这只是一个嵌入式功能

1459
01:16:32,454 --> 01:16:35,156
在我的代码。如果有局部变量，或者

1460
01:16:35,224 --> 01:16:37,958
我在类中的实例变量，或者其他什么，和

1461
01:16:38,027 --> 01:16:42,296
我用它们在闭包它的工作。即使如此

1462
01:16:42,365 --> 01:16:45,966
闭包附近，那些东西还在继续工作

1463
01:16:46,035 --> 01:16:49,936
直到闭包消失。这是什么意思，虽然，

1464
01:16:50,005 --> 01:16:52,306
因为闭包是类型，他们可以把数组和

1465
01:16:52,375 --> 01:16:56,810
字典，闭包是参考类型。

1466
01:16:56,879 --> 01:17:01,014
Swift中只有两个引用类型，classes和

1467
01:17:01,083 --> 01:17:02,683
闭包。那么这是什么意思？

1468
01:17:02,752 --> 01:17:05,285
这意味着如果你把它放进去，那么这个封闭就会堆积起来

1469
01:17:05,354 --> 01:17:08,856
数组。所以这个数组实际上有指向这个

1470
01:17:08,925 --> 01:17:13,327
关闭。现在这是一个小小的弯曲。我不期望

1471
01:17:13,395 --> 01:17:16,330
你在顶部得到这个权利。但这也意味着，

1472
01:17:16,398 --> 01:17:19,934
如果你从你的关闭中捕获变量

1473
01:17:20,002 --> 01:17:22,803
周围的代码，他们也必须活在堆中。

1474
01:17:22,872 --> 01:17:25,505
因为我们不能让这个闭包不起作用，对吗？

1475
01:17:25,574 --> 01:17:28,842
不能，如果这个函数必须是一个执行的函数。

1476
01:17:28,911 --> 01:17:30,644
所以这里是一个例子。

1477
01:17:30,713 --> 01:17:33,848
在这里我有一个名为ltaue的局部变量，

1478
01:17:33,916 --> 01:17:35,382
生活的宇宙和一切，

1479
01:17:35,451 --> 01:17:38,585
我认为这是代表。它被设置为42.好的，

1480
01:17:38,654 --> 01:17:41,822
而我的操作，关闭在那里，说ltul时间$ 0。所以

1481
01:17:41,891 --> 01:17:47,594
那个闭包实际上是在里面使用一个局部变量。

1482
01:17:47,663 --> 01:17:51,264
现在如果我把这个操作放到数组中，会发生什么？好的，

1483
01:17:51,333 --> 01:17:53,700
然后再返回并从数组中取出

1484
01:17:53,769 --> 01:17:56,837
执行它。那么，当它这样做，它仍然需要

1485
01:17:56,905 --> 01:18:00,741
那里。否则，封闭将不会执行。所以

1486
01:18:00,810 --> 01:18:05,079
ltuau，ltuae被捕获到堆中

1487
01:18:05,148 --> 01:18:07,681
呆在那里，直到闭包消失。

1488
01:18:07,749 --> 01:18:10,217
现在，这真棒，这一切都只是神奇的作品。

1489
01:18:10,286 --> 01:18:13,487
除了一种情况，你不必考虑它

1490
01:18:13,555 --> 01:18:15,522
这是一个内存周期。

1491
01:18:15,590 --> 01:18:18,391
这可以创建一个内存循环，因为你可能会捕获

1492
01:18:18,460 --> 01:18:22,696
操作数组所在的类。好吧

1493
01:18:22,764 --> 01:18:26,766
如果你捕获了数组在操作中的类，

1494
01:18:26,835 --> 01:18:31,605
那么这个封闭已经将这个类捕获到了堆中。和

1495
01:18:31,674 --> 01:18:35,275
这个类通过它的数组被捕获

1496
01:18:35,344 --> 01:18:36,877
堆在闭包。所以

1497
01:18:36,946 --> 01:18:38,912
他们通过阵列指向对方，

1498
01:18:38,981 --> 01:18:41,448
你看？他们正在创建一个内存周期，即闭包

1499
01:18:41,517 --> 01:18:43,717
保持类，类保持闭包。

1500
01:18:43,786 --> 01:18:44,584
他们留在堆里，

1501
01:18:44,653 --> 01:18:47,153
他们永远不能离开，直到有人解除闭包

1502
01:18:47,222 --> 01:18:49,156
从这个数组中，例如。所以，

1503
01:18:49,225 --> 01:18:52,592
我们可以打破像这样的封闭循环。我们使用那个东西，

1504
01:18:52,661 --> 01:18:54,995
我上次谈到，unowned。记住，unowned吗？

1505
01:18:55,063 --> 01:18:57,164
当我们谈到weak和strong和unowned，

1506
01:18:57,233 --> 01:18:59,266
我说，我会告诉你什么是unowned的。所以

1507
01:18:59,335 --> 01:19:01,701
我要把这两样东西放在一起unowned和

1508
01:19:01,770 --> 01:19:04,238
我们可以有这些周期的事实。在几个

1509
01:19:04,306 --> 01:19:07,007
星期，我会和你谈谈，我们如何打破这些周期。好的，

1510
01:19:07,076 --> 01:19:09,977
我们如何创建一个不会保留的闭包

1511
01:19:10,046 --> 01:19:14,514
好的，好吧，我们来看一个闭包的演示。

1512
01:19:14,583 --> 01:19:17,851
我要改善这个唯一的脸的方法索引

1513
01:19:17,920 --> 01:19:21,021
卡要好得多。而且我不仅要使用闭包，

1514
01:19:21,090 --> 01:19:23,824
我要回去使用协议的扩展

1515
01:19:23,893 --> 01:19:26,493
我要把这一切联系在一起。可以，然后呢

1516
01:19:26,562 --> 01:19:30,931
让我们这样做。在这里，如果我们记得，

1517
01:19:31,000 --> 01:19:35,102
我们，我们将在这里成为一个大窗口。如果我们走了

1518
01:19:35,171 --> 01:19:37,838
回到我们的专注，好吧，这里的集中。

1519
01:19:37,907 --> 01:19:39,973
请记住，我们有索引的唯一一张面卡，

1520
01:19:40,042 --> 01:19:43,343
其中，据说使我们的代码更简单，

1521
01:19:43,412 --> 01:19:46,213
它在这里下了。它真的做了这个代码

1522
01:19:46,281 --> 01:19:49,716
这里美丽而可读。但是，它实际上增加了

1523
01:19:49,785 --> 01:19:53,754
这里有相当多的代码。但是这是比你更多的代码

1524
01:19:53,822 --> 01:19:56,657
实际上需要找到一个唯一的索引

1525
01:19:56,725 --> 01:20:00,594
面卡，如果你使用一个方法，需要闭包。现在，

1526
01:20:00,663 --> 01:20:03,196
我们要使用的方法，它有点像地图，

1527
01:20:03,265 --> 01:20:07,701
它自己的集合，它被称为过滤器。那么过滤器是什么

1528
01:20:07,769 --> 01:20:10,437
它是否贯穿集合中的每个项目

1529
01:20:10,505 --> 01:20:13,040
执行你提供的功能。过滤器只有一个

1530
01:20:13,108 --> 01:20:16,810
论据。这是一个功能。该函数返回一个布尔值。

1531
01:20:16,878 --> 01:20:20,246
所以它执行该函数与参数是每个

1532
01:20:20,315 --> 01:20:23,751
项目中的集合。如果该函数返回true，

1533
01:20:23,820 --> 01:20:26,253
那么它把它放在一个新的数组，好吧，和

1534
01:20:26,321 --> 01:20:29,089
如果它变成错误的，它不会。所以基本上

1535
01:20:29,158 --> 01:20:32,759
将集合过滤为一个数组，但只有那些

1536
01:20:32,828 --> 01:20:35,195
从函数返回true。看看我在说什么？所以

1537
01:20:35,264 --> 01:20:37,564
这就是为什么它被称为过滤器。过滤收集，

1538
01:20:37,633 --> 01:20:40,100
从那些返回true的数组中取出数组。好，

1539
01:20:40,169 --> 01:20:43,069
这对于这个很好，因为索引只有一张脸和一张脸。

1540
01:20:43,138 --> 01:20:45,639
如何去看看所有的卡片和索引的指标

1541
01:20:45,707 --> 01:20:49,876
只是找到有卡面的指标？所以我只是

1542
01:20:49,945 --> 01:20:52,045
需要一个功能来说明卡片是否正面朝上

1543
01:20:52,114 --> 01:20:56,083
我能行。所以让我们来做。我会让索引，我们会说

1544
01:20:56,152 --> 01:21:01,154
让我把它叫做卡面指数，好吧，

1545
01:21:01,223 --> 01:21:05,325
这将是一个数组。我会让它等于我的卡

1546
01:21:05,394 --> 01:21:09,430
指数。卡指数，什么类型的卡指数，

1547
01:21:09,498 --> 01:21:14,033
有谁记得？哦，我只是告诉你它是什么。

1548
01:21:14,102 --> 01:21:19,039
是的是的？这是int的责任范围。它索引到

1549
01:21:19,108 --> 01:21:24,144
卡阵列。所以我要过滤这些指数

1550
01:21:24,213 --> 01:21:26,913
提供一个功能。这是唯一的参数，所以

1551
01:21:26,982 --> 01:21:28,449
我不需要任何括号或者

1552
01:21:28,517 --> 01:21:31,885
什么，我只是要把它放在后面。这个功能正好

1553
01:21:31,954 --> 01:21:35,622
需要看看指数，看看这是一张面朝上的卡。

1554
01:21:35,691 --> 01:21:39,726
所以这就是卡片索引，我们只会使用$ 0，

1555
01:21:39,794 --> 01:21:44,664
这是一个议论功能，是Faceup。好的，

1556
01:21:44,733 --> 01:21:46,800
所以这是一个布尔函数，在这里。

1557
01:21:46,868 --> 01:21:50,103
这是一个布尔函数，由闭包执行

1558
01:21:50,172 --> 01:21:53,506
在那里返回真的，如果该指数的卡面

1559
01:21:53,575 --> 01:21:56,676
向上。所以，现在我已经创建了这是一个数组，

1560
01:21:56,745 --> 01:21:59,179
这是一个数组索引顺便说一下。

1561
01:21:59,248 --> 01:22:01,948
我们来看看。数组索引。

1562
01:22:02,017 --> 01:22:05,819
这个Array.Index类型记住，我们有String.Index，

1563
01:22:05,887 --> 01:22:09,690
Array.Index是类型别名或只是设置为int。

1564
01:22:09,759 --> 01:22:12,225
这就是为什么数组可以通过int进行索引的原因，

1565
01:22:12,294 --> 01:22:15,595
cuz他们的Array.Index是int。字符串不是这样的。

1566
01:22:15,664 --> 01:22:19,699
String.Index，不幸的是，不是int。可以，然后呢

1567
01:22:19,768 --> 01:22:23,437
这是所有指数的数组。现在，如果这只有

1568
01:22:23,506 --> 01:22:26,639
有一件事，那么我们有一张面朝上的卡。

1569
01:22:26,708 --> 01:22:30,377
我们都同意吗？所以我要回到这里

1570
01:22:30,446 --> 01:22:34,914
如果faceUpCardIndices.count == 1，

1571
01:22:34,983 --> 01:22:41,555
我将返回faceUpCardIndices.first，

1572
01:22:41,623 --> 01:22:44,024
首先是一个返回第一个的集合方法

1573
01:22:44,093 --> 01:22:46,960
在收集的东西。否则，我会回来

1574
01:22:47,029 --> 01:22:49,696
零，因为我们或者没有正视卡或者

1575
01:22:49,765 --> 01:22:52,966
我们有不止一个，无论哪种情况，我们都会返回0。

1576
01:22:53,035 --> 01:22:56,770
所以我不需要这里的任何东西。好的，

1577
01:22:56,839 --> 01:23:00,473
所以这比这整个事情更清洁。

1578
01:23:00,542 --> 01:23:03,310
大家都同意吗？还有一点可读性。

1579
01:23:03,379 --> 01:23:05,979
通过过滤给我所有的脸牌指数

1580
01:23:06,048 --> 01:23:09,216
向我展示那些正面朝上的指标。好的，

1581
01:23:09,285 --> 01:23:11,618
这种读法也好一点，但是

1582
01:23:11,687 --> 01:23:13,586
我们甚至可以做得比这更好。

1583
01:23:13,655 --> 01:23:16,156
我们将通过创建一个扩展来做得更好

1584
01:23:16,224 --> 01:23:20,827
一个协议在这里。我们要扩展的协议是

1585
01:23:20,896 --> 01:23:25,832
采集。所以我们要添加一个var。可能是一个功能，

1586
01:23:25,901 --> 01:23:27,734
但这将是一个集合的变种。

1587
01:23:27,802 --> 01:23:30,437
所以，我将把它添加到字符串，字典，

1588
01:23:30,506 --> 01:23:33,240
数组，所有这些东西。它会做什么，

1589
01:23:33,309 --> 01:23:39,045
这将是唯一的。它会回来

1590
01:23:39,114 --> 01:23:43,216
如果只有唯一的东西在那个集合中

1591
01:23:43,285 --> 01:23:45,953
在集合中的一件事，否则它会返回零。

1592
01:23:46,021 --> 01:23:47,553
现在，什么是类型，

1593
01:23:47,622 --> 01:23:52,325
一个只会是？那么，集合是一个泛型类型。

1594
01:23:52,394 --> 01:23:55,695
它有一个通用的东西作为元素，

1595
01:23:55,764 --> 01:23:59,633
这是那里的东西的类型。所以元素就是这样

1596
01:23:59,701 --> 01:24:03,303
像一个占位符，正确的，在元素的数组中。

1597
01:24:03,371 --> 01:24:06,506
你知道吗？对于泛型类型，它是类型。

1598
01:24:06,575 --> 01:24:08,208
当然，我希望它是可选的。

1599
01:24:08,277 --> 01:24:10,844
因为我只会返回非零，如果有一个和

1600
01:24:10,912 --> 01:24:14,181
在这个集合中只有一个东西，这个字符串，或者

1601
01:24:14,249 --> 01:24:15,682
这个数组，或者这个字典，或者

1602
01:24:15,750 --> 01:24:17,484
这个可数范围。

1603
01:24:17,553 --> 01:24:22,088
这是我可以实现它，看这个。返回计数

1604
01:24:22,157 --> 01:24:27,961
== 1？第一：无。现在我怎么能做到这一点？

1605
01:24:28,029 --> 01:24:32,132
计数是一个收集方法，告诉了多少事情

1606
01:24:32,200 --> 01:24:37,504
在那里。首先是一个收集方法，它返回

1607
01:24:37,572 --> 01:24:41,341
那里的第一件事。所以，因为这些是收集

1608
01:24:41,410 --> 01:24:44,844
方法，我可以使用它们来执行一个集合

1609
01:24:44,913 --> 01:24:50,951
变种。在协议上看到这些扩展的力量。

1610
01:24:51,019 --> 01:24:54,120
现在，字符串，数组，可数范围，

1611
01:24:54,189 --> 01:24:58,525
他们都执行一个和唯一。所以我可以回到这里

1612
01:24:58,593 --> 01:25:05,165
只是返回，返回这个，记住，这是一个数组

1613
01:25:05,234 --> 01:25:09,503
面朝上的牌的指数，点1和只有。

1614
01:25:11,239 --> 01:25:16,743
好的，我甚至不需要这个。好的，甚至更简单。

1615
01:25:16,812 --> 01:25:21,614
顺便说一句，我绝对可以做，让通道

1616
01:25:21,683 --> 01:25:26,286
= hello.oneAndOnly。好的，现在会返回什么？

1617
01:25:26,355 --> 01:25:30,924
什么会等于那里？任何人？

1618
01:25:32,427 --> 01:25:33,493
>>这将是零，

1619
01:25:33,562 --> 01:25:37,330
因为只有一个，只有一个返回

1620
01:25:37,399 --> 01:25:42,769
元素和这个字符串有五个元素。如果我这样做，

1621
01:25:42,838 --> 01:25:47,874
这将返回什么？这将返回h，一个和

1622
01:25:47,943 --> 01:25:52,946
只有在该字符串中的东西。所以我通过了

1623
01:25:53,015 --> 01:25:56,917
扩展集合，该字符串和数组恰好是。

1624
01:25:56,986 --> 01:25:58,451
顺便说一句，这是什么类型的？ CH，

1625
01:25:58,520 --> 01:26:03,557
你觉得它的类型是什么？这是一个可选的字符。

1626
01:26:05,427 --> 01:26:09,429
可选字符，因为字符串的元素是

1627
01:26:09,498 --> 01:26:13,300
字符。而一个字符串是一个字符的集合。但

1628
01:26:13,368 --> 01:26:17,537
如果我点击它，它会说，这是一个String.Element。

1629
01:26:17,606 --> 01:26:21,408
所以就像Array.Index是类型别名是int，

1630
01:26:21,476 --> 01:26:25,212
String.Element是类型别名是字符。

1631
01:26:25,280 --> 01:26:27,814
所以，你必须查看文档才能看到或

1632
01:26:27,883 --> 01:26:28,981
你只需要知道它。

1633
01:26:29,050 --> 01:26:30,984
但是如果你正在做你的Alt点击，我不想要你

1634
01:26:31,053 --> 01:26:32,986
当你看到这不是一个字符时会感到惊讶。

1635
01:26:34,756 --> 01:26:39,326
好的，好的，所以很多事情都是这样的

1636
01:26:39,395 --> 01:26:42,562
这里简短的演示。我们在这里使用了闭包。和

1637
01:26:42,631 --> 01:26:46,767
我们也在这里扩展一个协议来创建这个

1638
01:26:46,835 --> 01:26:49,202
方法在这里。所以希望你能理解这两个。

1639
01:26:49,271 --> 01:26:53,039
如果你不这样做，就用广场，过来问问我

1640
01:26:53,108 --> 01:26:57,811
随你。好的，下次再见。哦，

1641
01:26:57,880 --> 01:26:59,212
等等，抱歉一件事，让我回去

1642
01:26:59,281 --> 01:27:02,182
只是告诉你即将到来。因为有一件事

1643
01:27:02,251 --> 01:27:05,852
注意这里关于即将到来。那是星期五，

1644
01:27:05,921 --> 01:27:08,088
我们将有可选部分

1645
01:27:08,156 --> 01:27:10,991
对象的持久性，我们不会在这个星期五这样做。

1646
01:27:11,060 --> 01:27:12,125
我们将在未来的星期五做，

1647
01:27:12,194 --> 01:27:14,060
我们会坚持反对，但是在未来的星期五。

1648
01:27:14,129 --> 01:27:17,197
所以本周没有星期五的部分。下周，

1649
01:27:17,265 --> 01:27:19,666
我会做意见，手势，多点触摸，

1650
01:27:19,735 --> 01:27:24,270
多个MVC，所有这一切。 >>更多信息，

1651
01:27:24,339 --> 01:27:26,907
请访问Stanford.edu。

