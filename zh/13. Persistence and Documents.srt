1
00:00:00,401 --> 00:00:04,636
[音乐]

2
00:00:04,705 --> 00:00:09,174
>>斯坦福大学。 >>好的，欢迎来到

3
00:00:09,242 --> 00:00:13,245
2017年秋季斯坦福CS193P秋季讲座13

4
00:00:13,314 --> 00:00:16,014
18.所以我们今天有一个演示，我真的很友善

5
00:00:16,082 --> 00:00:18,316
压缩它ciz我真的需要去幻灯片，

6
00:00:18,385 --> 00:00:21,753
非常重要的是坚持不懈的话题。所以

7
00:00:21,822 --> 00:00:23,155
让我直接进入该演示，

8
00:00:23,224 --> 00:00:25,257
然后我们会在那之后坚持下去。

9
00:00:25,326 --> 00:00:28,460
所以这里的演示是我要把我们的表情符号艺术和

10
00:00:28,528 --> 00:00:31,597
添加一些方法来显示文本字段

11
00:00:31,665 --> 00:00:36,201
在我们的小集合视图中滑动，所以

12
00:00:36,270 --> 00:00:40,672
我们可以添加更多的表情符号到那个小滑动的东西。所以

13
00:00:40,741 --> 00:00:44,209
我们该怎么做？那么为了让这个更快，

14
00:00:44,278 --> 00:00:47,145
这是我们上一次离开时的表情符号。但

15
00:00:47,213 --> 00:00:50,115
我在这里做了一些小改动。我已经加了两个

16
00:00:50,184 --> 00:00:51,683
集合视图单元格。你在这里看到他们，

17
00:00:51,751 --> 00:00:53,919
这个带有加号按钮。这只是一个UI按钮，

18
00:00:53,988 --> 00:00:56,755
在这里，然后这个有一个UI文本字段。

19
00:00:56,824 --> 00:00:57,756
这就是这一点，

20
00:00:57,824 --> 00:00:59,757
我不知道你是否能看到那里的浅灰色，但是

21
00:00:59,826 --> 00:01:00,993
这是里面的文本字段。

22
00:01:01,061 --> 00:01:04,029
这是这些新单元格中的唯一一个单元

23
00:01:04,097 --> 00:01:06,264
当然，我给了它一个标识符。

24
00:01:06,333 --> 00:01:08,567
这个叫做AddEmojiButtonCell，

25
00:01:08,636 --> 00:01:13,471
这个被称为EmojiInputCell。

26
00:01:13,540 --> 00:01:16,574
这个单元格只是一个标准的UI集合视图单元格。

27
00:01:16,643 --> 00:01:20,078
所以如果我在这里看，你可以看到它的类是

28
00:01:20,146 --> 00:01:23,415
只是UI集合视图单元格。但这是一个特殊的

29
00:01:23,483 --> 00:01:26,985
文本字段集合视图单元格。收集的一个子类

30
00:01:27,054 --> 00:01:29,721
查看处理该文本字段的单元格。

31
00:01:29,790 --> 00:01:31,656
所以我们要去看看这个代码

32
00:01:31,725 --> 00:01:34,726
实际上添加了一点额外的代码，因为我想要的

33
00:01:34,795 --> 00:01:38,230
向你展示一种更棘手的方式去做事情。

34
00:01:38,298 --> 00:01:40,765
这并不棘手，但这是一个非常有价值的方式，

35
00:01:40,834 --> 00:01:42,234
这有点高级，所以

36
00:01:42,303 --> 00:01:45,537
我想确保你学到这一点。好，如此

37
00:01:45,606 --> 00:01:48,740
我有这两个新的单元格。我们来看看这段代码

38
00:01:48,809 --> 00:01:52,844
对于文本字段，集合视图单元格，就在这里，

39
00:01:52,913 --> 00:01:55,580
这是一个非常非常简单的单元，它只是一个outlet

40
00:01:55,649 --> 00:01:57,649
到你在那里看到的文本字段。

41
00:01:57,717 --> 00:01:59,184
现在注意当我的outlet被设置，

42
00:01:59,252 --> 00:02:02,153
我立即将该代表的代表设置给我，我，

43
00:02:02,222 --> 00:02:04,723
我。而我是一个UITextFieldDelegate。

44
00:02:04,791 --> 00:02:07,192
好的，记得上次幻灯片。和

45
00:02:07,260 --> 00:02:09,694
所以我只在这里实现了一个委托方法

46
00:02:09,763 --> 00:02:12,397
textfieldShouldReturn和它做什么，当你按下

47
00:02:12,466 --> 00:02:15,367
键盘上的返回键，它首先退出

48
00:02:15,435 --> 00:02:17,368
响应者，这意味着它停止使用键盘。和

49
00:02:17,437 --> 00:02:20,138
键盘消失。所以如果你不做这件小事

50
00:02:20,206 --> 00:02:21,873
在这里，然后当你按下键盘上的Return键时，

51
00:02:21,942 --> 00:02:24,242
键盘保持不动。好的，光标不断闪烁。

52
00:02:24,311 --> 00:02:26,478
这导致它消失。

53
00:02:26,547 --> 00:02:27,846
我们会再添加一个

54
00:02:27,915 --> 00:02:32,283
在这里一秒钟精巧的方法。所以现在，

55
00:02:32,352 --> 00:02:34,318
记得我在这里有两个单元格，对吧？

56
00:02:34,387 --> 00:02:38,290
表情符号按钮之一，然后在那里输入单元格。所以

57
00:02:38,358 --> 00:02:40,892
现在，让我们回到我们的表情艺术控制器代码和

58
00:02:40,961 --> 00:02:44,563
看看我如何处理这个，我怎么把它放在UI中。

59
00:02:44,631 --> 00:02:47,532
那么，首先那个小加号按钮，

60
00:02:47,601 --> 00:02:50,702
它使用目标操作将此消息发送给我的控制器。

61
00:02:50,771 --> 00:02:52,671
现在注意它将它直接发送给控制器。

62
00:02:52,740 --> 00:02:54,472
如果我有多个加号按钮，

63
00:02:54,541 --> 00:02:56,241
他们都会发送这条消息。

64
00:02:56,309 --> 00:02:59,911
幸运的是，我只有一个，这非常好。

65
00:02:59,980 --> 00:03:02,647
请记住，如果我们有一些东西，很多时候

66
00:03:02,716 --> 00:03:03,982
在局表视图中的一个集合

67
00:03:04,051 --> 00:03:04,849
它发送目标行动，

68
00:03:04,918 --> 00:03:07,719
我们已经将它发送到一个自定义单元格了，对吧？因为我们想要

69
00:03:07,788 --> 00:03:10,755
每个人都会收到一件特别的东西，但是，在这里我们可以拥有

70
00:03:10,824 --> 00:03:13,758
事情通过控制器发送。现在所有这一切

71
00:03:13,827 --> 00:03:17,829
那个加号按钮的作用就是它把这个添加到表情符号上。

72
00:03:17,898 --> 00:03:20,865
因为我们在按下后正在添加表情符号

73
00:03:20,934 --> 00:03:24,002
那个按钮。然后它重新加载部分零。

74
00:03:24,071 --> 00:03:27,105
现在我已经决定，我要把那个加号按钮和

75
00:03:27,173 --> 00:03:29,841
文本字段名称与全部不同

76
00:03:29,910 --> 00:03:32,144
其余的部分。记住集合视图，如表视图，

77
00:03:32,212 --> 00:03:33,244
他们有部分，所以

78
00:03:33,313 --> 00:03:35,413
我要让第零部分成为加号按钮或

79
00:03:35,482 --> 00:03:38,049
文本字段，取决于我是否在添加Emoji

80
00:03:38,118 --> 00:03:40,885
时间，然后第一部分将是我的。

81
00:03:40,954 --> 00:03:43,855
表情符号，因为我今天习惯了。那么我们如何实现呢？

82
00:03:43,924 --> 00:03:46,357
那么，我们不得不说我们现在有两个部分，

83
00:03:46,426 --> 00:03:49,327
而不只是一个部分。当我们拿到号码时

84
00:03:49,396 --> 00:03:50,729
在这里的一节中的项目，

85
00:03:50,797 --> 00:03:53,665
我们必须看看该部分，看看它是否是第0部分，

86
00:03:53,733 --> 00:03:56,634
那么我们有1，无论是加号按钮或文本字段，

87
00:03:56,703 --> 00:03:59,070
或者如果是我们的旧版本，我们有emojis的数量，

88
00:03:59,139 --> 00:04:01,940
我们曾经有过的所有那些表情符号

89
00:04:02,009 --> 00:04:05,143
穿过。然后我们必须改变我们的单元格在项目。

90
00:04:05,212 --> 00:04:07,645
这是为特定事物获取单元格的东西。

91
00:04:07,714 --> 00:04:09,213
所以看看这个部分。所以

92
00:04:09,282 --> 00:04:12,650
这是这个代码用来看起来像什么，我只是把它放进去

93
00:04:12,719 --> 00:04:16,221
如果该部分是一个，然后做我们以前做的事情。

94
00:04:16,290 --> 00:04:19,291
否则，如果该部分为零，那么如果我添加

95
00:04:19,359 --> 00:04:22,393
表情符号，我会把那个文本字段放在那里。和

96
00:04:22,462 --> 00:04:26,064
如果我不添加表情符号，我会把按钮放在那里。

97
00:04:26,132 --> 00:04:27,515
文本字段将会交换地点对吗？

98
00:04:27,516 --> 00:04:28,899
所以按钮和

99
00:04:28,969 --> 00:04:31,002
你按下按钮，它会改变和

100
00:04:31,070 --> 00:04:33,304
切换到文本字段，因为我要设置它

101
00:04:33,373 --> 00:04:36,407
将emoji添加到true，然后我将重新加载我的部分。

102
00:04:36,476 --> 00:04:39,110
这将导致所有这一切再次被调用

103
00:04:39,179 --> 00:04:41,879
它会来回切换。所以我必须要

104
00:04:41,948 --> 00:04:46,184
当我切换到文本字段时，在这里放置一些代码

105
00:04:46,252 --> 00:04:48,553
把文本拿出来，我们会谈论这个。但

106
00:04:48,621 --> 00:04:50,855
在此之前，让我告诉你我做过的其他事情。

107
00:04:50,924 --> 00:04:53,758
一个是我想要的文本字段，当它在那里，非常

108
00:04:53,827 --> 00:04:57,662
宽。我不希望它像所有其他单元格一样微小。

109
00:04:57,731 --> 00:04:59,063
我希望它是一个很宽的小区，所以

110
00:04:59,132 --> 00:05:02,066
我在这里覆盖了这个方法。集合视图布局方法

111
00:05:02,135 --> 00:05:05,369
称为索引路径项目的大小。

112
00:05:05,438 --> 00:05:08,673
并且您返回该路径上某个项目的大小。好，

113
00:05:08,742 --> 00:05:12,043
如果我添加表情符号，而我们正在谈论第零部分，

114
00:05:12,112 --> 00:05:14,413
那么我会选择宽按钮，否则，

115
00:05:14,481 --> 00:05:17,181
我正在做我以前的标准尺寸，是的，

116
00:05:17,250 --> 00:05:19,850
这些是蓝色的数字，他们不应该在这里。我应该

117
00:05:19,919 --> 00:05:23,321
根据用户字体大小来计算

118
00:05:23,390 --> 00:05:26,024
选择和可访问滑块，所有这些，但我们不

119
00:05:26,093 --> 00:05:29,227
有所有的时间，所以我在这里使用蓝色的数字。和

120
00:05:29,296 --> 00:05:32,730
那么我在这里覆盖的另一个是显示单元格。

121
00:05:32,799 --> 00:05:34,398
这是另一个很酷的小委托方法

122
00:05:34,467 --> 00:05:35,500
在集合视图中。

123
00:05:35,569 --> 00:05:37,602
这是在它显示一个单元格之前调用的。

124
00:05:37,671 --> 00:05:40,771
在这里，我所做的是，如果我显示输入单元格，

125
00:05:40,840 --> 00:05:43,307
那个小文本字段之一，我让它成为第一个

126
00:05:43,376 --> 00:05:46,244
响应者。这样当文本字段出现时，

127
00:05:46,313 --> 00:05:50,481
键盘出现。看看我为什么这么做？所以

128
00:05:50,550 --> 00:05:53,652
将显示单元格。你觉得另一个有趣的集合？

129
00:05:53,720 --> 00:05:55,620
我只需要做另外几件小事。

130
00:05:55,689 --> 00:05:59,624
如果我们正在编辑表情符号，我禁用了拖动功能。

131
00:05:59,693 --> 00:06:02,827
如果我们正在输入新的表情符号，我不会让拖动发生

132
00:06:02,896 --> 00:06:05,096
因为它只是弄虚作假

133
00:06:05,165 --> 00:06:07,465
尝试在同一时间交换事物。

134
00:06:07,534 --> 00:06:10,034
我们正在添加东西，所以我把它从那里拿出来了。

135
00:06:10,103 --> 00:06:16,374
我也不允许丢弃，我的代码在哪里呢？

136
00:06:16,443 --> 00:06:20,211
DropProposal，那是哪里？我在这里找不到任何东西，

137
00:06:20,280 --> 00:06:24,715
这里是。所以我不允许你重新定位

138
00:06:24,784 --> 00:06:27,619
收集物品，正确，小表情符号。

139
00:06:27,688 --> 00:06:31,022
我不允许将它放入第0部分。这就是其中的原因

140
00:06:31,091 --> 00:06:33,825
加号按钮是。我不想放弃笑脸

141
00:06:33,893 --> 00:06:37,395
将自行车放入加号按钮所在的位置。所以

142
00:06:37,464 --> 00:06:39,964
我只是在这里说，如果索引路径

143
00:06:40,033 --> 00:06:43,534
是第一部分，那么我会做这件事，我会复制或

144
00:06:43,603 --> 00:06:46,671
移动表情符号。否则，我会说这个放弃建议是

145
00:06:46,739 --> 00:06:49,541
取消了，这意味着我不能在那里下降。大家

146
00:06:49,609 --> 00:06:52,410
那很酷？这就是我所做的所有代码。现在，

147
00:06:52,479 --> 00:06:55,347
最后一件事，让我们来看看这里看起来像什么。

148
00:06:57,250 --> 00:07:01,753
这是我们的用户界面。所以，这是我们所能做到的

149
00:07:01,821 --> 00:07:04,523
移动东西。左侧有加号按钮。

150
00:07:05,792 --> 00:07:08,793
哎呀。如果我按下加号按钮，就会看到它

151
00:07:08,862 --> 00:07:13,097
替换为文本字段。我可以提出我的

152
00:07:13,166 --> 00:07:16,968
键盘在这里，并开始输入，一些，我不知道，

153
00:07:17,036 --> 00:07:19,904
我们在这里得到什么鞋子和帽子和东西。

154
00:07:19,973 --> 00:07:23,240
然后输入这些东西。现在如果我按回车键，

155
00:07:23,309 --> 00:07:25,944
我的键盘要走了，因为我实现了那个

156
00:07:26,013 --> 00:07:28,879
文本委托方法。看看它如何消失？但是

157
00:07:28,948 --> 00:07:31,382
不添加表情符号，因为我没有放任何代码

158
00:07:31,451 --> 00:07:34,219
在这里，实际上需要我在那里输入的内容。和

159
00:07:34,287 --> 00:07:39,657
将其添加到我的滚动列表中。那么我该怎么做？

160
00:07:39,726 --> 00:07:42,393
那就是诀窍。我们去看看。

161
00:07:42,462 --> 00:07:46,297
我们希望在这里的文字领域，

162
00:07:46,366 --> 00:07:50,435
当文本字段辞职是第一响应者时，

163
00:07:50,503 --> 00:07:53,071
当它停止显示文本字段。然后我们想要

164
00:07:53,139 --> 00:07:55,106
把它放进去。所以我们当然会用这个

165
00:07:56,843 --> 00:08:02,080
我谈到的叫做TextFieldDidEndEditing的委托方法。

166
00:08:02,149 --> 00:08:07,318
编辑，编辑。它是。当这发生时，

167
00:08:07,387 --> 00:08:10,154
我想回到我的集合视图基本和

168
00:08:10,223 --> 00:08:13,691
说添加我的文本字段中的表情符号。但

169
00:08:13,760 --> 00:08:16,995
我该如何回到我的集合视图？

170
00:08:17,063 --> 00:08:19,497
集合视图单元格没有真正的指针

171
00:08:19,565 --> 00:08:21,199
他们的集合视图。

172
00:08:21,268 --> 00:08:23,668
所以，这是一个有趣的问题要解决，而且

173
00:08:23,737 --> 00:08:25,537
我实际上会解决它。很多人会解决它

174
00:08:25,605 --> 00:08:27,772
试图在这里找到收藏品

175
00:08:27,841 --> 00:08:29,574
跟它谈话或类似的事情。但

176
00:08:29,643 --> 00:08:33,277
实际上一个更简单的方法来做到这一点闭包。所以

177
00:08:33,346 --> 00:08:38,049
我在名为辞职的单元格中创建了一个var，public var

178
00:08:38,117 --> 00:08:42,120
处理程序。这只是一个闭包，一个功能

179
00:08:42,188 --> 00:08:44,455
它不接受任何参数并且不返回任何参数。

180
00:08:44,524 --> 00:08:48,460
事实上，我甚至会把它作为一个可选功能

181
00:08:48,528 --> 00:08:51,296
它可以是无用的，不必设置。

182
00:08:51,364 --> 00:08:53,831
当文本字段编辑发生时，我只是会去

183
00:08:53,900 --> 00:08:57,601
称这个事情，辞职处理程序。可能没有

184
00:08:57,670 --> 00:09:00,605
我会选择链接它并调用它。所以我只是在调用

185
00:09:00,674 --> 00:09:04,709
该功能。现在，任何有兴趣的人，当我的文字

186
00:09:04,778 --> 00:09:08,280
领域辞职可以设置此闭包的东西。和

187
00:09:08,348 --> 00:09:10,849
这正是我们要回到这里的原因

188
00:09:10,917 --> 00:09:14,886
在我们的控制器。我们加载我们的单元格的地方，

189
00:09:14,955 --> 00:09:17,888
这就在这里。如果我们正在制作表情符号输入单元，

190
00:09:17,957 --> 00:09:19,490
这是与文本填充的东西。

191
00:09:19,559 --> 00:09:23,962
我只是想说如果我可以让输入单元等于这个单元格

192
00:09:24,030 --> 00:09:28,632
作为文本字段集合单元格，这是集合视图

193
00:09:28,701 --> 00:09:33,171
这个单元格就是那个有文本字段的单元格。

194
00:09:33,239 --> 00:09:37,642
然后我要设置输入单元，辞职处理程序，

195
00:09:37,710 --> 00:09:41,112
辞职处理人员。现在，我要设置它

196
00:09:41,181 --> 00:09:44,082
做一些闭包的事情，当我想要那些文本的时候就做到了

197
00:09:44,151 --> 00:09:46,818
领域辞职到第一响应者。那么，我该怎么做

198
00:09:46,886 --> 00:09:49,487
想做？我想把表情符号带出来

199
00:09:49,556 --> 00:09:52,089
当然放入我的清单。所以，我们就这样做。

200
00:09:52,158 --> 00:09:55,293
我要确定我的意思，首先，我要说，如果我能让

201
00:09:55,362 --> 00:10:00,698
文本等于输入单元格的文本字段文本，所以

202
00:10:00,767 --> 00:10:02,867
如果你能从那里得到一些文本。

203
00:10:02,936 --> 00:10:04,802
然后，我将会拥有我的emojis，

204
00:10:04,871 --> 00:10:07,839
记得那是我的模型吗？那是这样的，

205
00:10:07,907 --> 00:10:10,308
哎呀，它在哪里？在这里显示所有的emojis，

206
00:10:10,377 --> 00:10:13,678
我只是想补充一点，我只是想说我的

207
00:10:13,747 --> 00:10:17,181
emojis等于文本字段中的文本。

208
00:10:17,250 --> 00:10:19,950
我会映射它们，所有的角色都在那里

209
00:10:20,019 --> 00:10:24,556
字符串，以便我有一个字符串数组，对吗？和

210
00:10:24,624 --> 00:10:26,691
我会添加到已有的内容中。

211
00:10:26,760 --> 00:10:30,327
所以这是表情符号就是我们已经拥有的表情符号。和

212
00:10:30,396 --> 00:10:32,062
我甚至会在我要去的地方做一个小窍门

213
00:10:32,131 --> 00:10:36,133
uniquify他们，独特。这只是一件小事

214
00:10:36,202 --> 00:10:38,703
我把这个公用事业放在一个数组中

215
00:10:38,772 --> 00:10:40,671
确保所有项目都是独一无二的。

216
00:10:40,740 --> 00:10:43,040
因为我不想拥有多个笑脸，

217
00:10:43,109 --> 00:10:46,877
多辆自行车，无论如何。现在我明白了，嘿

218
00:10:46,946 --> 00:10:50,682
你在这里隐含地使用自己，你应该把自己的点。

219
00:10:50,750 --> 00:10:53,718
每次你这样做，你都会停下来

220
00:10:53,787 --> 00:10:56,287
嗯，这是否会创建一个记忆周期或

221
00:10:56,356 --> 00:10:59,223
这是否可能导致多线程问题？

222
00:10:59,292 --> 00:11:01,426
那么这里没有多线程问题。

223
00:11:01,494 --> 00:11:04,261
因为我们没有滚动单元格的问题

224
00:11:04,330 --> 00:11:07,431
就像你在家庭作业中一样滚回去。但

225
00:11:07,500 --> 00:11:11,202
这里有一个记忆周期。你看到如何

226
00:11:11,271 --> 00:11:13,704
有一个记忆周期，因为self是收集，

227
00:11:13,773 --> 00:11:14,639
是我们自私的视图控制者。

228
00:11:14,708 --> 00:11:16,640
我们指向我们的集合视图。

229
00:11:16,709 --> 00:11:20,111
当然，我们的收藏视图指向它的单元格。它的单元格

230
00:11:20,180 --> 00:11:23,648
指向这个闭包。这个闭包点回来了

231
00:11:23,717 --> 00:11:26,651
对我们自己。所以它一直在进行。所以

232
00:11:26,720 --> 00:11:30,455
我们必须用weak self来打破这一点。和

233
00:11:30,524 --> 00:11:33,824
然后让我们所有的self在这里成为问号。

234
00:11:33,893 --> 00:11:37,495
这也是一种self。它可以是self感叹号，因为

235
00:11:37,563 --> 00:11:40,231
如果这是零，我们不会到达那里。所以，这很好，

236
00:11:40,300 --> 00:11:42,466
但实际上这里还有另一个。

237
00:11:42,535 --> 00:11:44,869
有时候，只是因为它告诉你self，

238
00:11:44,938 --> 00:11:46,704
并不意味着那里可能没有其他人。

239
00:11:46,773 --> 00:11:50,441
还有另外一个，就是这个。这个var是输入

240
00:11:50,510 --> 00:11:52,877
单元格和我在这闭包内使用它，

241
00:11:52,945 --> 00:11:55,546
它将捕获它。但它指向了

242
00:11:55,615 --> 00:11:59,117
通过辞职处理人员回到闭包处，

243
00:11:59,185 --> 00:12:01,552
所以这也必须被打破。

244
00:12:01,621 --> 00:12:06,857
现在这个我们可以打破，打破，因为无主

245
00:12:06,926 --> 00:12:10,995
我们知道我们永远不会在这个闭包执行它，

246
00:12:11,063 --> 00:12:15,165
如果这是零。因为根据定义，我们正在执行

247
00:12:15,234 --> 00:12:18,603
它的辞职处理程序，所以我们可以使用无主的，在这种情况下，

248
00:12:18,671 --> 00:12:21,973
要做到这一点。还有什么我们需要在这里做？好吧，我们

249
00:12:22,042 --> 00:12:25,376
只需要停止说我们正在添加表情符号，因为

250
00:12:25,445 --> 00:12:28,612
我们不是，对，我们已经完成了在这里添加表情符号。

251
00:12:28,681 --> 00:12:32,917
然后，我们必须要问我们的表情符号集合视图

252
00:12:32,986 --> 00:12:36,287
重新加载数据。为什么我们需要重新加载数据？

253
00:12:36,356 --> 00:12:38,656
因为我们只是给我们的模型添加了表情符号

254
00:12:38,725 --> 00:12:42,393
无论何时您更改模型，您都需要更新表格。

255
00:12:42,461 --> 00:12:44,228
所以我会重新加载并导致它回归，

256
00:12:44,297 --> 00:12:47,031
看看我的新模型，调用所有这些函数，

257
00:12:47,099 --> 00:12:50,468
所有这些功能都在这里，重新加载一切。

258
00:12:50,537 --> 00:12:52,837
它也会很好地重新加载部分零和

259
00:12:52,905 --> 00:12:56,774
把按钮放回去是因为我把它设置为false。所以

260
00:12:56,843 --> 00:12:58,409
让我们看看所有这些行动。

261
00:13:06,385 --> 00:13:09,053
开始了。所以，我们有这个，我们仍然可以

262
00:13:09,121 --> 00:13:12,556
通常滚动。我们可以重新定位这些东西。

263
00:13:12,625 --> 00:13:14,625
它不会让我们把它放在0节，

264
00:13:14,694 --> 00:13:18,062
那很好。我们加上它带来了文本字段。

265
00:13:18,131 --> 00:13:19,363
它重新加载了该部分和

266
00:13:19,432 --> 00:13:22,467
放置文本字段，因为我们现在正在添加一个模块。

267
00:13:22,535 --> 00:13:26,804
可以在这里调出我的键盘，让我们放一些

268
00:13:26,872 --> 00:13:29,373
海中的生物在这里。我只是要那样做。现在，

269
00:13:29,442 --> 00:13:32,677
我会打回去哪个会解雇我的键盘

270
00:13:32,745 --> 00:13:35,013
因为那个辞职的第一反应者放在那里。

271
00:13:35,081 --> 00:13:36,480
由于这将结束编辑，

272
00:13:36,549 --> 00:13:41,485
它会将这个表情符号添加到我们的列表中。看到了吗？其

273
00:13:41,554 --> 00:13:44,822
他们是在开始。我们可以在这里做同样的事情。

274
00:13:44,891 --> 00:13:46,757
也许我会补充，我不知道，

275
00:13:46,826 --> 00:13:49,626
这里有些农场动物。而这次我不是

276
00:13:49,695 --> 00:13:52,229
会回来，我实际上会解雇我的键盘

277
00:13:52,298 --> 00:13:54,431
通过按下右下角的东西。

278
00:13:54,500 --> 00:13:56,734
你看到那个说键盘消失的东西。准备，

279
00:13:56,803 --> 00:14:01,972
繁荣，现在它增加了这些。所以，'它，

280
00:14:02,041 --> 00:14:05,542
那是文本字段。对不起，我们不得不匆忙，有点匆忙，

281
00:14:05,611 --> 00:14:08,379
但是我们又一次得到了很多其他的东西。我会的

282
00:14:08,447 --> 00:14:10,815
发布这个代码，所以你可以详细看看它

283
00:14:10,884 --> 00:14:12,549
看到。我向你们展示了我们所做的所有改变，

284
00:14:12,618 --> 00:14:14,351
我只是没有全部输入，

285
00:14:14,420 --> 00:14:20,491
随着我们的前进。好的，回到这里的幻灯片。

286
00:14:20,559 --> 00:14:23,160
今天我们来谈谈我们的主题，即持久性。

287
00:14:23,229 --> 00:14:26,764
通过坚持，我的意思是让事情坚持下去，对吧？

288
00:14:26,833 --> 00:14:29,333
用户输入一些东西，他们创建了一个表情符号艺术

289
00:14:29,402 --> 00:14:31,836
文件或类似的东西。而你，当然，

290
00:14:31,904 --> 00:14:33,771
希望这些东西留在你身边，不要他们

291
00:14:33,840 --> 00:14:36,040
每次运行应用程序时都会消失。在这种情况下

292
00:14:36,108 --> 00:14:38,042
你的家庭作业和现在的表情符号艺术的情况下，

293
00:14:38,111 --> 00:14:40,545
这是没用的。所以有很多方法

294
00:14:40,614 --> 00:14:42,313
让事情持久下去，就像你看到的那样

295
00:14:42,382 --> 00:14:44,982
让我们深入讨论所有这些问题。

296
00:14:45,051 --> 00:14:47,885
现在，其中一些我只会覆盖一点点

297
00:14:47,953 --> 00:14:50,888
其中一些我会深入报导。第一个在这里

298
00:14:50,956 --> 00:14:54,525
是UserDefault，现在这个超级简单，

299
00:14:54,594 --> 00:14:58,329
它就像字典一样持续下去，对吧？

300
00:14:58,398 --> 00:15:00,698
你用钥匙把东西放在这本字典里

301
00:15:00,767 --> 00:15:03,200
值和下次运行应用程序时，

302
00:15:03,269 --> 00:15:07,671
他们仍然在那里。唯一的限制就是，

303
00:15:07,740 --> 00:15:10,207
这是你可以在这本词典中唯一的东西

304
00:15:10,276 --> 00:15:12,910
东西是属性列表。

305
00:15:12,979 --> 00:15:14,912
好吧，现在属性列表不是一种类型，或者

306
00:15:14,981 --> 00:15:17,582
类似的东西，这只是一个概念。

307
00:15:17,650 --> 00:15:19,817
属性列表是任意组合，

308
00:15:19,886 --> 00:15:23,520
任何数据结构，即只有数组的任何组合，

309
00:15:23,589 --> 00:15:27,158
字典，字符串，日期，数据或像膨胀一样的数字，

310
00:15:27,227 --> 00:15:30,361
提示或双重。好的，那就是我们所说的属性清单。

311
00:15:30,430 --> 00:15:33,030
这是你可以在这一点上唯一的东西

312
00:15:33,099 --> 00:15:36,067
一个名为UserDefaults的轻量级数据库，好吗？

313
00:15:36,135 --> 00:15:39,037
那么API是什么样子的呢，把东西放在那里呢？

314
00:15:39,105 --> 00:15:42,639
很简单，这里有两个主要的方法，

315
00:15:42,708 --> 00:15:46,244
用属性列表作为键的参数。

316
00:15:46,312 --> 00:15:50,648
然后返回一个返回属性列表的键。

317
00:15:50,717 --> 00:15:52,649
这是一个NE的原因是真的

318
00:15:52,718 --> 00:15:55,453
没有其他类型可以表示属性列表，并且

319
00:15:55,522 --> 00:15:57,121
这是一个Objective-C API。

320
00:15:57,190 --> 00:16:01,826
但是NE必须是一个属性列表。所以

321
00:16:01,895 --> 00:16:04,362
它可能是一个int。它可以是一串字符串。

322
00:16:04,430 --> 00:16:06,531
它可能是一个字典，其键是字符串和

323
00:16:06,599 --> 00:16:08,733
其值是double数组。

324
00:16:08,801 --> 00:16:11,502
这些都将被视为属性清单。但

325
00:16:11,571 --> 00:16:15,572
一个CG浮点数组？不是属性列表，

326
00:16:15,641 --> 00:16:21,445
因为CG浮动不是属性列表。好吧，

327
00:16:21,514 --> 00:16:23,213
所以你如何阅读和写这些东西？

328
00:16:23,282 --> 00:16:25,449
你如何访问这个？你怎么称呼这些方法？好，

329
00:16:25,517 --> 00:16:29,419
我们实际上并没有创建一个不同的UserDefaults事物。

330
00:16:29,488 --> 00:16:32,156
你可以，但我们通常不这样做。我们改用了

331
00:16:32,225 --> 00:16:34,925
我们通过说UserDefaults.standard获得共享的。

332
00:16:34,994 --> 00:16:39,063
标准是用户演变类中的静态栏，并且

333
00:16:39,131 --> 00:16:42,533
它返回到这个共享UserDefaults的东西。和

334
00:16:42,601 --> 00:16:45,769
那么我们只需在其上设置呼叫集来设置值，我们就可以

335
00:16:45,838 --> 00:16:50,774
请将对象紧密呼叫或forKey，让事情恢复正常。

336
00:16:50,843 --> 00:16:52,476
所以这里有一些例子。

337
00:16:52,545 --> 00:16:53,844
注意我可以设置一个浮点数，

338
00:16:53,913 --> 00:16:54,745
因为这是一个属性列表。

339
00:16:54,814 --> 00:16:57,281
我可以设置一个int数组，这是一个属性列表。

340
00:16:57,350 --> 00:16:59,717
我也可以设置零，因为它是一个Any ?,和

341
00:16:59,785 --> 00:17:02,787
这意味着清除任何价值

342
00:17:02,855 --> 00:17:08,626
这个关键。还有一些便利的方法

343
00:17:08,694 --> 00:17:11,328
把事情弄清楚，对，如果你反对的话

344
00:17:11,397 --> 00:17:14,731
关键，你会回到哪种类型？一个任何，这意味着

345
00:17:14,800 --> 00:17:18,503
你必须用它来把它变成某种东西。好，

346
00:17:18,571 --> 00:17:20,405
为了节省你，他们有一些方法和

347
00:17:20,473 --> 00:17:23,207
他们就像double forKey，array forKey和

348
00:17:23,275 --> 00:17:26,944
那些会返回你的类型。现在，例如，

349
00:17:27,013 --> 00:17:30,248
double forKey，如果那里的东西没有一个double，

350
00:17:30,316 --> 00:17:33,117
它只是会返回0.因为它不是一个问号，

351
00:17:33,186 --> 00:17:36,254
不幸的是，这只是double。和

352
00:17:36,322 --> 00:17:39,056
同样，一个forKey数组，如果那里的东西，

353
00:17:39,124 --> 00:17:41,792
如果该键不是数组，它将返回零，

354
00:17:41,861 --> 00:17:44,594
因为这是一个可选的数组。所以这些小东西，

355
00:17:44,663 --> 00:17:45,996
这些便利尽力帮助你，但是

356
00:17:46,065 --> 00:17:47,832
他们只会尽可能地帮助你。

357
00:17:47,901 --> 00:17:50,033
如果你把错误的类型放在那里，显然，

358
00:17:50,102 --> 00:17:53,504
他们做不到正确的事情。我什么时候会用这个

359
00:17:53,573 --> 00:17:55,640
事情？这件事真的只是为了

360
00:17:55,708 --> 00:17:59,010
轻量级的东西，如设置，喜好，

361
00:17:59,078 --> 00:18:01,278
那有点东西。您不会存储文档或

362
00:18:01,347 --> 00:18:05,082
那里有用户默认的任何类型的严重用户数据。

363
00:18:05,151 --> 00:18:08,318
现在保存数据库，数据库自动保存

364
00:18:08,387 --> 00:18:10,988
您。所以你真的不需要保存它。但有时你

365
00:18:11,056 --> 00:18:13,524
想要，尤其是当你在调试时

366
00:18:13,593 --> 00:18:15,560
你总是在调试器中停下来。

367
00:18:15,628 --> 00:18:18,528
有时你会在有机会之前停下来

368
00:18:18,597 --> 00:18:20,431
保存。所以如果你想明确保存，

369
00:18:20,500 --> 00:18:23,133
你可以使用这个方法同步，这将会保存

370
00:18:23,202 --> 00:18:25,303
它。它返回一个bool，不管它是否成功

371
00:18:25,371 --> 00:18:27,204
不知道如果不成功，你会怎么做。

372
00:18:27,272 --> 00:18:28,772
我想再试一次。

373
00:18:28,841 --> 00:18:32,242
但我们通常不会看这个的返回值。

374
00:18:32,311 --> 00:18:34,979
我们只是说同步。所以很多时候人们会放

375
00:18:35,047 --> 00:18:37,214
在那里同步，因为他们在做调试器，

376
00:18:37,283 --> 00:18:38,882
他们一直在停止，

377
00:18:38,951 --> 00:18:41,452
并没有保存它们，然后再运行它。所以

378
00:18:41,521 --> 00:18:42,787
如果你愿意，你可以随意做到这一点。

379
00:18:42,855 --> 00:18:46,858
做同步很轻巧。好，如此

380
00:18:46,926 --> 00:18:49,927
这是第一个。第二种方式

381
00:18:49,996 --> 00:18:53,564
持久的东西被称为归档。所以与问题

382
00:18:53,633 --> 00:18:56,099
首先，用户默认只有很小的东西。

383
00:18:56,168 --> 00:18:59,236
其次，必须是属性清单。如果我有

384
00:18:59,304 --> 00:19:03,173
一些数据结构，我想存储，这是大和或

385
00:19:03,242 --> 00:19:06,943
除了属性列表之外，还有其他东西。并做到这一点

386
00:19:07,012 --> 00:19:10,247
我要使用归档。现在有两种机制

387
00:19:10,316 --> 00:19:14,451
归档，旧的方式和iOS 11的新方式。

388
00:19:14,520 --> 00:19:17,154
当然，我会详细讨论新的

389
00:19:17,223 --> 00:19:19,857
iOS 11的方式，因为旧的方式显然不好

390
00:19:19,926 --> 00:19:22,593
足够。他们在iOS 11中提出了一个新的。

391
00:19:22,661 --> 00:19:24,461
但是它们在某些方面非常非常相似。

392
00:19:24,530 --> 00:19:26,831
只是这种新方式更加自动化，而且

393
00:19:26,899 --> 00:19:29,933
编写的代码少得多。那么让我们来谈谈这两件事

394
00:19:30,002 --> 00:19:32,536
方法。旧的方式称为NS编码器。

395
00:19:32,605 --> 00:19:35,639
所以NS编码器是一个协议。和

396
00:19:35,708 --> 00:19:39,677
基本上NS编码器归结为每一个

397
00:19:39,746 --> 00:19:43,947
要保存的对象图中的对象，或者

398
00:19:44,016 --> 00:19:47,717
无论如何，坚持不懈，实施这两件事情。

399
00:19:47,786 --> 00:19:49,987
一个称为编码器的函数。

400
00:19:50,056 --> 00:19:53,323
所以NS编码器有点像是字典里的东西，

401
00:19:53,392 --> 00:19:56,394
你可以在那里设置数值。然后从编码器初始化。

402
00:19:56,462 --> 00:19:58,729
它可能会让你回到那个字典

403
00:19:58,798 --> 00:20:02,199
你得初始化这个对象。所以这很简单。

404
00:20:02,268 --> 00:20:05,102
你只需要将编码发送给每一个对象

405
00:20:05,170 --> 00:20:08,038
对象图。它会把自己放在一个大的

406
00:20:08,107 --> 00:20:10,374
字典。然后当你想把它带回生活时，

407
00:20:10,443 --> 00:20:13,110
你开始用编码器告诉init

408
00:20:13,179 --> 00:20:15,112
他们都必须自己初始化。

409
00:20:15,181 --> 00:20:19,683
这是故事板如何保存。所以查看Controller，

410
00:20:19,752 --> 00:20:22,653
UI视图，UI标签按钮，所有这些都实现

411
00:20:22,722 --> 00:20:26,089
代码中的这些东西以及编码器中的init。和

412
00:20:26,158 --> 00:20:28,759
有人去辛苦工作来实施

413
00:20:28,828 --> 00:20:31,028
对于故事板中的每一件可能的事情。

414
00:20:31,097 --> 00:20:34,465
实际上花了多少工作是惊人的。所以

415
00:20:34,533 --> 00:20:37,467
这很好，你有这种编码，编码和

416
00:20:37,536 --> 00:20:39,503
解码能力。你用它做什么？

417
00:20:39,571 --> 00:20:42,172
那么，你几乎总是用它来做这件事

418
00:20:42,241 --> 00:20:46,476
东西变成数据。请记住我们的数据，比特包，

419
00:20:46,545 --> 00:20:49,146
那个小结构？你变成了一个数据，然后你

420
00:20:49,214 --> 00:20:50,680
可以将数据存储在文件系统中。

421
00:20:50,749 --> 00:20:51,882
因为你要学习Cuz，

422
00:20:51,951 --> 00:20:54,552
这就是我们如何与文件系统进行交互的方式。我们存储和

423
00:20:54,620 --> 00:20:58,923
读取数据。那么你如何拿一个大对象图，在哪里

424
00:20:58,991 --> 00:21:01,191
那里的每一个物体都实现了这两件事，

425
00:21:01,260 --> 00:21:04,395
并把它变成一个数据？你可以用键入的NS来完成

426
00:21:04,463 --> 00:21:08,131
归档。所以NS键控存档器只需要一个对象

427
00:21:08,200 --> 00:21:10,934
它和它指向的一切都实现了这两件事情，

428
00:21:11,003 --> 00:21:14,338
它会给你一个已经占据整体的数据

429
00:21:14,407 --> 00:21:17,074
对象图，并将其收集到数据中。

430
00:21:17,143 --> 00:21:20,143
同样，如果你把这样的数据还给它，

431
00:21:20,212 --> 00:21:21,612
到NS键入unarchiver，

432
00:21:21,681 --> 00:21:25,182
unarchiver然后它会将它变回对象

433
00:21:25,250 --> 00:21:27,751
通过调用该init。每个人都很酷，我们如何

434
00:21:27,820 --> 00:21:30,654
去做？这是使这个机制起作用的很多工作

435
00:21:30,722 --> 00:21:32,522
因为你必须执行这两件事

436
00:21:32,591 --> 00:21:34,624
在那里的每一个对象。所以

437
00:21:34,693 --> 00:21:36,660
让我们来谈谈新的方式，这很相似。

438
00:21:36,729 --> 00:21:39,730
它被称为Codable。而Codable是一个协议，

439
00:21:39,798 --> 00:21:43,366
它实际上是两个协议，D-Codable和N-Codable。和

440
00:21:43,435 --> 00:21:46,937
它以同样的方式工作。你还有init和

441
00:21:47,006 --> 00:21:48,339
你仍然有一个编码的东西。

442
00:21:48,407 --> 00:21:51,275
不同之处在于Swift和运行时，以及

443
00:21:51,343 --> 00:21:54,445
基金会将为您实施这两种方法，

444
00:21:54,513 --> 00:21:57,547
几乎所有的时间。它只是一种实现它们

445
00:21:57,616 --> 00:21:59,283
免费的，所以你不必做任何事情。

446
00:21:59,352 --> 00:22:02,920
所以只要你在Swift中使用了一些基本类型，

447
00:22:02,989 --> 00:22:05,222
包括你在这张幻灯片上看到的所有东西，

448
00:22:05,291 --> 00:22:07,891
它只是神奇的作品。所以

449
00:22:07,960 --> 00:22:11,562
我将向你们展示我们如何拍摄对象图和

450
00:22:11,631 --> 00:22:13,264
用这个机制把它变成一个数据，

451
00:22:13,332 --> 00:22:15,732
这与关键存档的东西略有不同。

452
00:22:15,801 --> 00:22:17,701
而且我也会告诉你它看起来是什么样子

453
00:22:17,770 --> 00:22:21,004
Codable的东西，因为要做到这一点，它必须是

454
00:22:21,073 --> 00:22:23,139
可编码的。它必须实施Codable。所以我们来看看

455
00:22:23,208 --> 00:22:26,210
那些。首先让我们看看我们如何将其转化为数据。这里，

456
00:22:26,278 --> 00:22:29,346
而不是把它变成一个任意的数据块

457
00:22:29,415 --> 00:22:32,449
我们不知道它是什么，我们实际上编码它

458
00:22:32,518 --> 00:22:36,019
像JSON这样的已知格式。大家都知道JSON是什么？

459
00:22:36,088 --> 00:22:38,221
它基本上就像这种文本格式

460
00:22:38,290 --> 00:22:40,925
在互联网上描述事物，传递数据。

461
00:22:40,993 --> 00:22:44,561
所以JSON是一个众所周知的格式，我们可以将其转换

462
00:22:44,630 --> 00:22:47,365
大对象图形成它的描述，

463
00:22:47,433 --> 00:22:50,667
令人惊讶的是JSON。还有另一个

464
00:22:50,736 --> 00:22:53,770
编码器，可以做到这一点，那属性列表，所以。

465
00:22:53,839 --> 00:22:56,073
这整个事情我告诉你关于UserDefaults，

466
00:22:56,142 --> 00:22:58,575
一切都是一串字符串或日期或数字，

467
00:22:58,644 --> 00:23:00,711
你也可以把它变成类似的东西。

468
00:23:00,779 --> 00:23:03,713
这些是iOS附带的两个编码器。和

469
00:23:03,782 --> 00:23:04,848
你怎么做到这一点？好，

470
00:23:04,917 --> 00:23:08,151
你只是有你的对象是mytype，

471
00:23:08,220 --> 00:23:11,922
您定义的某种类型。该类型必须是Codable。

472
00:23:11,990 --> 00:23:14,591
只要它是Codable和它想要的一切

473
00:23:14,660 --> 00:23:18,061
在它里面存档的是Codable，那么你可以说JSON

474
00:23:18,130 --> 00:23:22,899
数据等于尝试JSON编码该对象。它是

475
00:23:22,968 --> 00:23:25,468
会给你回数据blob，并在该数据blob

476
00:23:25,537 --> 00:23:29,206
是整个对象图的JSON表示，

477
00:23:29,274 --> 00:23:33,143
这是非常不可思议的。现在注意到这确实会抛出，

478
00:23:33,212 --> 00:23:36,146
编码时不太可能抛出，但可以

479
00:23:36,215 --> 00:23:39,383
可能有些地方首先，我不知道为什么，但是

480
00:23:39,452 --> 00:23:43,153
它无法编码它，它可能会抛出。

481
00:23:43,222 --> 00:23:45,956
顺便说一句，如果你有一个JSON数据Blob，

482
00:23:46,025 --> 00:23:49,292
你可能想看看它是一个字符串。用JSON就是了

483
00:23:49,361 --> 00:23:52,929
始终编​​码为utf8。这是它使用的字符串编码。

484
00:23:52,998 --> 00:23:55,666
所以你总是可以像jsonData一样获取数据Blob

485
00:23:55,735 --> 00:23:58,669
从那里的前一行开始，并用它创建一个字符串。

486
00:23:58,737 --> 00:24:00,938
所有的字符串需要知道的是编码是什么？

487
00:24:01,007 --> 00:24:06,677
你说它是.utf8。这是Unicode 8位编码。

488
00:24:06,746 --> 00:24:09,546
好的，现在，如果你有一个JSON表示的话

489
00:24:09,615 --> 00:24:10,881
你的整个对象图和

490
00:24:10,950 --> 00:24:13,116
你想创建你的对象图吗？

491
00:24:13,185 --> 00:24:16,520
那么你只需使用JSON解码器并说解码。

492
00:24:16,588 --> 00:24:20,024
那么你所要做的就是指定The class or

493
00:24:20,092 --> 00:24:22,625
JSON中顶层事物的结构，

494
00:24:22,694 --> 00:24:26,396
由该JSON代表。并给它JSON数据blob和

495
00:24:26,465 --> 00:24:28,865
它会解码它。现在这也抛出和

496
00:24:28,934 --> 00:24:31,769
这是更可能抛出。也许你的JSON数据是

497
00:24:31,837 --> 00:24:35,639
损坏或畸形或类似的东西。和

498
00:24:35,708 --> 00:24:38,175
它很有可能使这一切工作，你在哪里

499
00:24:38,243 --> 00:24:41,144
在那里使用一些标准的JSON从一些网站

500
00:24:41,213 --> 00:24:43,780
您将其转换为代码中的对象。

501
00:24:43,849 --> 00:24:45,582
你在哪里做一对一的映射。

502
00:24:45,651 --> 00:24:48,686
所以也许你去的网站有错误

503
00:24:48,754 --> 00:24:52,856
他们生成不好的JSON或其他东西，所以这可能会抛出

504
00:24:52,924 --> 00:24:55,626
这里。让我们来谈谈，我们会谈谈一点

505
00:24:55,694 --> 00:24:58,862
一秒钟，以及如何处理这件事扔。

506
00:24:58,931 --> 00:25:03,133
请注意，JSON与“强类型”相反。

507
00:25:03,202 --> 00:25:07,237
像JSON中的日期只是某种格式的字符串，对吧？

508
00:25:07,306 --> 00:25:11,041
JSON中不存在日期类型这样的概念。所以这

509
00:25:11,109 --> 00:25:14,444
解码器是相当可配置的，所以你可以指定一些东西

510
00:25:14,513 --> 00:25:18,615
比如，解码应该是约会的策略是什么？

511
00:25:18,683 --> 00:25:20,166
这个JSON文件中存储日期的格式是什么？那么你

512
00:25:20,167 --> 00:25:21,650
换一种说法，

513
00:25:21,720 --> 00:25:25,055
可以指定那些有点东西来配置解码器

514
00:25:25,124 --> 00:25:29,325
能够找出这个JSON表示。好吧，

515
00:25:29,394 --> 00:25:32,429
现在我谈到抛出错误。在这里，例如，

516
00:25:32,498 --> 00:25:36,232
我遇到了这个解码器抛出的错误。

517
00:25:36,301 --> 00:25:38,101
我之所以显示这一点其实并不是因为

518
00:25:38,170 --> 00:25:40,404
你要这样做。你实际上不太可能

519
00:25:40,472 --> 00:25:43,173
捕获这些解码错误并对它们做任何事情。

520
00:25:43,242 --> 00:25:45,409
除非你正在调试你自己的JSON格式，

521
00:25:45,478 --> 00:25:47,744
你想看看你犯了什么错误或什么。

522
00:25:47,813 --> 00:25:50,147
但我想在这里向你展示它看起来像什么

523
00:25:50,215 --> 00:25:54,951
抛出的错误是一个枚举。 Cuz记得那个

524
00:25:55,020 --> 00:25:58,154
什么都可以抛出。你可以抛出任何类型的东西

525
00:25:58,223 --> 00:26:00,557
一个错误。它所要做的就是实现协议错误，

526
00:26:00,625 --> 00:26:03,493
这真的没什么，所以你可以扔任何东西。

527
00:26:03,562 --> 00:26:06,529
所以很多时候事情会抛出一个枚举。当他们

528
00:26:06,598 --> 00:26:09,366
扔枚举，你可以做同样的事情，我们做开关，

529
00:26:09,435 --> 00:26:11,468
这是为了获取相关的值。

530
00:26:11,536 --> 00:26:15,739
所以你可以看到这对于错误非常有效，对吗？

531
00:26:15,808 --> 00:26:18,007
所以你抓住了关键找不到错误和

532
00:26:18,076 --> 00:26:19,376
你抓住了相关的价值，

533
00:26:19,444 --> 00:26:23,279
这是其中之一是没有找到的关键。所以

534
00:26:23,348 --> 00:26:25,816
这是一件很平常的事情，就是抛出枚举和

535
00:26:25,885 --> 00:26:28,084
然后在你的捕获中，你只是抓住案件和

536
00:26:28,153 --> 00:26:31,956
你被允许做同样的事情来获取关联

537
00:26:32,024 --> 00:26:37,194
就像你可以用开关做的那样。好吧，

538
00:26:37,263 --> 00:26:39,896
所以我们来看一个让事情可编码的例子。

539
00:26:39,965 --> 00:26:42,399
所以我在这里得到了我的struct MyType。和

540
00:26:42,468 --> 00:26:44,367
它有一个日期，一个字符串，和

541
00:26:44,436 --> 00:26:46,837
那么它有一些其他类型的bar

542
00:26:46,906 --> 00:26:49,372
这里没有显示。为了使其可编码，

543
00:26:49,441 --> 00:26:53,743
我所要做的就是说colon可编码。如果我说这是

544
00:26:53,812 --> 00:26:58,215
可编码的，那么它是可编码的。除非它或里面的东西

545
00:26:58,284 --> 00:27:01,484
它不能由swift自动编码。所以

546
00:27:01,553 --> 00:27:03,921
这不是我第一次向你展示的那些东西之一

547
00:27:03,989 --> 00:27:07,157
滑到那里。所以在这里，日期绝对是可编码的，

548
00:27:07,225 --> 00:27:08,892
字符串是可编码的，据推测，

549
00:27:08,961 --> 00:27:12,462
一些其他类型也使自己可编码。和

550
00:27:12,531 --> 00:27:15,666
所以，这件事现在是可编码的，这就是我必须要做的。

551
00:27:15,734 --> 00:27:18,301
实现init和编码更容易

552
00:27:18,370 --> 00:27:21,438
在那里的每一个对象。我们只是说它是可编码的，而且

553
00:27:21,507 --> 00:27:24,274
它是。以及使用该产生的JSON

554
00:27:24,343 --> 00:27:26,710
JSON编码器看起来像这样，对吧？

555
00:27:26,778 --> 00:27:29,846
someDate，它与var，冒号和

556
00:27:29,915 --> 00:27:32,949
然后是我们决定的某种编码策略中的日期。

557
00:27:33,018 --> 00:27:36,486
然后“someString”：“你好”，然后是“其他”：

558
00:27:36,555 --> 00:27:40,156
<无论SomeOtherType看起来像在JSON>看起来会

559
00:27:40,225 --> 00:27:44,194
被嵌入在那里，你看到了吗？所以它可以递归

560
00:27:44,263 --> 00:27:48,965
下降。现在我们可能不想要JSON

561
00:27:49,034 --> 00:27:52,702
看起来完全像这样，那么我们可以调整它吗？是的，我们可以，

562
00:27:52,771 --> 00:27:57,007
看这个。例如，在JSON中，通常是键

563
00:27:57,075 --> 00:28:00,443
没有骆驼案例，你知道一些大写的D数据

564
00:28:00,512 --> 00:28:03,513
就像我们为变数所做的一样。通常钥匙是，

565
00:28:03,582 --> 00:28:07,183
单词与“som_date”之类的下划线是分开的。所以

566
00:28:07,252 --> 00:28:10,787
我们可以轻松地更改我们使用时生成的密钥

567
00:28:10,856 --> 00:28:15,158
即JSON编码器通过添加一个名为CodingKeys的私有枚举

568
00:28:15,227 --> 00:28:17,327
这是一个字符串类型的枚举。和

569
00:28:17,396 --> 00:28:19,830
它必须实现一个协议编码密钥。和

570
00:28:19,899 --> 00:28:22,799
它所做的只是一个案例，它是一个枚举，对吧？

571
00:28:22,868 --> 00:28:25,168
对于我们要编码的每个变种都有一个案例。

572
00:28:25,237 --> 00:28:26,870
所以如果我们有一个var我们不想编码，

573
00:28:26,939 --> 00:28:28,672
只是不要把那个案子放在那里。和

574
00:28:28,741 --> 00:28:30,340
如果你有一个你想编码的变种，但是

575
00:28:30,409 --> 00:28:33,510
你想要它改变钥匙，只是说等于你的钥匙

576
00:28:33,578 --> 00:28:36,946
想。所以在这里我已经说过case someDate =“som_date”，所以

577
00:28:37,015 --> 00:28:40,550
现在在JSON中，它会说som_date等于，而不是

578
00:28:40,619 --> 00:28:43,687
someDate。并注意我没有在那里放一些字符串的情况

579
00:28:43,756 --> 00:28:46,490
毕竟，所以someString甚至不会被放入JSON中。

580
00:28:48,427 --> 00:28:50,894
所以这是一个非常酷，简单的方法

581
00:28:50,963 --> 00:28:55,065
自定义从您的类型生成的JSON。现在，

582
00:28:55,134 --> 00:28:57,400
我甚至不会真的谈论这个，但是

583
00:28:57,469 --> 00:29:01,537
你可以从解码器实现init。那件事

584
00:29:01,606 --> 00:29:05,641
实际上是把这个东西从jJSON中抽出来。如果你想

585
00:29:05,710 --> 00:29:08,411
做一些验证或某种复杂的事情，或者

586
00:29:08,480 --> 00:29:12,282
例如，如果你有一个swift不能编码的类型。

587
00:29:12,351 --> 00:29:15,418
一些你发明的不是由它们组成的新类型

588
00:29:15,487 --> 00:29:18,188
其他类型的迅速可以编码，你想这样做，

589
00:29:18,257 --> 00:29:20,490
你能行的。我只是把它放在这里，

590
00:29:20,558 --> 00:29:23,426
所以你可以稍后看看它是如何做到的。

591
00:29:23,495 --> 00:29:25,561
解码器中有一个容器，你可以得到它

592
00:29:25,630 --> 00:29:28,431
它有键和值看起来像一本字典。它的

593
00:29:28,500 --> 00:29:32,402
不那么难。有一件事是当你解码一个类时，

594
00:29:32,471 --> 00:29:34,838
你必须在这里为supe_init调用，对吧？

595
00:29:34,907 --> 00:29:37,073
因为你正在解码，你必须实现init。

596
00:29:37,142 --> 00:29:39,575
所以你必须调用supe_init。但不要调用supe_init

597
00:29:39,644 --> 00:29:42,546
使用发送给您的相同解码器。解码器已发送

598
00:29:42,614 --> 00:29:46,283
给你解码你的变数。你想发送这个

599
00:29:46,351 --> 00:29:49,153
来自称为superDecoder的容器的东西。

600
00:29:49,221 --> 00:29:52,889
作为你的超类的解码器吧。和

601
00:29:52,958 --> 00:29:56,860
那么当然，你也可以实现编码来编码

602
00:29:56,929 --> 00:29:59,496
随机类型不属于swift的一部分。

603
00:29:59,564 --> 00:30:00,864
再说一次，我不会去解决这个问题。

604
00:30:00,933 --> 00:30:01,832
你不必为此做任何事情

605
00:30:01,900 --> 00:30:04,734
当然你的功课。但对于你的最终项目

606
00:30:04,803 --> 00:30:07,571
至少你知道这是可以做到的，就是实现编码

607
00:30:07,639 --> 00:30:11,040
和init为你自己。好，就这样

608
00:30:11,109 --> 00:30:14,177
归档。归档，整点是我们采取一些

609
00:30:14,246 --> 00:30:17,413
快速的东西绘制对象，我们把它变成一个数据。

610
00:30:17,482 --> 00:30:18,915
数据要么是JSON要么是

611
00:30:18,984 --> 00:30:21,217
属性列表格式。所以我们有一个数据，

612
00:30:21,286 --> 00:30:24,487
现在我们想要将这些数据存储在文件系统中。

613
00:30:24,556 --> 00:30:25,588
我们会把它放在一个文件中。

614
00:30:25,657 --> 00:30:29,426
这只是一个普通的文件。请记住，iOS是Unix。和

615
00:30:29,495 --> 00:30:32,929
所以当然我们有一个unix文件系统

616
00:30:32,998 --> 00:30:36,500
从斜杠开始的任何其他unix文件系统和

617
00:30:36,568 --> 00:30:39,502
我们所需要做的只是写出它来存储我们的数据博客

618
00:30:39,571 --> 00:30:43,740
到一个文件。那么我们如何在iOS中访问这个unix文件系统呢？

619
00:30:43,809 --> 00:30:45,909
那么，最重要的是

620
00:30:45,977 --> 00:30:48,712
明白是Unix文件系统的唯一部分你

621
00:30:48,780 --> 00:30:53,116
可以访问你的沙盒。你的沙盒就是这个

622
00:30:53,184 --> 00:30:55,418
密闭空间。这是你唯一可以写的地方。

623
00:30:55,487 --> 00:30:57,887
您无法在任何地方写入任何系统文件。

624
00:30:57,956 --> 00:30:59,889
你不能写入任何其他应用程序的信息。

625
00:30:59,958 --> 00:31:02,692
您只能在沙盒中书写。为什么iOS

626
00:31:02,761 --> 00:31:07,731
限制你到一个沙盒。那么，主要有三个原因。

627
00:31:07,799 --> 00:31:12,636
一，安全。因为我们想确保没有其他人

628
00:31:12,704 --> 00:31:16,473
应用程序可以过来，并以某种方式破坏你的应用程序，让它如此

629
00:31:16,542 --> 00:31:19,810
你的应用程序无法正常工作。隐私，

630
00:31:19,878 --> 00:31:21,845
你正在收集用户信息，无论如何，

631
00:31:21,914 --> 00:31:24,080
你不希望其他恶意应用程序在那里看

632
00:31:24,149 --> 00:31:26,983
并获取该信息。而一个被低估的是

633
00:31:27,052 --> 00:31:30,954
清理。你想在用户说的时候清理掉，

634
00:31:31,022 --> 00:31:34,090
我不希望这个应用程序了。如果你拥有一切

635
00:31:34,159 --> 00:31:36,426
一个沙盒，你可以删除那个沙盒，现在一切

636
00:31:36,494 --> 00:31:39,595
该应用程序曾经完成了。所以，有清理

637
00:31:39,664 --> 00:31:43,666
一部分。所以，Unix文件系统中的Access就是一切

638
00:31:43,735 --> 00:31:47,103
在这个沙盒中找到一个起点。还有

639
00:31:47,172 --> 00:31:49,939
你可以找到几个起点。例如，

640
00:31:50,008 --> 00:31:52,675
沙盒中有您的应用程序目录。

641
00:31:52,744 --> 00:31:56,179
这有你的可执行文件，所有的故事板，JPEG文件，

642
00:31:56,248 --> 00:31:58,148
你的图像资产，所有这些东西。

643
00:31:58,216 --> 00:32:02,486
你的沙盒的这一部分，你可以得到一个Unix路径。

644
00:32:02,554 --> 00:32:04,654
但它完全不可写。

645
00:32:04,723 --> 00:32:07,323
你不能写任何这些。你只能阅读它。

646
00:32:07,392 --> 00:32:09,125
如果有什么你需要写在那里，

647
00:32:09,194 --> 00:32:12,229
比如说让你通过一些初始数据库或者其他的东西，

648
00:32:12,297 --> 00:32:13,463
你将不得不复制到

649
00:32:13,531 --> 00:32:15,866
你的沙盒中的其他地方之一，和

650
00:32:15,934 --> 00:32:19,069
从那里编辑它。你的沙盒中的另一个地方，

651
00:32:19,138 --> 00:32:21,771
真正重要的是Documents目录。

652
00:32:21,840 --> 00:32:25,041
这是您存储用户感知的内容的地方

653
00:32:25,110 --> 00:32:27,177
作为文件形式的数据。

654
00:32:27,245 --> 00:32:30,146
它的重要性在于它是用户感知的

655
00:32:30,215 --> 00:32:33,083
作为一个文件是因为这个目录，那里有什么，

656
00:32:33,152 --> 00:32:36,253
会在iOS 11的文件应用程序中显示。

657
00:32:36,321 --> 00:32:39,756
我不知道你们是否都看过iOS 11，玩过它

658
00:32:39,825 --> 00:32:42,559
许多。有一个新的应用程序，文件，它显示

659
00:32:42,627 --> 00:32:45,362
你在所有文档目录中的所有文件

660
00:32:45,430 --> 00:32:48,598
应用程序。所以不要把东西放在Documents目录中

661
00:32:48,666 --> 00:32:52,502
除非他们被用户视为文档。

662
00:32:52,570 --> 00:32:54,704
还有应用程序支持。那就是你可以的地方

663
00:32:54,773 --> 00:32:58,174
把用户创建的东西不是文档，

664
00:32:58,243 --> 00:33:00,610
因为这不会显示在文件中。和

665
00:33:00,679 --> 00:33:01,911
那么还有其他目录，

666
00:33:01,980 --> 00:33:03,914
大约十几个其他的。其中之一，例如，

667
00:33:03,982 --> 00:33:06,183
是Caches目录。这是你可以暂时放置的地方

668
00:33:06,251 --> 00:33:09,052
可以随时删除的东西，在任何时候，

669
00:33:09,121 --> 00:33:12,022
并重新创建。例如，在本周的作业中，

670
00:33:12,090 --> 00:33:14,190
我会要求你把你的图像画廊和

671
00:33:14,259 --> 00:33:18,161
缓存这些图像。所以当人们把东西拖进去

672
00:33:18,229 --> 00:33:19,262
然后他们开始滚动，

673
00:33:19,331 --> 00:33:20,463
而不是经常回去和

674
00:33:20,531 --> 00:33:21,798
一直提取这些东西，

675
00:33:21,867 --> 00:33:23,299
你将它们缓存在文件系统中。好，

676
00:33:23,368 --> 00:33:26,035
你会想把它放在Caches目录中，因为

677
00:33:26,104 --> 00:33:28,905
它不会在磁盘空间方面对付你的应用程序

678
00:33:28,973 --> 00:33:31,541
用法，你可以随时重新取回它，如果你，

679
00:33:31,610 --> 00:33:35,312
如果缓存被吹走。

680
00:33:35,380 --> 00:33:37,313
好，那么，你需要找到所有这些东西的路径。

681
00:33:37,382 --> 00:33:40,450
那么如何获得这些特殊目录的路径，以及

682
00:33:40,518 --> 00:33:44,220
然后开始构建自己的路径。

683
00:33:44,289 --> 00:33:46,622
首先要理解的是，所有

684
00:33:46,691 --> 00:33:48,591
对文件系统的访问将会发生

685
00:33:48,660 --> 00:33:51,695
两个类，或两个，两个对象。他们不是类，

686
00:33:51,764 --> 00:33:54,230
他们是结构。但一个是FileManager，

687
00:33:54,299 --> 00:33:57,466
另一个是URL。你已经了解了

688
00:33:57,535 --> 00:34:01,137
网址，因为我们使用了网址资源，

689
00:34:01,205 --> 00:34:03,840
HTTP资源以及类似的东西。那么，你也可以

690
00:34:03,908 --> 00:34:06,742
有磁盘上的本地资源的URL。

691
00:34:06,811 --> 00:34:09,078
而我们的网址本质上只是一条路径，

692
00:34:09,147 --> 00:34:13,216
该文件的Unix路径。所以，

693
00:34:13,284 --> 00:34:16,552
在你做任何事之前你要做的是找到一个

694
00:34:16,621 --> 00:34:19,556
这些沙盒目录，因为你不能只写和

695
00:34:19,625 --> 00:34:21,524
从这些沙盒目录中读取。所以

696
00:34:21,593 --> 00:34:26,362
实际上有两种方法可以获取沙盒网址，而

697
00:34:26,431 --> 00:34:28,498
我要在这里向你展示其中的一个，这是我的

698
00:34:28,567 --> 00:34:31,701
喜欢。实际上我会在演示中展示另一个。

699
00:34:31,769 --> 00:34:35,605
这是一个FileManager方法，并且FileManager是一种

700
00:34:35,674 --> 00:34:38,274
像用户默认的那样，我们使用一个共享的调用

701
00:34:38,343 --> 00:34:40,977
默认。虽然有时我们实际上想要

702
00:34:41,046 --> 00:34:43,713
通过说FileManager创建一个不同的FileManager

703
00:34:43,782 --> 00:34:45,515
开括号关闭括号，对吗？只是

704
00:34:45,584 --> 00:34:47,583
调用它的初始化程序，它不需要任何参数，我会的

705
00:34:47,652 --> 00:34:50,786
谈谈我们在这里稍后想要做什么。

706
00:34:50,855 --> 00:34:54,524
所以这个被称为DomainMask中目录的URL，

707
00:34:54,592 --> 00:34:59,162
适合创建。所以我们来看看这些参数。

708
00:34:59,231 --> 00:35:02,331
for目录是您想要的沙盒目录。

709
00:35:02,400 --> 00:35:05,067
像documentDirectory一样，cachesDirectory，

710
00:35:05,136 --> 00:35:06,970
applicationSupportDirectory。

711
00:35:07,038 --> 00:35:08,671
那就在那里

712
00:35:08,740 --> 00:35:12,242
它是通过枚举在这里指定的。和

713
00:35:12,310 --> 00:35:14,110
我向你展示了他们在底部的一些例子。

714
00:35:14,179 --> 00:35:16,879
您明显可以在文档中查找它，

715
00:35:16,948 --> 00:35:19,749
那里有什么。在domainMask中，总是

716
00:35:19,818 --> 00:35:23,185
。iOS上的.userDomainMask，因为我们拥有沙盒和

717
00:35:23,254 --> 00:35:25,155
我们只能在沙盒中看。

718
00:35:25,223 --> 00:35:28,992
在MacOS上它可能是一个共享网络域。

719
00:35:29,060 --> 00:35:31,327
它可能是系统共享域中心，但是

720
00:35:31,396 --> 00:35:34,263
在iOS上，它始终是userDomainMask。

721
00:35:34,332 --> 00:35:37,266
适当的，你总是会把它设置为零。

722
00:35:37,335 --> 00:35:39,502
基本上，如果你要替换一个文件，

723
00:35:39,571 --> 00:35:41,905
你想指定你要替换的URL

724
00:35:41,973 --> 00:35:44,840
您可以确保它与音量相同，

725
00:35:44,909 --> 00:35:48,545
你得到的URL。再一次，那种意义不大

726
00:35:48,613 --> 00:35:51,213
在大多数情况下，iOS通常只有零。和

727
00:35:51,282 --> 00:35:52,616
那么创造是一个重要的问题。

728
00:35:52,684 --> 00:35:55,251
这表示你是否要创建该沙盒，

729
00:35:55,320 --> 00:35:56,386
特殊的沙盒目录，

730
00:35:56,455 --> 00:35:59,055
因为当你的应用程序被创建时，它们并不是全部存在。

731
00:35:59,123 --> 00:36:01,424
像applicationSupport不存在，所以你必须

732
00:36:01,493 --> 00:36:03,459
确保你说create：true，就在那里。不

733
00:36:03,528 --> 00:36:05,428
伤害要说create：true，我想documentDirectory

734
00:36:05,496 --> 00:36:08,397
实际上已经为你创造，但是，不能伤害。所以

735
00:36:08,466 --> 00:36:12,068
这是你如何得到一个URL，你看到的返回值是一个URL，

736
00:36:12,136 --> 00:36:14,738
进入沙盒。现在你在沙盒中有一个URL，

737
00:36:14,806 --> 00:36:17,607
现在你可以开始写文件了。你这样做的方式

738
00:36:17,675 --> 00:36:21,478
是通过使用URL方法appendingPathComponent。

739
00:36:21,547 --> 00:36:24,213
因此添加了一个目录或文件的名称

740
00:36:24,282 --> 00:36:27,217
到该URL的末尾，您甚至可以添加文件扩展名。

741
00:36:27,285 --> 00:36:28,317
顺便说一下，这是完全合法的，

742
00:36:28,386 --> 00:36:32,689
要说appendingPathComponent food.jpg，你不需要

743
00:36:32,757 --> 00:36:34,357
在那里单独调用来做延期。

744
00:36:34,426 --> 00:36:37,460
但无论如何，你会用它来构建一个URL

745
00:36:37,529 --> 00:36:40,663
延伸过沙盒，它可以有目录和

746
00:36:40,731 --> 00:36:43,833
东东。你可以，一旦你有网址，

747
00:36:43,901 --> 00:36:47,069
你可以找出诸如FileURL或者类似的东西

748
00:36:47,138 --> 00:36:50,806
它是一个HTTP URL吗？你可以得到正确的日期。

749
00:36:50,875 --> 00:36:54,144
这是一个目录吗？这个文件有多大？

750
00:36:54,213 --> 00:36:57,714
从这个方法，URL中的resourceValues。

751
00:36:57,782 --> 00:37:00,683
而key的resourceValues需要一堆密钥，比如

752
00:37:00,752 --> 00:37:03,385
文件大小和类似的东西，并去查找它

753
00:37:03,454 --> 00:37:06,555
文件系统并返回带有这些键和字典的字典

754
00:37:06,624 --> 00:37:09,391
它找到的价值。这就是为什么价值是任何权利。

755
00:37:09,460 --> 00:37:13,363
它可能是一个数字，它可能是一个字符串，类似的东西。

756
00:37:13,431 --> 00:37:15,799
所以你可以在那里找到很多你的文件。

757
00:37:17,235 --> 00:37:18,835
你如何读写文件？

758
00:37:18,904 --> 00:37:21,738
我们用数据做到这一点。你已经看到了这一点，

759
00:37:21,806 --> 00:37:26,075
其实。我们使用数据从互联网上读取文件，

760
00:37:26,144 --> 00:37:29,078
与一个HTTP URL。当然你可以用FileURL来做到这一点

761
00:37:29,147 --> 00:37:32,582
以及。我们在做时没有使用这些选项，

762
00:37:32,651 --> 00:37:34,083
因为我们使用了默认选项，

763
00:37:34,152 --> 00:37:36,753
你大多会这样做。但是有一些阅读选项

764
00:37:36,822 --> 00:37:38,921
你可以去看看。并写入文件，

765
00:37:38,990 --> 00:37:41,724
你会发送这个数据，写（到url。

766
00:37:41,792 --> 00:37:45,061
它也有你可以看看的选项。以便

767
00:37:45,129 --> 00:37:48,197
是我们如何读写文件系统。我们有

768
00:37:48,266 --> 00:37:51,401
一个数据，可能是我们通过归档到JSON或

769
00:37:51,469 --> 00:37:54,137
无论与他们的存档者，我们只是阅读和

770
00:37:54,206 --> 00:37:57,606
用这两种方法从文件系统中写入。所以

771
00:37:57,675 --> 00:37:59,909
你可以看到它只是获取正确的URL，

772
00:37:59,978 --> 00:38:00,877
然后它很容易阅读和

773
00:38:00,946 --> 00:38:04,213
写。我想多谈一点

774
00:38:04,282 --> 00:38:07,484
文件管理器。除了正式之外，你还可以做很多其他的事情

775
00:38:07,552 --> 00:38:09,385
给你一个沙盒中的东西的网址。

776
00:38:09,454 --> 00:38:12,355
例如，它可以告诉你文件是否存在，

777
00:38:12,423 --> 00:38:15,658
在文件系统中。它可以移动文件，复制文件，

778
00:38:15,726 --> 00:38:19,028
创建目录，枚举目录，删除文件，

779
00:38:19,097 --> 00:38:20,897
所有这些，都在FileManager中。

780
00:38:20,966 --> 00:38:23,433
FileManager中可能有上百种方法

781
00:38:23,502 --> 00:38:26,936
这样做。 FileManager也有一个委托。和

782
00:38:27,005 --> 00:38:30,206
这个委托，几乎所有的方法都是，应该这样做。

783
00:38:30,275 --> 00:38:33,142
我应该允许打开这个文件吗？我应该允许你吗？

784
00:38:33,211 --> 00:38:35,044
移动这个文件。他们是那种应该的东西，所以

785
00:38:35,113 --> 00:38:37,546
委托可以控制FileManager是否被允许

786
00:38:37,615 --> 00:38:41,917
做事。这和FileManager是线程的事实

787
00:38:41,986 --> 00:38:45,254
安全，但只在FileManager的一个实例中。

788
00:38:45,323 --> 00:38:47,757
所以如果你在另一个线程上有一个FileManager

789
00:38:47,826 --> 00:38:49,592
主线程，它是线程安全的，但

790
00:38:49,661 --> 00:38:52,862
仅当该文件管理器在该线程上创建时才有效。

791
00:38:52,931 --> 00:38:55,731
我以前给你看过的filemanager.default，

792
00:38:55,800 --> 00:38:57,967
这是主线之一。所以你不想使用

793
00:38:58,036 --> 00:39:00,470
filemanager.default在任何线程中，但主要

794
00:39:00,538 --> 00:39:04,006
线。当然，如果你要设置一个代表

795
00:39:04,075 --> 00:39:06,175
FileManager，你可能不想设置委托

796
00:39:06,244 --> 00:39:09,178
filemanager.default。这是一种共享的FileManager

797
00:39:09,247 --> 00:39:11,948
每个人都在主线程中使用。所以

798
00:39:12,016 --> 00:39:15,384
在这种情况下你可能想创建一个FileManager。

799
00:39:15,453 --> 00:39:18,421
多个文件管理员知道如何不让对方

800
00:39:18,490 --> 00:39:22,758
脚趾。好吧？所以我们已经学会了简单的一点

801
00:39:22,827 --> 00:39:25,929
数据库，这是用户默认的东西

802
00:39:25,997 --> 00:39:28,197
我们可以在那里存储属性清单，这只是为了

803
00:39:28,266 --> 00:39:31,767
设置和类似的东西。然后我们了解了如何

804
00:39:31,836 --> 00:39:34,570
做归档，功能更强大。我们可以存储其他

805
00:39:34,639 --> 00:39:37,006
事情和Swift大多只是为我们做代码，

806
00:39:37,075 --> 00:39:40,843
但有时我们可以参与，如果我们想。和

807
00:39:40,912 --> 00:39:44,080
它生成数据，然后我们学习如何获取这些数据，

808
00:39:44,148 --> 00:39:46,782
与JSON或任何其中，并将它们存储在文件中

809
00:39:46,851 --> 00:39:49,852
系统，使用FileManager和URL。现在我要谈谈

810
00:39:49,921 --> 00:39:53,022
下一个持久性事物是核心数据。所以

811
00:39:53,091 --> 00:39:54,290
核心数据是如果你有

812
00:39:54,359 --> 00:39:57,159
大量的数据，你需要搜索它。

813
00:39:57,228 --> 00:39:59,228
换句话说，你需要一个数据库。

814
00:39:59,297 --> 00:40:03,566
所以核心数据本质上是一个SQL数据库。有人反对

815
00:40:03,635 --> 00:40:06,902
面向API的API。所以你与这个数据库交互。

816
00:40:06,971 --> 00:40:10,272
它看起来像Swift对象，但在幕后

817
00:40:10,341 --> 00:40:13,343
Swift对象实际上是在一个数据库中，一个SQL数据库。

818
00:40:13,411 --> 00:40:14,811
现在核心数据非常强大

819
00:40:14,879 --> 00:40:17,480
实际上可能具有与SQL不同的后端，

820
00:40:17,549 --> 00:40:21,951
但大多数情况下，我们使用SQL数据的后端。所以

821
00:40:22,020 --> 00:40:24,987
这就是Core Data的功能，它非常高效，

822
00:40:25,056 --> 00:40:27,189
美丽的面向对象。

823
00:40:27,258 --> 00:40:28,358
我现在不可以，

824
00:40:28,426 --> 00:40:30,593
我没有时间在这个季度谈论它，但是

825
00:40:30,662 --> 00:40:33,796
幸运的是，我上个季度花了整整一周的时间。所以

826
00:40:33,865 --> 00:40:37,032
你可以去看看iTunes U并看到两个讲座，

827
00:40:37,101 --> 00:40:38,267
它并没有真正改变那么多

828
00:40:38,336 --> 00:40:41,103
iOS 11，所以它会很好。这是一个伟大的

829
00:40:41,172 --> 00:40:43,739
没有涵盖在您的最终项目的讲座功能中，

830
00:40:43,808 --> 00:40:46,042
因为我不会在这个讲座中介绍它。

831
00:40:46,111 --> 00:40:47,943
我会给你一个概述。但

832
00:40:48,012 --> 00:40:48,944
你可以轻松回去

833
00:40:49,013 --> 00:40:50,446
观看我最后一次演讲，

834
00:40:50,515 --> 00:40:52,548
了解一切，并准备好去。所以

835
00:40:52,617 --> 00:40:55,251
我要在这里做的只是对它的简要概述。

836
00:40:55,320 --> 00:40:56,886
如果你想要详细的核心数据，和

837
00:40:56,954 --> 00:40:59,522
这对你的最终项目来说是一个很棒的功能，

838
00:40:59,591 --> 00:41:03,493
相信我。去检查一下iTunes U.好的，

839
00:41:03,561 --> 00:41:07,263
所以它是这种面向对象编程的一种方式

840
00:41:07,331 --> 00:41:11,266
层与后端SQL。我们怎么做，我们怎么做

841
00:41:11,335 --> 00:41:14,770
匹配这两件事？那么我们实际上有一个工具

842
00:41:14,839 --> 00:41:18,207
在Xcode里面是一个可视化的映射器。你建立你所有的

843
00:41:18,276 --> 00:41:21,611
物体和所有的变量基本上都在这个映射器中。

844
00:41:21,680 --> 00:41:23,946
映射器用来弄清楚如何做到这一点

845
00:41:24,015 --> 00:41:27,783
为您进行向前映射，它只是自动发生。

846
00:41:27,852 --> 00:41:30,252
所以如果你有谁知道数据库，数据库

847
00:41:30,321 --> 00:41:33,890
有桌子。他们在表中有记录的行，

848
00:41:33,959 --> 00:41:36,059
他们有专栏是这些领域。

849
00:41:36,127 --> 00:41:38,061
这仍然发生在幕后，但是

850
00:41:38,129 --> 00:41:40,263
当你编程时你没有看到这些，

851
00:41:40,331 --> 00:41:42,331
因为你使用的是面向对象的API。

852
00:41:42,400 --> 00:41:45,401
所以这就是Visual Mapper的样子，对，

853
00:41:45,470 --> 00:41:48,738
它在Xcode这里。在这里我有一些对象，

854
00:41:48,807 --> 00:41:50,773
推文和Twitter用户。

855
00:41:50,842 --> 00:41:53,042
这些将映射到我的代码中的对象

856
00:41:53,111 --> 00:41:55,811
数据库中的表。然后我们得到了像这样的领域

857
00:41:55,880 --> 00:41:57,380
推文有一个创建日期，

858
00:41:57,448 --> 00:42:01,017
推文的唯一标识符，推文的文本。

859
00:42:01,085 --> 00:42:03,819
它甚至有一个变种，这是指向高音扬声器

860
00:42:03,888 --> 00:42:06,723
通过Twitter用户和Twitter用户端，

861
00:42:06,791 --> 00:42:10,059
它有一个叫tweets的变种。哪一点会回来，

862
00:42:10,127 --> 00:42:14,229
这实际上是一组推文对象。所以

863
00:42:14,298 --> 00:42:17,332
核心数据正在使用该映射。

864
00:42:17,401 --> 00:42:18,467
在物体上做出

865
00:42:18,536 --> 00:42:20,002
所有这些东西看起来都像对象一样

866
00:42:20,071 --> 00:42:21,537
在另一边建立表和

867
00:42:21,606 --> 00:42:25,775
数据库中的行。所以，让我们来看看我们，怎么样

868
00:42:25,844 --> 00:42:27,943
看起来像在代码中这样做，所以你有一个想法。

869
00:42:28,012 --> 00:42:30,112
再次，我没有试图教你如何在这里做核心数据。

870
00:42:30,181 --> 00:42:32,581
这是给你一个看起来像什么的概念。

871
00:42:32,650 --> 00:42:34,684
关于核心数据理解的最重要的事情，

872
00:42:34,753 --> 00:42:37,219
是我们使用代码访问它的全部内容

873
00:42:37,288 --> 00:42:41,190
一个NSManagedObjectContext。所以这个环境是关键的

874
00:42:41,259 --> 00:42:43,693
有两种方法可以获得这种背景。一，

875
00:42:43,762 --> 00:42:45,261
你知道我们什么时候创建我们的项目？

876
00:42:45,330 --> 00:42:46,662
那里有那么一小会儿，那就说，

877
00:42:46,731 --> 00:42:49,899
使用核心数据，你还记得吗？所以你可以打开它

878
00:42:49,968 --> 00:42:53,335
然后你会在你的应用代理中获得一个方法，我们就是这样

879
00:42:53,404 --> 00:42:55,304
没有谈过。我们将在下周讨论这个问题，

880
00:42:55,373 --> 00:42:57,340
这是给你的背景。

881
00:42:57,409 --> 00:42:59,041
它实际上是一个给你上下文的变种。

882
00:42:59,110 --> 00:43:02,078
所以这是一种方法，另一种方法是创建一个子类，

883
00:43:02,146 --> 00:43:04,947
它使用UIDocument的一个子类，我会这样做

884
00:43:05,015 --> 00:43:09,385
今天晚些时候再谈。这将给你的背景下，

885
00:43:09,453 --> 00:43:12,488
而Uidocument是一种抽象文件的方式。

886
00:43:12,556 --> 00:43:14,523
所以这是查看整个数据库的一种方式，

887
00:43:14,592 --> 00:43:18,527
就像一个大文件一样。这可能是一个巨大的文件

888
00:43:18,596 --> 00:43:21,230
因为那些数据库可能很大。但

889
00:43:21,299 --> 00:43:23,099
这是获得背景的两种方式。

890
00:43:23,167 --> 00:43:25,768
一旦你掌握了两个，一个背景，

891
00:43:25,836 --> 00:43:28,604
现在你可以开始在数据库中完成所有这些访问

892
00:43:28,672 --> 00:43:30,940
看起来像一个物体。这就是这个样子。

893
00:43:31,008 --> 00:43:35,344
例如，在这里，我创建了一条推文。唯一的

894
00:43:35,412 --> 00:43:38,314
对于初始值设定项的参数有上下文，

895
00:43:38,382 --> 00:43:40,817
它告诉，基本上是数据库把它放进去。但是

896
00:43:40,885 --> 00:43:42,785
那么如果我想设置推文的文本，

897
00:43:42,854 --> 00:43:45,221
我只是说tweet.text，它看起来就像Swift一样，

898
00:43:45,289 --> 00:43:49,058
tweet.created等于一个日期。是的，我甚至可以创建乔，

899
00:43:49,126 --> 00:43:51,927
一个推特用户在与推文相同的上下文中

900
00:43:51,996 --> 00:43:56,899
说tweet.tweeter =乔。我甚至可以去tweet.tweeter.name =

901
00:43:56,967 --> 00:44:00,702
换句话说，“Joe Schmo”使用Swift符号去

902
00:44:00,771 --> 00:44:03,672
通过我链接到的对象。所以

903
00:44:03,741 --> 00:44:08,377
它看起来和Swift完全一样。我也可以

904
00:44:08,446 --> 00:44:12,181
通过请求上下文删除它们来删除对象。

905
00:44:12,250 --> 00:44:15,050
我所做的更改实际上是自动保存的

906
00:44:15,119 --> 00:44:18,587
我使用该UIDocument方法来获取上下文。

907
00:44:18,656 --> 00:44:21,357
但是，如果我使用“使用核心数据”开关来执行此操作，

908
00:44:21,425 --> 00:44:24,360
那么我必须保存它。关于保存的唯一的事情是

909
00:44:24,428 --> 00:44:25,994
它可以抛出。你可以想象，

910
00:44:26,063 --> 00:44:28,364
如果我将这些东西保存到SQL数据库中，

911
00:44:28,433 --> 00:44:30,966
我可能会遇到SQL错误或某种文件系统已满或

912
00:44:31,035 --> 00:44:34,203
像这样的东西。所以如果不是的话，我必须抓住错误

913
00:44:34,271 --> 00:44:37,907
会做基于UIDocument的自动保存。现在怎么样

914
00:44:37,976 --> 00:44:41,143
在那里搜索对象，推文和Twitter用户。

915
00:44:41,212 --> 00:44:42,912
所以在这里我要去寻找

916
00:44:42,981 --> 00:44:47,050
一些推特用户在过去24小时内发了推文。

917
00:44:47,118 --> 00:44:49,418
所以首先，我要求TwitterUser类

918
00:44:49,487 --> 00:44:51,987
取回请求。你看到我的第一行

919
00:44:52,056 --> 00:44:54,089
说TwitterUser.fetchRequest？

920
00:44:54,158 --> 00:44:57,093
然后，这个获取请求，我设置了一个谓词，看看，

921
00:44:57,162 --> 00:44:59,962
NSPredicate格式？谓词是一种方式

922
00:45:00,031 --> 00:45:04,299
在文本中指定您想要的搜索。这不太像

923
00:45:04,368 --> 00:45:08,971
SQL，但它非常适合英语。所以在这里我想要任何

924
00:45:09,040 --> 00:45:13,809
在24小时前创建的推文。好的

925
00:45:13,877 --> 00:45:16,478
因为昨天的cuz是我在前一行做出的一个变种

926
00:45:16,547 --> 00:45:21,350
是timeIntervalSinceNow减24小时。所以

927
00:45:21,418 --> 00:45:22,651
我以这种方式描述了我的搜索。

928
00:45:22,720 --> 00:45:26,755
我也可以描述我希望如何排序结果。我在这里

929
00:45:26,824 --> 00:45:30,225
会按TwitterUser的名称排序。和

930
00:45:30,294 --> 00:45:33,796
那么我只是问上下文请去拿那些东西

931
00:45:33,864 --> 00:45:37,533
与之相匹配。它给了我一些这些

932
00:45:37,602 --> 00:45:40,402
正如我们所预料的那样。如果没有，如果没有

933
00:45:40,471 --> 00:45:43,739
匹配，然后我会得到一个空数组。如果出现错误，

934
00:45:43,807 --> 00:45:46,775
就像我说的谓词有一个语法错误，

935
00:45:46,844 --> 00:45:50,646
就像任何被创造出来的双子一样，那么这就会被抛弃。

936
00:45:50,715 --> 00:45:53,282
我必须抓住它并弄清楚。

937
00:45:53,350 --> 00:45:55,651
但是，否则它会以对象数组的形式返回。

938
00:45:55,720 --> 00:45:58,220
所以查询数据库也很容易，而且是

939
00:45:58,289 --> 00:46:00,823
使用SQL来执行该搜索，因此它非常高效。

940
00:46:00,891 --> 00:46:04,794
而且，即使是很大的价值回来，它也是有效的

941
00:46:04,862 --> 00:46:07,363
关于这一点。我不能谈论它是如何做到的，

942
00:46:07,432 --> 00:46:10,032
但即使巨大的事情也是非常有效的，

943
00:46:10,101 --> 00:46:13,803
返回。核心数据可以做得更多。

944
00:46:13,872 --> 00:46:15,338
它对多线程有很大的支持，

945
00:46:15,406 --> 00:46:17,773
它与UITableView有非常紧密的结合，

946
00:46:17,842 --> 00:46:18,641
如你所想。

947
00:46:18,710 --> 00:46:21,010
你知道，你经常可能需要这些信息

948
00:46:21,079 --> 00:46:23,812
数据库出现在表中。你甚至可以设置它

949
00:46:23,881 --> 00:46:27,016
所以一张表总是显示一个提取请求的结果，

950
00:46:27,084 --> 00:46:29,151
即使数据库从底下改变。

951
00:46:29,219 --> 00:46:31,621
它只是自动更新表和自动，

952
00:46:31,689 --> 00:46:33,656
你不必在代码中做任何事情。

953
00:46:33,725 --> 00:46:36,358
只要说出你想要关联的提取请求即可

954
00:46:36,427 --> 00:46:39,128
桌子。它有很多好的数据库，

955
00:46:39,196 --> 00:46:42,799
像乐观锁定和回滚更改等。

956
00:46:42,867 --> 00:46:46,468
你可以很容易地用这个来重做撤销重做，

957
00:46:46,537 --> 00:46:49,905
与核心数据。所以我，

958
00:46:49,973 --> 00:46:51,874
我不能介绍这些，但我只是想给你

959
00:46:51,943 --> 00:46:53,709
核心数据可以做什么的一种想法，

960
00:46:53,778 --> 00:46:56,645
因为它是iOS中非常强大的框架。所以看看

961
00:46:56,713 --> 00:47:00,316
我上一季度的iTunes U想出了如何做到这一点。

962
00:47:00,385 --> 00:47:03,452
我做了一个全面的演示整个交易。好，如此

963
00:47:03,521 --> 00:47:06,688
下一个话题也是本周我无法谈论的话题。

964
00:47:06,757 --> 00:47:10,559
但在此之前，我也在这个季度做了一周的时间。

965
00:47:10,628 --> 00:47:12,361
所以如果你再回到iTunes U上，

966
00:47:12,429 --> 00:47:14,997
而不是那个季度我做Cloud Kit的Core Data，

967
00:47:15,065 --> 00:47:17,866
而不是我们这个季度他们中的任何一个

968
00:47:17,935 --> 00:47:19,602
文档浏览器。所以

969
00:47:19,670 --> 00:47:22,137
每个季度我都喜欢花一个星期的时间来坚持，并且

970
00:47:22,206 --> 00:47:25,374
我每季度都会做一件不同的事情。这一季我是

971
00:47:25,443 --> 00:47:29,344
做文档，两个季度之前我做了Cloud Kit。所以

972
00:47:29,413 --> 00:47:32,548
云套件是什么？云套件也是一个数据库，

973
00:47:32,617 --> 00:47:35,384
就像Core Data一样，但它不是SQL

974
00:47:35,452 --> 00:47:38,253
数据库。这是一个非常简单的数据库，它只是

975
00:47:38,322 --> 00:47:40,823
对象的类型和这些对象中的属性。

976
00:47:40,892 --> 00:47:43,592
你可以查询他们，但他们是简单的查询。和

977
00:47:43,660 --> 00:47:46,963
事情之间的关系必须非常简单

978
00:47:47,031 --> 00:47:50,165
直截了当。但令人难以置信的是，

979
00:47:50,234 --> 00:47:53,135
它在网络上。所以这是一个网络数据库

980
00:47:53,204 --> 00:47:56,238
核心数据，您可以在网络上拥有数据库文件。

981
00:47:56,306 --> 00:47:59,007
但是当你开始访问它时，它必须带上这个文件

982
00:47:59,076 --> 00:48:01,476
到你的本地机器因为它是一个本地SQL。

983
00:48:01,545 --> 00:48:04,046
数据库的东西，而云套件

984
00:48:04,115 --> 00:48:06,315
实际上当您提出搜索请求时

985
00:48:06,384 --> 00:48:09,351
一些东西，它通过互联网向iCloud和

986
00:48:09,419 --> 00:48:12,822
说搜索该数据库并将结果发回。所以

987
00:48:12,890 --> 00:48:17,326
Cloud Kit的API完全是异步的，正确的，

988
00:48:17,395 --> 00:48:19,528
你提出请求，然后你提供一个闭包，并且

989
00:48:19,597 --> 00:48:22,531
它在得到结果时会在以后回拨你。所以

990
00:48:22,600 --> 00:48:25,167
这需要一定的体贴

991
00:48:25,236 --> 00:48:27,769
在编程时可能需要很长的时间

992
00:48:27,838 --> 00:48:30,472
像那样的时间，好吧。你已经看到了这一点

993
00:48:30,541 --> 00:48:33,475
希望在你的作业中使用多线程，但是

994
00:48:33,544 --> 00:48:36,578
它在Cloud Kit中有所放大。现在不是，

995
00:48:36,647 --> 00:48:39,180
这并不坏，它只是要求你以某种方式思考

996
00:48:39,249 --> 00:48:41,383
当你在编程时。所以

997
00:48:41,452 --> 00:48:42,985
Cloud Kit的重要组件，

998
00:48:43,053 --> 00:48:45,454
你有记录类型，这就像类。

999
00:48:45,523 --> 00:48:48,357
你有领域，就像在课堂上的var，

1000
00:48:48,426 --> 00:48:51,560
记录，这是一个类的实例。这是一个参考

1001
00:48:51,629 --> 00:48:55,197
像一个指向另一个类的指针，你有数据库和

1002
00:48:55,266 --> 00:48:58,033
数据库内的区域。你有容器包含

1003
00:48:58,102 --> 00:49:01,503
数据库。你有查询，就像一个提取请求，

1004
00:49:01,572 --> 00:49:04,373
核心数据中的一点点。它其实非常相似

1005
00:49:04,442 --> 00:49:05,774
到Core Data中的获取请求。和

1006
00:49:05,843 --> 00:49:09,244
那么你有订阅这是一个奇妙的功能。

1007
00:49:09,313 --> 00:49:12,747
就是说，你做了一个查询，然后把它提供给服务器，并且

1008
00:49:12,816 --> 00:49:14,984
你说任何时候数据库的变化，

1009
00:49:15,052 --> 00:49:17,019
这样这个查询就会改变，

1010
00:49:17,088 --> 00:49:20,222
向我发送推送通知。你们都知道推动什么？

1011
00:49:20,291 --> 00:49:23,592
谁知道推送通知是什么？所以

1012
00:49:23,661 --> 00:49:27,162
不是每个人，而是大多数人。所以推送通知就是

1013
00:49:27,231 --> 00:49:29,899
一些涉及到你的应用的东西，它甚至会被唤醒

1014
00:49:29,967 --> 00:49:33,002
你的应用程序，并说，哇，一些信息已经到达。

1015
00:49:33,070 --> 00:49:35,071
这是最酷的，即使不是最酷的，

1016
00:49:35,139 --> 00:49:37,672
云工具包中的功能，是你会得到通知

1017
00:49:37,741 --> 00:49:39,909
当数据库以您所关心的方式进行更改时。

1018
00:49:39,977 --> 00:49:42,978
这些被称为订阅。但

1019
00:49:43,046 --> 00:49:44,646
你会看到，我会告诉你一些代码

1020
00:49:44,715 --> 00:49:47,749
云套件。它不像Core Data那样看起来不像

1021
00:49:47,818 --> 00:49:49,301
像代码中的Swift一样。你有更多的函数调用和

1022
00:49:49,302 --> 00:49:50,785
尽可能多

1023
00:49:50,854 --> 00:49:54,223
东东。现在要使用Cloud Kit，您必须打开iCloud。

1024
00:49:54,292 --> 00:49:56,591
你这样做，就像你必须打开的很多东西一样，

1025
00:49:56,660 --> 00:49:58,660
像推送通知和其他东西，

1026
00:49:58,729 --> 00:50:01,797
在项目设置的功能部分。

1027
00:50:01,865 --> 00:50:03,832
所以你会去那里的能力，和

1028
00:50:03,901 --> 00:50:07,569
你会为iCloud打开这个开关。和

1029
00:50:07,638 --> 00:50:10,338
那么你会打开这个小小的云工具包开关

1030
00:50:10,407 --> 00:50:12,808
在这里，这将使这种能力成为可能

1031
00:50:12,877 --> 00:50:14,977
你使用Cloud Kit。如果你不打开它，

1032
00:50:15,045 --> 00:50:17,212
你将无法使用它。当你这样做时，

1033
00:50:17,281 --> 00:50:19,848
底部会有这个小按钮

1034
00:50:19,917 --> 00:50:22,651
称为云套件仪表板。此云工具包控制面板，

1035
00:50:22,720 --> 00:50:25,253
让我们按下它，看看它的样子。

1036
00:50:25,322 --> 00:50:27,489
它会去到网络上的这个地方，它会在那里展示

1037
00:50:27,558 --> 00:50:30,726
你的数据库模式。所以你所有的记录类型，

1038
00:50:30,795 --> 00:50:33,061
和所有的小田野，不仅如此，而且

1039
00:50:33,130 --> 00:50:36,565
实际的数据。一旦你发货，它不是很有用

1040
00:50:36,634 --> 00:50:38,767
你的应用程序，因为你会有成千上万的用户

1041
00:50:38,835 --> 00:50:40,869
产生这么多的数据你甚至无法看到它。

1042
00:50:40,938 --> 00:50:43,005
但是在开发中，这真的很棒，

1043
00:50:43,074 --> 00:50:45,708
因为你创建了一个对象，你可以看看它

1044
00:50:45,776 --> 00:50:48,410
确保它在那里，它有正确的数据或

1045
00:50:48,479 --> 00:50:53,014
随你。所以这个仪表板是你如何在你的工作

1046
00:50:53,083 --> 00:50:57,519
架构。它不像核心数据模式

1047
00:50:57,588 --> 00:51:02,057
编辑的事情。由于在Cloud Kit中与Core Data不同，

1048
00:51:02,126 --> 00:51:03,859
它随着你的建立而构建模式。

1049
00:51:03,927 --> 00:51:07,729
只要你说，如果你说创建这个名字的对象，

1050
00:51:07,798 --> 00:51:11,433
它只会去创造它。它是，它会在飞行中完成它，

1051
00:51:11,502 --> 00:51:14,269
你不必去和像你一样预先构建你的模式

1052
00:51:14,338 --> 00:51:17,473
在核心数据中做。这就是所说的，动态的

1053
00:51:17,541 --> 00:51:19,842
架构创建。而这只在开发过程中才起作用，

1054
00:51:19,911 --> 00:51:22,277
明显。然后，一旦你将它发布给你的用户

1055
00:51:22,346 --> 00:51:26,548
它不会像你一样创建类和领域

1056
00:51:26,616 --> 00:51:28,717
访问它们。但是你正在发展，这真的很好，

1057
00:51:28,786 --> 00:51:31,353
开始编写代码并且拥有它真的很容易

1058
00:51:31,422 --> 00:51:34,990
它开始构建与该代码相匹配的数据库。

1059
00:51:35,059 --> 00:51:36,725
好的，所以这是代码的样子。你是

1060
00:51:36,794 --> 00:51:39,594
会发现它看起来不像Core Data那么好。

1061
00:51:39,663 --> 00:51:42,330
所以你必须得到一个数据库，所以通常，

1062
00:51:42,399 --> 00:51:45,267
你会使用公共或私有云数据库。

1063
00:51:45,336 --> 00:51:48,737
然后创建一条推文，你会看到你会说CKRecord，

1064
00:51:48,805 --> 00:51:51,907
CK是Cloud Kit。 CK记录名称鸣叫会

1065
00:51:51,975 --> 00:51:55,077
如果没有，则自动将该表添加到数据库

1066
00:51:55,146 --> 00:51:58,180
存在。然后你会说推文subquote

1067
00:51:58,249 --> 00:52:01,750
文本=文本。然后有一个高音喇叭，你必须说

1068
00:52:01,819 --> 00:52:05,520
CKRecord TwitterUser。然后说tweet sub tweeter =

1069
00:52:05,589 --> 00:52:10,058
用引用记录高音扬声器的CKReference删除这个

1070
00:52:10,127 --> 00:52:12,861
事情，如果它的东西被删除。所以你看，

1071
00:52:12,930 --> 00:52:14,530
它更冗长而不是，

1072
00:52:14,598 --> 00:52:18,233
看起来不像斯威夫特，要做所有这些东西。和

1073
00:52:18,302 --> 00:52:20,802
当然，像保存这样的东西是异步的，对。

1074
00:52:20,871 --> 00:52:22,938
所以，我想在数据库中保存这条推文。

1075
00:52:23,007 --> 00:52:25,874
那么，它将会，我必须提供这种闭包，

1076
00:52:25,943 --> 00:52:28,477
一旦它完成或它会回掉给我

1077
00:52:28,545 --> 00:52:32,480
如果有错误。现在这个网络编程，

1078
00:52:32,549 --> 00:52:35,350
总是有很多错误处理。所以

1079
00:52:35,419 --> 00:52:37,753
如果你们没有做网络编程，

1080
00:52:37,822 --> 00:52:40,455
习惯了它，Cloud Kit中有29个不同的错误

1081
00:52:40,524 --> 00:52:44,459
错误。并不是所有的人都可以在每次手术中发生，但是

1082
00:52:44,528 --> 00:52:47,796
他们中的很多人都可以。例如，我已经显示错误

1083
00:52:47,865 --> 00:52:50,598
这里没有认证。因为它是Cloud Kit，

1084
00:52:50,667 --> 00:52:53,068
如果用户未在设备上登录到iCloud，

1085
00:52:53,136 --> 00:52:55,070
那么它不会知道他们是谁，所以

1086
00:52:55,139 --> 00:52:57,406
它不会工作。所以你可以得到这个错误。

1087
00:52:57,475 --> 00:53:00,842
你可以得到网络超时，各种东西。所以

1088
00:53:00,911 --> 00:53:04,246
这只是一种不同的计划方式，你必须这样做

1089
00:53:04,315 --> 00:53:07,349
习惯它，这是异步编程。

1090
00:53:07,418 --> 00:53:10,385
这是一个查询的样子。这是模拟的

1091
00:53:10,454 --> 00:53:14,089
取回请求。您仍然使用NSPredicate。所以

1092
00:53:14,158 --> 00:53:17,259
像文本包含一些searchString或

1093
00:53:17,328 --> 00:53:21,329
随你。但谓词不能太复杂

1094
00:53:21,398 --> 00:53:24,399
如核心数据。他们必须相当直接

1095
00:53:24,468 --> 00:53:26,635
谓词。但是，然后你创建一个CKQuery，

1096
00:53:26,704 --> 00:53:29,137
这是一个云工具包查询，然后你说执行和

1097
00:53:29,206 --> 00:53:32,173
当然它是异步的。所以你提供了一个闭包，并且

1098
00:53:32,242 --> 00:53:35,511
它会将您的查询结果回调给您。

1099
00:53:35,579 --> 00:53:38,180
所以这就是查询，查询的样子。

1100
00:53:38,249 --> 00:53:41,717
再次，非常简单，但异步和

1101
00:53:41,785 --> 00:53:45,353
没有Core Data那么强大。常规查询或

1102
00:53:45,422 --> 00:53:48,356
订阅，我无法真正向您展示该代码的外观

1103
00:53:48,425 --> 00:53:51,526
就像因为我没有教你推送通知。

1104
00:53:51,595 --> 00:53:53,895
推送通知并不困难。

1105
00:53:53,964 --> 00:53:57,599
有一个叫做UserNotifications的整个框架。

1106
00:53:57,668 --> 00:53:59,668
但是我没有任何意义向你展示它是什么

1107
00:53:59,737 --> 00:54:01,804
看起来像我没有教你那样。

1108
00:54:01,872 --> 00:54:04,806
所以我们稍后再讨论。也许我会试着展示

1109
00:54:04,875 --> 00:54:08,543
Cloud Kit的示例，推送通知正在发生，

1110
00:54:08,612 --> 00:54:13,248
当我们覆盖那个。好，现在，下一个主题。

1111
00:54:13,316 --> 00:54:16,885
所以这是我将在本周花费的主题，

1112
00:54:16,954 --> 00:54:19,555
这是基于文档的应用程序。所以

1113
00:54:19,623 --> 00:54:23,325
当你坚持的东西时，这是持久的

1114
00:54:23,394 --> 00:54:26,561
被用户视为文档。

1115
00:54:26,630 --> 00:54:30,532
例如，表情符艺术。我创建了一个美丽的表情符号艺术

1116
00:54:30,601 --> 00:54:34,903
文件，把我的鬼和我的自行车放在那里，我的蜜蜂。

1117
00:54:34,972 --> 00:54:37,972
然后我想保存一个文件，然后用户

1118
00:54:38,041 --> 00:54:41,042
会去创建一个不同的与其他图像和

1119
00:54:41,111 --> 00:54:42,477
那里有一些其他的东西。

1120
00:54:42,546 --> 00:54:44,045
他们想把它保存为一个不同的文档。

1121
00:54:44,114 --> 00:54:45,914
所以他们，你看他们如何看待他们作为文件。

1122
00:54:45,982 --> 00:54:47,849
与你的图像库作业一样的东西。

1123
00:54:47,918 --> 00:54:49,751
你有一个你建立的图像库，和

1124
00:54:49,819 --> 00:54:52,287
那么也许你想有一个不同的图像库

1125
00:54:52,356 --> 00:54:52,954
这是相关的

1126
00:54:53,023 --> 00:54:56,191
另一种方式。这些被视为文件。所以

1127
00:54:56,260 --> 00:55:00,728
我们将讨论iOS API的机制

1128
00:55:00,797 --> 00:55:04,632
存储很棒的文档。它需要

1129
00:55:04,701 --> 00:55:07,903
绝对关心你想用文件做的一切，

1130
00:55:07,971 --> 00:55:08,703
你必须努力，

1131
00:55:08,772 --> 00:55:12,841
几乎没有任何工作可以使它工作。你所要做的就是

1132
00:55:12,909 --> 00:55:16,177
实际上将您的模型转换为数据并返回。

1133
00:55:16,246 --> 00:55:20,381
就是这样，它管理绝对一切。所以

1134
00:55:20,450 --> 00:55:22,050
当我说它管理一切时，

1135
00:55:22,118 --> 00:55:26,754
我的意思是？那么，开放，写作，阅读，关闭

1136
00:55:26,823 --> 00:55:31,126
异步的文档文件全部由UIDocument处理。

1137
00:55:31,195 --> 00:55:36,297
现在为什么我想让我的文档异步打开？

1138
00:55:36,366 --> 00:55:39,534
为什么我在乎？我的文件不大，不会

1139
00:55:39,603 --> 00:55:41,269
花费很多时间将它们写入文件系统，

1140
00:55:41,338 --> 00:55:45,840
谁在乎？那么，UIDocument支持保存你的文件

1141
00:55:45,909 --> 00:55:51,646
iCloud驱动器。在网络上，这可能会更慢。所以，

1142
00:55:51,715 --> 00:55:54,415
如果您必须编写代码以将其保存到iCloud驱动器，

1143
00:55:54,484 --> 00:55:57,185
你确实很伤心，因为你必须全力以赴

1144
00:55:57,254 --> 00:56:00,054
该网络代码来弄清楚我是如何得到这个东西的

1145
00:56:00,123 --> 00:56:02,523
通过网络？它失败了吗？它是网络吗？

1146
00:56:02,592 --> 00:56:04,292
而这种方式你使用UIDocument，

1147
00:56:04,361 --> 00:56:07,495
你只是说保存。它完成后会给你回调。

1148
00:56:07,564 --> 00:56:09,465
这都是异步的，它很棒。

1149
00:56:11,034 --> 00:56:14,135
它也会自动保存你的文档。然后再次，

1150
00:56:14,204 --> 00:56:16,871
我告诉过你为你的核心获得背景的方法之一

1151
00:56:16,940 --> 00:56:19,841
数据是创建一个UI托管文档，它的名称，

1152
00:56:19,910 --> 00:56:23,044
这是核心数据库的子类UIDocument，和

1153
00:56:23,113 --> 00:56:25,547
它会自动保存它。那么同样的事情发生在你的身上。

1154
00:56:25,616 --> 00:56:27,682
您的文件可以自动保存，

1155
00:56:27,751 --> 00:56:29,651
你甚至不需要保存它们。和

1156
00:56:29,720 --> 00:56:32,487
关于UIDocument最重要的是这个

1157
00:56:32,556 --> 00:56:36,391
它集成了iOS 11的文件应用程序和

1158
00:56:36,460 --> 00:56:38,059
文档浏览器。我们会看到，

1159
00:56:38,128 --> 00:56:41,029
如果我们今天得到它，希望我们会，

1160
00:56:41,098 --> 00:56:44,666
这意味着很多，这是非常强大的。所以

1161
00:56:44,735 --> 00:56:47,969
你需要做什么使UIDocument工作？

1162
00:56:48,038 --> 00:56:51,240
你想拥有UIDocument。那么我会假设你

1163
00:56:51,308 --> 00:56:54,275
已经有一个MVC显示您的文档和

1164
00:56:54,344 --> 00:56:57,546
它有一些var或vars是它的模型，对。

1165
00:56:57,615 --> 00:56:59,447
这是MVC，当然它有一个模型。

1166
00:56:59,516 --> 00:57:02,483
所以就像表情艺术一样，我们还没有我们的模特

1167
00:57:02,552 --> 00:57:05,887
在表情艺术中，但想象我有一些类型的表情符号变体

1168
00:57:05,956 --> 00:57:09,524
艺术，这是我展示的模型。它会

1169
00:57:09,593 --> 00:57:12,427
有图片的网址，它会有所有的表情符号，

1170
00:57:12,495 --> 00:57:15,163
他们在哪里，他们的大小，对吧？

1171
00:57:15,232 --> 00:57:17,032
这将是事物的模型。

1172
00:57:17,100 --> 00:57:20,201
所以我会假设我从那里开始。所以你需要做的

1173
00:57:20,270 --> 00:57:23,572
将您的应用程序转换为使用UIDocument是可以的

1174
00:57:23,640 --> 00:57:28,176
将该模型转换为数据，并从数据转换

1175
00:57:28,245 --> 00:57:30,312
回到模型。那么在本次讲座的早些时候，

1176
00:57:30,380 --> 00:57:32,447
我不只是告诉你如何做到这一点

1177
00:57:32,516 --> 00:57:36,017
存档者？真的很容易。所以你可以使用JSON格式

1178
00:57:36,086 --> 00:57:38,654
作为文档的文件格式，

1179
00:57:38,722 --> 00:57:42,023
只需使用归档即可来回转换模型

1180
00:57:42,092 --> 00:57:44,859
在数据之间，这就是你所要做的全部事情。

1181
00:57:44,928 --> 00:57:47,095
唯一你可能想要做的其他事情是

1182
00:57:47,163 --> 00:57:49,998
每当您的文档更改时告诉UIDocument，

1183
00:57:50,067 --> 00:57:52,568
就像你拖入一个新的表情符号或任何其他内容一样

1184
00:57:52,636 --> 00:57:54,903
那么它会自动保存。因为你必须告诉它，

1185
00:57:54,972 --> 00:57:56,871
否则它不知道何时自动保存。

1186
00:57:56,940 --> 00:57:59,207
但是，这实际上被称为一个功能，

1187
00:57:59,275 --> 00:58:03,010
我的文件改变了，它会从那里算出来。

1188
00:58:03,079 --> 00:58:05,213
就是这样，这就是为了让UIDocument工作而必须做的一切。

1189
00:58:05,282 --> 00:58:09,317
真正实现两种方法，获取并设置我的模型为

1190
00:58:09,385 --> 00:58:14,489
一个数据。那么我们该怎么做？我们继承UIDocument和

1191
00:58:14,558 --> 00:58:17,592
我们重写两个方法，一个是创建数据的方法

1192
00:58:17,661 --> 00:58:21,229
从数据中获取我们的模型。现在我们几乎总是

1193
00:58:21,298 --> 00:58:25,133
想要在我们的UIDocument子类中添加一个var，

1194
00:58:25,202 --> 00:58:28,469
这是模型。我们将要成为的模型

1195
00:58:28,538 --> 00:58:30,372
转换成数据和从数据转换。所以，

1196
00:58:30,440 --> 00:58:32,307
这里如果我有一个EmojiArtDocument

1197
00:58:32,376 --> 00:58:35,676
子类化UI文档，我添加了一个名为EmojiArt的变种，

1198
00:58:35,745 --> 00:58:36,812
这是EmojiArt类型。

1199
00:58:36,880 --> 00:58:40,115
这大概是这种模型的类型

1200
00:58:40,184 --> 00:58:44,453
我在我的EmojiArtDocument中。现在还有其他方法

1201
00:58:44,521 --> 00:58:46,721
您可以在UIDocument中重写某些内容。

1202
00:58:46,790 --> 00:58:48,857
我甚至会谈论其中的一个。但

1203
00:58:48,926 --> 00:58:52,427
你想做的主要两件事是阅读和

1204
00:58:52,495 --> 00:58:54,729
写入数据。而你唯一需要做的是

1205
00:58:54,798 --> 00:58:59,401
创建UIDocument是指定它的URL。

1206
00:58:59,470 --> 00:59:03,305
所以存在的唯一初始化器

1207
00:59:03,373 --> 00:59:05,473
UIDocument，它需要一个参数，

1208
00:59:05,542 --> 00:59:08,776
正如你可以看到它在黄色那里，fileURL和

1209
00:59:08,845 --> 00:59:12,146
那就是文档的URL。现在我

1210
00:59:12,215 --> 00:59:15,583
稍后会告诉你，这个URL可能会给你和

1211
00:59:15,652 --> 00:59:19,921
可能是一台iCloud硬盘，你甚至可能不在乎。

1212
00:59:19,990 --> 00:59:23,424
当然，你也可以在某处创建一个URL

1213
00:59:23,493 --> 00:59:26,494
大概在你的沙盒的文档目录中，并且

1214
00:59:26,563 --> 00:59:30,832
如果你想的话，创建自己的文档。但实际上，在iOS中

1215
00:59:30,901 --> 00:59:35,603
11，通常我们让文件应用机制给我们提供URL。

1216
00:59:35,672 --> 00:59:37,806
用户去他们想要的文件，并且

1217
00:59:37,874 --> 00:59:40,141
他们说创建文档，它给了我们URL和

1218
00:59:40,210 --> 00:59:42,244
我们只是称之为创建我们的UIDocument。

1219
00:59:43,847 --> 00:59:46,014
现在一旦我们创建了我们的UIDocument，

1220
00:59:46,083 --> 00:59:48,783
我们将设置我在顶部定义的var

1221
00:59:48,852 --> 00:59:51,653
那里的屏幕。我们将在那里设置该模型

1222
00:59:51,721 --> 00:59:53,554
那么UIDocument会从那里拿走它。

1223
00:59:53,623 --> 00:59:54,889
它会读取和写入文件和

1224
00:59:54,958 --> 00:59:57,992
一切。好，那么做这个转换怎么样

1225
00:59:58,061 --> 01:00:01,830
从emojiArt到数据和从数据到emojiArt。所以

1226
01:00:01,899 --> 01:00:04,599
这是两种方法。这是转换你的

1227
01:00:04,668 --> 01:00:08,570
模型化成数据，它被称为类型的内容，好吧。

1228
01:00:08,639 --> 01:00:10,839
它抛出，你可以抛出。如果你有问题

1229
01:00:10,907 --> 01:00:13,507
将您的表情符号转换为数据，您可以抛出。和

1230
01:00:13,576 --> 01:00:17,212
我会告诉你那个东西被扔到哪里。并注意它

1231
01:00:17,280 --> 01:00:20,215
返回一个Any。你会认为这会返回一个数据

1232
01:00:20,284 --> 01:00:22,450
就在那里，但它会返回一个Any，因为你实际上可以

1233
01:00:22,519 --> 01:00:26,754
也代表您的文档为充满文件的目录。

1234
01:00:26,823 --> 01:00:29,257
这就是所谓的FileWrapper。但

1235
01:00:29,326 --> 01:00:32,160
我们只会谈谈Data的实现方式。

1236
01:00:32,229 --> 01:00:33,762
如果你想做FileWrapper的方式，你会有

1237
01:00:33,831 --> 01:00:35,730
查找文件包装的文档。

1238
01:00:35,799 --> 01:00:37,532
这并不难，但它更多一点

1239
01:00:37,601 --> 01:00:40,368
而不仅仅是把它变成一个数据blob。和

1240
01:00:40,437 --> 01:00:42,738
那么我将如何实施这种方法呢？

1241
01:00:42,806 --> 01:00:44,739
真的很简单，我会用这个归档的东西，而且

1242
01:00:44,808 --> 01:00:47,241
在这里使用JSON编码器或其他东西

1243
01:00:47,310 --> 01:00:50,411
创建一个Data对象。我只是回报它，就是这样。

1244
01:00:50,480 --> 01:00:53,748
所以这通常是一个类轮，这个类型的内容。现在

1245
01:00:53,817 --> 01:00:56,985
那种你看到的类型，是的，我已经说过你了

1246
01:00:57,053 --> 01:00:59,387
可以扔到那里。所以在那里传递的类型

1247
01:00:59,456 --> 01:01:03,658
这是一个通用类型标识符UTI。和

1248
01:01:03,727 --> 01:01:05,493
我会谈一谈这是什么

1249
01:01:05,562 --> 01:01:09,464
在几张幻灯片中。这不是类似.jpeg的类型。

1250
01:01:09,532 --> 01:01:12,434
这是一个像public.json这样的类型

1251
01:01:12,502 --> 01:01:16,538
是JSON文件，还是public.img，它是一个图像文件。那是

1252
01:01:16,607 --> 01:01:18,573
那种类型的名字就是这种类型的东西。

1253
01:01:18,642 --> 01:01:21,509
通常你不关心，因为通常你的UIDocument只

1254
01:01:21,578 --> 01:01:25,013
无论如何打开一种文件，如emojiArt文件，所以

1255
01:01:25,082 --> 01:01:27,215
你甚至不关心这是什么类型。但你可能会

1256
01:01:27,284 --> 01:01:30,118
成为一个UIDocument，然后可以以不同的格式

1257
01:01:30,186 --> 01:01:33,755
也许你在乎。好的，相反呢？

1258
01:01:33,824 --> 01:01:35,890
你有一个数据，交给你，

1259
01:01:35,959 --> 01:01:37,792
你必须变成你的模型。

1260
01:01:37,861 --> 01:01:42,229
再次，你可能会使用该JSON解码器，和

1261
01:01:42,298 --> 01:01:47,001
把数据拿回来，并把它变成一个表情符号艺术。然后再次，

1262
01:01:47,070 --> 01:01:50,738
它有那里的类型，从类型的内容加载，这是

1263
01:01:50,807 --> 01:01:54,041
UTI。这个也会抛出。这一个你更可能

1264
01:01:54,110 --> 01:01:57,579
抛出，因为在这里你得到了一个JSON的东西或

1265
01:01:57,647 --> 01:02:00,749
一个数据blob，你就变成了EmojiArt。它

1266
01:02:00,817 --> 01:02:03,385
可能会损坏，它可能不是正确的格式，

1267
01:02:03,453 --> 01:02:07,021
它有什么问题，所以你可能会扔在这里。

1268
01:02:07,090 --> 01:02:09,758
事实上，这就是你需要做的就是实现这些

1269
01:02:09,826 --> 01:02:12,294
两种方法。现在你可以使用所有的方法

1270
01:02:12,362 --> 01:02:15,863
UIDocument像open一样打开您的文档。

1271
01:02:15,932 --> 01:02:19,501
它是异步的，所以你在那里提供一个闭包，

1272
01:02:19,569 --> 01:02:21,536
它甚至会告诉你你是否成功做到了

1273
01:02:21,605 --> 01:02:24,205
不。如果它没有成功打开它，你就是

1274
01:02:24,273 --> 01:02:26,241
会看着这个叫做documentState的东西，并且

1275
01:02:26,309 --> 01:02:28,676
我会在一秒钟之内谈论这件事，好吧。

1276
01:02:28,745 --> 01:02:30,611
这就是你如何打开一个文件。你必须这样做

1277
01:02:30,680 --> 01:02:33,447
当然，在你使用之前打开你的UIDocument，

1278
01:02:33,516 --> 01:02:35,349
因为UIDocument想要去获取文件，

1279
01:02:35,418 --> 01:02:36,851
并获取数据和类似的东西。

1280
01:02:36,920 --> 01:02:40,055
调用将其转换为表情符艺术或表情的方法

1281
01:02:40,123 --> 01:02:43,358
无论如何，但你必须打开你的文件。

1282
01:02:43,427 --> 01:02:46,627
你可以明确地保存你的文件，或者你可以做

1283
01:02:46,696 --> 01:02:49,264
自动保存。如果你做自动保存，这是你的方法

1284
01:02:49,332 --> 01:02:52,968
必须调用告诉你的UIDocument我已经改变了。

1285
01:02:53,036 --> 01:02:57,571
UpdateChangeCount（.done）。另一种方法，顺便说一句

1286
01:02:57,640 --> 01:03:01,709
这是使用UIDocument的撤消管理器。不幸，

1287
01:03:01,778 --> 01:03:04,112
我没有时间教你做撤销。

1288
01:03:04,181 --> 01:03:05,180
撤消管理器是一个真正的

1289
01:03:05,248 --> 01:03:08,049
很酷的小类，每次你做手术时，

1290
01:03:08,118 --> 01:03:09,784
就像在或中拖动一个新的表情符号一样

1291
01:03:09,853 --> 01:03:12,186
调整它的大小，你去到撤销管理器和

1292
01:03:12,255 --> 01:03:15,056
说，我只是做了这个操作，这里是闭包

1293
01:03:15,125 --> 01:03:20,127
如何撤消它。然后，它会自动进行撤消/重做，

1294
01:03:20,196 --> 01:03:22,464
只需将这些闭包拉出来，以便撤消和

1295
01:03:22,532 --> 01:03:25,299
然后重做，来回走动。当然，如果你使用

1296
01:03:25,368 --> 01:03:28,670
UIDocument的undoManager来做这件事，那么它就会知道

1297
01:03:28,738 --> 01:03:31,739
当您执行这些撤消和时，文档已经更改

1298
01:03:31,808 --> 01:03:37,045
重做东西。所以这是使用撤消管理器的另一种方式。

1299
01:03:37,114 --> 01:03:39,780
如果你想明确保存，那就保存。

1300
01:03:39,849 --> 01:03:42,383
保存的不是开放的，它实际上有一对

1301
01:03:42,452 --> 01:03:46,755
参数。您保存到URL的原因是

1302
01:03:46,823 --> 01:03:50,291
另存为。当然，一个文档知道它自己的URL，

1303
01:03:50,360 --> 01:03:52,527
这是在初始化时指定的，或者是

1304
01:03:52,595 --> 01:03:56,464
文件的URL。所以保存到URL可以让你保存到

1305
01:03:56,532 --> 01:03:59,100
另一个URL保存为。然后就是这样

1306
01:03:59,169 --> 01:04:01,703
文件保存操作，不幸的是当你保存时，

1307
01:04:01,772 --> 01:04:04,272
你必须知道这是否是最初的文档

1308
01:04:04,341 --> 01:04:07,274
创建保存或是否是后续安全。

1309
01:04:07,343 --> 01:04:09,010
你必须告诉系统。

1310
01:04:09,079 --> 01:04:11,612
我不确定为什么它会让你这样做，而不是外出

1311
01:04:11,681 --> 01:04:14,382
并弄清楚，我认为这只是为了灵活性。

1312
01:04:14,451 --> 01:04:17,585
因为它可以保存到许多不同种类的容器中。

1313
01:04:17,654 --> 01:04:21,055
iCloud驱动器，您的本地文件系统，它甚至可以保存到

1314
01:04:21,124 --> 01:04:25,126
像Box这样的东西。所以也许有些人不允许它提问

1315
01:04:25,194 --> 01:04:28,630
文件是否存在的问题，我不是

1316
01:04:28,698 --> 01:04:31,899
确切地确定它为什么这样做。但是当你说出来的时候，

1317
01:04:31,968 --> 01:04:35,636
你必须知道你是否创建它。

1318
01:04:35,705 --> 01:04:37,404
当你完成你的文档时，

1319
01:04:37,473 --> 01:04:40,408
你会想要关闭它。当然，这是最重要的事情

1320
01:04:40,477 --> 01:04:43,545
如果它有任何未完成的更改，则保存它。

1321
01:04:43,613 --> 01:04:46,381
再次，如果它关闭它，你会有这个

1322
01:04:46,450 --> 01:04:48,950
文件状态的东西。那么，我一直在说什么，

1323
01:04:49,019 --> 01:04:50,852
如果事情失败，请查看文档状态，

1324
01:04:50,921 --> 01:04:53,822
那是什么？那么，让我们看看文档

1325
01:04:53,890 --> 01:04:56,324
状态，文档状态是UIDocument中的一个变量。

1326
01:04:56,393 --> 01:04:58,827
你可以看看它，看看你的文档是如何做的。

1327
01:04:58,895 --> 01:05:01,829
这是一些正常的值，这意味着你的

1328
01:05:01,898 --> 01:05:05,166
文件已准备好使用。只要做任何你想要的事情，

1329
01:05:05,234 --> 01:05:07,601
这是正常的状态。还有关闭，

1330
01:05:07,670 --> 01:05:10,838
这意味着要么你没有打开它，要么尝试打开

1331
01:05:10,907 --> 01:05:13,808
它失败了，它仍然处于关闭状态。

1332
01:05:13,877 --> 01:05:18,279
有saveError，这是你试图保存它和

1333
01:05:18,348 --> 01:05:22,183
它失败了。还有editDisabled，就是这样

1334
01:05:22,251 --> 01:05:25,586
UIDocument上的一种方法，即禁用编辑。

1335
01:05:25,655 --> 01:05:28,023
为什么你会想禁用编辑？那么，为了

1336
01:05:28,091 --> 01:05:30,958
例如，核心数据文档UIManagedDocument。

1337
01:05:31,027 --> 01:05:33,962
它在做某种事情时会禁用编辑

1338
01:05:34,031 --> 01:05:36,865
一个SQL操作来更新数据库。现在它

1339
01:05:36,933 --> 01:05:40,068
只发生一微秒，它被禁用。

1340
01:05:40,136 --> 01:05:43,071
但基本上，当您将editingDisabled设置为状态时

1341
01:05:43,139 --> 01:05:46,040
的文件。你只是不想让用户

1342
01:05:46,109 --> 01:05:48,342
拖动新的表情符号，或调整任何东西。

1343
01:05:48,411 --> 01:05:50,945
在表情符号艺术之类的东西中不是一个真正的问题，

1344
01:05:51,014 --> 01:05:53,981
它非常简单。但这可能是核心问题

1345
01:05:54,050 --> 01:05:57,518
数据或其他一些更复杂的存储机制。

1346
01:05:57,587 --> 01:05:59,620
然后是progressAvailable状态。

1347
01:05:59,689 --> 01:06:02,223
这意味着你在文档上打开了，并且

1348
01:06:02,292 --> 01:06:06,027
该文件是巨大的，它从iCloud或

1349
01:06:06,096 --> 01:06:09,163
一些东西。这将告诉你，进展，

1350
01:06:09,232 --> 01:06:11,666
它将成为UIDocument中的进度条，

1351
01:06:11,734 --> 01:06:13,434
会告诉你它有多远。

1352
01:06:13,503 --> 01:06:16,604
它会一直保持这种状态直到完全下载，

1353
01:06:16,673 --> 01:06:21,409
然后它会移动到打开，或者正常。最后，

1354
01:06:21,478 --> 01:06:24,345
有冲突，这是一个非常迷人的。

1355
01:06:24,413 --> 01:06:27,915
由于文档可以存储在网络容器中，

1356
01:06:27,984 --> 01:06:31,352
它可能会保存在有网络访问的地方

1357
01:06:31,421 --> 01:06:34,255
时间。然后在另一个地方开始编辑

1358
01:06:34,324 --> 01:06:37,325
没有网络访问权限，反之亦然。导致两个

1359
01:06:37,393 --> 01:06:40,694
应用程序的版本最终被保存到iCloud。

1360
01:06:40,763 --> 01:06:43,931
现在你有两个版本可能是冲突的，而且

1361
01:06:44,000 --> 01:06:45,299
这就是这个。

1362
01:06:45,368 --> 01:06:48,536
现在，你不会在你的应用中处理这个问题。

1363
01:06:48,605 --> 01:06:51,039
你可能会采取默认行为，也就是说，

1364
01:06:51,108 --> 01:06:53,140
它使用具有最近文件日期的那个。

1365
01:06:53,209 --> 01:06:56,544
无论哪个人最近写过，都会使用。但

1366
01:06:56,613 --> 01:06:59,113
如果你想解决这个差异，并且你想

1367
01:06:59,182 --> 01:07:01,950
注意这个并解决它，你可以使用这个NSFileVersion

1368
01:07:02,018 --> 01:07:05,052
静态方法在这里。并获得所有不同的版本，

1369
01:07:05,121 --> 01:07:07,088
并看看它们之间的差异。

1370
01:07:07,157 --> 01:07:09,524
也许为用户提供一些选择，无论如何，

1371
01:07:09,592 --> 01:07:12,260
这取决于你。但对于表情符号艺术，

1372
01:07:12,328 --> 01:07:15,396
你总是会采取最新的做法，你可能没问题

1373
01:07:15,465 --> 01:07:17,932
版本，无论哪一个最新保存。

1374
01:07:19,869 --> 01:07:23,304
DocumentState as var也可以用相同的方式观察

1375
01:07:23,372 --> 01:07:26,674
键盘观察可能发生。请记住，我告诉过

1376
01:07:26,742 --> 01:07:28,943
你有一种方法可以告诉系统，

1377
01:07:29,012 --> 01:07:31,512
嘿，如果键盘出现了，请告诉我，对不对？

1378
01:07:31,581 --> 01:07:34,315
这就是所谓的通知，同样的事情在这里。你可以说，

1379
01:07:34,384 --> 01:07:36,650
嘿，如果我的文档状态发生变化，请告诉我，

1380
01:07:36,719 --> 01:07:39,220
它会告诉你。我要告诉你如何

1381
01:07:39,289 --> 01:07:42,223
下周我们谈论通知时要做到这一点，

1382
01:07:42,292 --> 01:07:45,727
我会提到文档状态和键盘。并展示

1383
01:07:45,795 --> 01:07:51,232
你看什么代码看你的文档状态。

1384
01:07:51,301 --> 01:07:54,802
最后，我要谈谈一个很酷的小额外方法

1385
01:07:54,871 --> 01:07:57,672
可以在UIDocument中重写以放置缩略图图像。

1386
01:07:57,740 --> 01:08:01,742
而不是你的文件图标。默认，

1387
01:08:01,811 --> 01:08:04,244
当您在文件应用程序或文件中查看文档时

1388
01:08:04,313 --> 01:08:07,749
无论如何，他们会有图标，对吧？无论文件类型如何

1389
01:08:07,817 --> 01:08:10,518
图标，jpg文件图标，无论如何。要么

1390
01:08:10,587 --> 01:08:13,821
如果你有一个表情符艺术类型的文件，我们会去的

1391
01:08:13,889 --> 01:08:18,059
谈谈，周三，它会显示那个图标。

1392
01:08:18,127 --> 01:08:19,494
但是你也可以说，

1393
01:08:19,563 --> 01:08:22,563
当用户在文件系统中看到我的文件时，

1394
01:08:22,632 --> 01:08:26,601
实际上使用它的这个缩略图作为它的图标。

1395
01:08:26,670 --> 01:08:29,003
这是使它更容易的一个非常强大的方法

1396
01:08:29,072 --> 01:08:31,305
用户可以找到他们想要的文件。

1397
01:08:31,374 --> 01:08:34,108
因为想象绘文字艺术，你会做一些不错的艺术，而且

1398
01:08:34,177 --> 01:08:37,278
它使它有一个小缩略图。所以你可以看到

1399
01:08:37,347 --> 01:08:39,947
在文件系统中打开它之前，

1400
01:08:40,016 --> 01:08:42,883
它就像文档的图标。要做到这一点，

1401
01:08:42,952 --> 01:08:46,287
你所要做的就是覆盖这个UIDocument方法，

1402
01:08:46,356 --> 01:08:48,856
称为文件属性以写入URL的URL

1403
01:08:48,925 --> 01:08:52,660
操作。这通常会返回

1404
01:08:52,729 --> 01:08:56,531
一个文件属性的字典就是这个文件

1405
01:08:56,599 --> 01:08:59,634
隐？类似的事情，但你可以覆盖它，

1406
01:08:59,702 --> 01:09:02,803
获取它通常会返回的超级文件属性。

1407
01:09:02,872 --> 01:09:06,507
然后添加这个非常特殊的字典项目称为

1408
01:09:06,576 --> 01:09:10,778
URLResourceKey.thumbnailDicttiKey。它的价值

1409
01:09:10,846 --> 01:09:14,415
实际上是另一本字典。关键在于

1410
01:09:14,484 --> 01:09:19,620
ThumbnailDictionaryItem.NSThu-mbnail1024x1024SizeKey。和

1411
01:09:19,689 --> 01:09:24,759
该值是一个UIImage。所以你把这个添加到字典中，

1412
01:09:24,828 --> 01:09:27,929
如果你有一个UIImage是缩略图，并返回它。

1413
01:09:27,997 --> 01:09:31,766
现在，它说NSThumbnail1024x1024，但是

1414
01:09:31,835 --> 01:09:34,402
它实际上可以是任何大小。

1415
01:09:34,471 --> 01:09:37,105
在我看来，如果尺寸太小，

1416
01:09:37,173 --> 01:09:40,040
那么它将开始使用该文件的图标。所以

1417
01:09:40,109 --> 01:09:43,411
它不能太小，我不确定太小，

1418
01:09:43,479 --> 01:09:46,513
可能与图标图像有多大有关

1419
01:09:46,582 --> 01:09:49,050
是。也许如果它比图标图像小，

1420
01:09:49,119 --> 01:09:50,718
我真的不确定它是如何选择的。

1421
01:09:50,787 --> 01:09:53,654
但是，只要图像体积适中，

1422
01:09:53,723 --> 01:09:56,323
我也不知道是否有限制

1423
01:09:56,392 --> 01:09:59,060
大。但你可能不想浪费你的时间

1424
01:09:59,129 --> 01:10:01,228
创造比1024x1024更大的东西，

1425
01:10:01,297 --> 01:10:04,832
因为它会成为一个缩略图。这将是一个小型展示

1426
01:10:04,901 --> 01:10:08,802
文件应用程序或其他，你可以返回它，所以

1427
01:10:08,871 --> 01:10:13,174
我们也会在周三的演示中做到这一点。

1428
01:10:13,242 --> 01:10:15,442
所以在UIDocument中还有一些其他的东西，

1429
01:10:15,511 --> 01:10:17,845
像localizedName。它会查看URL，并且

1430
01:10:17,913 --> 01:10:20,748
在URL的末尾获得名称，以及类似的东西。

1431
01:10:20,817 --> 01:10:23,684
您可以了解当前是否有任何未保存的更改，

1432
01:10:23,753 --> 01:10:25,953
你可以得到上次保存文件的日期，

1433
01:10:26,021 --> 01:10:28,555
你甚至可以做userActivity。这是什么东西在哪里

1434
01:10:28,624 --> 01:10:30,624
你开始在一台设备上工作，

1435
01:10:30,693 --> 01:10:32,092
那么你继续另一个。

1436
01:10:32,161 --> 01:10:36,396
而你将完全处于你以前的位置。所以我们出去了

1437
01:10:36,465 --> 01:10:39,166
今天的时间，我确实有一个话题，我们将开始

1438
01:10:39,235 --> 01:10:42,437
星期三关闭。这是UIDocumentBrowserViewControl-

1439
01:10:42,505 --> 01:10:46,507
LER。这是一个非常棒的方式来给一个非常强大的用户

1440
01:10:46,576 --> 01:10:51,446
界面为你的用户在你自己的应用程序内要创建文件，

1441
01:10:51,514 --> 01:10:55,149
移动文件，删除文件，把它们放在文件夹中，你知道，

1442
01:10:55,218 --> 01:10:58,118
将它们从iCloud驱动器拖到本地硬盘上。

1443
01:10:58,187 --> 01:11:01,455
所有这些东西，你得到这个强大的用户界面，很少工作

1444
01:11:01,524 --> 01:11:04,659
在你的部分，只要你有基于UIDocument的应用程序。

1445
01:11:04,727 --> 01:11:06,828
所以，我们将在星期三开始，我会告诉你。

1446
01:11:06,896 --> 01:11:09,997
然后我会潜心将表情符艺术转化为

1447
01:11:10,065 --> 01:11:13,434
一个基于UIDocument的应用程序，它使用所有这些很酷的用户界面和

1448
01:11:13,503 --> 01:11:16,504
所有的东西。星期五，没有更多的部分，所以没有

1449
01:11:16,572 --> 01:11:19,207
周五部分。下周，我会谈论警报，

1450
01:11:19,275 --> 01:11:21,809
通知，我提到，应用程序的生命周期，

1451
01:11:21,878 --> 01:11:24,912
该应用程序委托的东西。还有一些关于segues的内容，

1452
01:11:24,981 --> 01:11:27,748
我们还没有谈到更多的细节。

1453
01:11:27,817 --> 01:11:31,986
这就是我们下一次做的，好吗？

1454
01:11:32,054 --> 01:11:35,656
我们稍后见。 >>更多信息，请访问我们，

1455
01:11:35,724 --> 01:11:37,458
在stanford.edu。

