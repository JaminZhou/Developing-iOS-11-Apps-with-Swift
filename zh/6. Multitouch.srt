1
00:00:00,401 --> 00:00:04,970
[MUSIC]

2
00:00:05,038 --> 00:00:09,174
斯坦福大学。 >>好的，

3
00:00:09,243 --> 00:00:13,845
欢迎来到斯坦福大学CS193P讲座6，

4
00:00:13,913 --> 00:00:18,183
2017年秋天。所以今天我要继续那个演示

5
00:00:18,251 --> 00:00:21,620
我上次开始了这将是今天的巨大演示，

6
00:00:21,689 --> 00:00:24,790
主要包括与自定义视图有关的东西。

7
00:00:24,859 --> 00:00:26,524
然后我回到幻灯片，

8
00:00:26,593 --> 00:00:28,826
只是几个简单的幻灯片多点触摸和

9
00:00:28,895 --> 00:00:32,664
我们如何做到这一点。然后，我们将回到演示，并添加一些

10
00:00:32,733 --> 00:00:36,568
多点触摸手势给我们的小扑克牌的事情。

11
00:00:36,636 --> 00:00:39,705
以下是今天要学习的内容，

12
00:00:39,773 --> 00:00:42,541
你回头看看演示后的幻灯片。

13
00:00:42,609 --> 00:00:46,812
然后试着做出决定，我是否知道，我们会发现

14
00:00:46,880 --> 00:00:50,048
出。在最后一次演讲和这个演讲之间，我

15
00:00:50,117 --> 00:00:53,318
继续前进，完成了一个自定义字符串转换为

16
00:00:53,386 --> 00:00:56,187
所有这三件事情。我只是做自定义

17
00:00:56,256 --> 00:00:59,591
字符串，可转换返回其原始值，记住它的原始

18
00:00:59,660 --> 00:01:02,928
在这里，价值观就是这些小小的东西然后排名，

19
00:01:02,996 --> 00:01:05,597
我不得不实际执行一些描述，

20
00:01:05,666 --> 00:01:08,600
就在那里，我回到了那里。接着

21
00:01:08,669 --> 00:01:12,871
一个数字的字符串版本，或类型J，Q或K.但是

22
00:01:12,940 --> 00:01:15,941
一旦我实现了可转换的自定义字符串

23
00:01:16,009 --> 00:01:19,277
所有这三件事情。然后这个代码我们回来了

24
00:01:19,346 --> 00:01:22,114
在这里我们刚刚打印出十张随机卡，

25
00:01:22,182 --> 00:01:24,583
在控制台上打印出来更好。

26
00:01:24,652 --> 00:01:26,885
所以让我们来看看它现在做了什么。

27
00:01:26,953 --> 00:01:29,587
看，这只是在这里打印出来的一种缩写

28
00:01:29,656 --> 00:01:32,757
版本，也就是说，如果你正在调试，那就更好了

29
00:01:32,826 --> 00:01:34,926
打印你的卡片，看看。

30
00:01:34,995 --> 00:01:38,530
你可能想在你的任务中做同样的事情

31
00:01:38,598 --> 00:01:42,734
第三名也是如此。所以就是这样。

32
00:01:42,803 --> 00:01:45,037
我们已经完成了我们的模型

33
00:01:45,105 --> 00:01:48,139
这个MVC，我们正在这里建设，这个应用程序，

34
00:01:48,208 --> 00:01:51,176
这张纸牌，所以我们有一副扑克牌。

35
00:01:51,245 --> 00:01:55,546
所以现在是时候深入绘制这些卡。

36
00:01:55,615 --> 00:01:58,616
我们要用一个自定义的UIView子类来做到这一点

37
00:01:58,685 --> 00:02:01,853
是我要调用给游戏卡视图。现在你创建一个自定义

38
00:02:01,922 --> 00:02:04,589
以相同的方式查看您创建其他类。

39
00:02:04,658 --> 00:02:07,859
所以你要做File> New> File。但在这里，而不是

40
00:02:07,927 --> 00:02:11,529
选择Swift文件，这就像一个UI独立的东西，

41
00:02:11,598 --> 00:02:16,801
你会选择Cocoa Touch类。这是因为我们的用户界面

42
00:02:16,870 --> 00:02:21,306
视图是Cocoa Touch或UI工具包类的子类。

43
00:02:21,374 --> 00:02:25,010
所以我会打电话，打牌，打牌，

44
00:02:25,078 --> 00:02:28,980
这将是UIView的子类。很多其他的UI工具包

45
00:02:29,049 --> 00:02:33,718
事情可以分类在这里，但我想要的是UIView。

46
00:02:33,787 --> 00:02:35,821
它说，你想放在哪里？顺便一提，

47
00:02:35,889 --> 00:02:38,890
我只想提醒你们所有人，你们中的一些人正在把你们的

48
00:02:38,959 --> 00:02:41,960
顶级文件，项目级别，所以他们是

49
00:02:42,028 --> 00:02:44,962
就像在你的X代码项目旁边结束一样。

50
00:02:45,031 --> 00:02:47,799
你真的想把他们放在这里的水平。

51
00:02:47,868 --> 00:02:50,802
这是我们收集所有课程的地方。所以就

52
00:02:50,871 --> 00:02:53,505
有一点提醒，我们在作业上看到了。

53
00:02:53,574 --> 00:02:56,408
所以这里是我的UIView子类，看看这个，看看？

54
00:02:56,476 --> 00:02:58,576
UIView的子类，很好。

55
00:02:58,645 --> 00:03:01,913
它甚至在这里给了我一个非常重要的方法的一个存根，

56
00:03:01,982 --> 00:03:05,450
这当然是我们的平庸。现在，你注意到了

57
00:03:05,519 --> 00:03:08,853
在这个存根中注释掉了，这是因为这个iOS

58
00:03:08,922 --> 00:03:11,656
实际上看看你有draw rect。

59
00:03:11,725 --> 00:03:14,025
如果你这样做，它会为屏幕提供一个缓冲区

60
00:03:14,094 --> 00:03:16,694
你和你的各种准备画画，

61
00:03:16,763 --> 00:03:19,163
好吧，这并不便宜，它不是免费的。

62
00:03:19,232 --> 00:03:21,766
所以，如果你真的没有画出你的画图，

63
00:03:21,835 --> 00:03:24,236
那么你会想离开它注释掉。

64
00:03:24,304 --> 00:03:27,839
现在为什么你会有一个UIView或UIView子类

65
00:03:27,908 --> 00:03:31,443
那没有draw rect？那实际上挺好的

66
00:03:31,512 --> 00:03:33,878
常见的，你做所有你的绘画与子视图，

67
00:03:33,947 --> 00:03:37,182
考虑UI堆栈视图，对吧？这是一个UIView，它完成了所有的工作

68
00:03:37,250 --> 00:03:39,851
绘制与堆积在里面的意见。

69
00:03:39,920 --> 00:03:43,054
它本身没有任何实际的绘画，它没有绘制

70
00:03:43,123 --> 00:03:46,124
rect，对吗？但是当然，我们会有一个平等的，

71
00:03:46,192 --> 00:03:48,559
因为我们要画一张纸牌

72
00:03:48,628 --> 00:03:51,830
现在我其实只是在这里举例，

73
00:03:51,898 --> 00:03:54,765
我要画出一些我的卡片的子视图和

74
00:03:54,834 --> 00:03:58,202
我的一些卡用这个画好了，好的。所以你会这样

75
00:03:58,271 --> 00:04:00,705
看到实际上两者都有的一个视图。和

76
00:04:00,774 --> 00:04:03,341
在你的家庭作业中，你可能会有

77
00:04:03,410 --> 00:04:04,976
至少有一个视图做子视图

78
00:04:05,045 --> 00:04:07,078
至少有一个视图有一个draw rect。所以

79
00:04:07,146 --> 00:04:11,016
你可以看到所有的行动，在这里行动。

80
00:04:11,084 --> 00:04:14,085
好的，所以我们得到了这个PlayingCardView。我们回去吧

81
00:04:14,154 --> 00:04:17,889
在这里我们的故事板，并把UI视图，

82
00:04:17,958 --> 00:04:21,626
一个PlayingCardView基本上，进入我们的用户界面，好吧。

83
00:04:21,695 --> 00:04:25,096
那么我们该怎么做呢？那么，我们如何把视图放在我们的用户界面？

84
00:04:25,165 --> 00:04:28,032
我们到这里去公用事业，倒在最下面，

85
00:04:28,101 --> 00:04:30,735
也许我们拖出一个按钮，或者我们拖动一个标签。

86
00:04:30,804 --> 00:04:34,105
当然，在哪里玩牌视图？那么，它不在

87
00:04:34,174 --> 00:04:36,775
在这里，当然，这些都是只是来的东西

88
00:04:36,843 --> 00:04:40,579
与X代码。但是我可以在这里拖到底部，

89
00:04:40,647 --> 00:04:43,915
这个人，查看，这是一个通用的用户界面视图。

90
00:04:43,984 --> 00:04:47,051
所以我把他拖到这里和他的班级

91
00:04:47,120 --> 00:04:51,055
他的类型只是UI视图。我要去做我的背景

92
00:04:51,124 --> 00:04:54,259
一个不同的颜色，所以我们可以看到他在那里好一点。

93
00:04:54,327 --> 00:04:56,862
所以我只是要选择我的背景和改变，

94
00:04:56,930 --> 00:04:59,097
橙色，我喜欢橙色，橙色。

95
00:04:59,166 --> 00:05:01,532
旧金山巨人的颜色就在那里。

96
00:05:01,601 --> 00:05:04,002
所以这是我的通用UI视图。

97
00:05:04,071 --> 00:05:06,471
我不希望这是一个通用的用户界面视图，

98
00:05:06,540 --> 00:05:09,640
我想要它是一个扑克牌视图，好吧，因为这是什么

99
00:05:09,709 --> 00:05:11,976
我一直在努力。而我们这样做的方式是

100
00:05:12,045 --> 00:05:13,945
与不同的检查员在右边。

101
00:05:14,013 --> 00:05:16,414
你看我们一直在这里使用这个检查员，

102
00:05:16,482 --> 00:05:19,384
属性检查器。隔壁就是这个

103
00:05:19,453 --> 00:05:21,720
的家伙。这是身份检查员，

104
00:05:21,789 --> 00:05:24,623
它检查所选事物的身份。

105
00:05:24,691 --> 00:05:28,393
所以在这里我有一个选择的视图，它是类型的UI视图，

106
00:05:28,461 --> 00:05:32,230
你看到课堂？但我可以去这里改变它

107
00:05:32,298 --> 00:05:36,067
一张纸牌视图。所以现在这是一张纸牌的看法，

108
00:05:36,136 --> 00:05:39,904
任何时候系统需要绘制它，它都会使用我们的

109
00:05:39,973 --> 00:05:44,676
在这里draw(rect)。这是我们编写的代码。

110
00:05:44,744 --> 00:05:47,845
所以这真棒。现在我要做一些自动

111
00:05:47,914 --> 00:05:50,915
布局这里你看过的。所以这不算什么

112
00:05:50,984 --> 00:05:53,985
新的，但我只是要把这个在这里的边缘，

113
00:05:54,053 --> 00:05:56,955
把这个放在这里，我要把它钉在边缘。

114
00:05:57,024 --> 00:06:00,057
所以我的电子贺卡会有点高

115
00:06:00,126 --> 00:06:04,229
在肖像模式下很薄，而且风景又短又宽

116
00:06:04,298 --> 00:06:07,865
模式，但没关系，我们稍后再解决。所以

117
00:06:07,934 --> 00:06:10,868
我只是要拖到角落，并设置我的leading和

118
00:06:10,937 --> 00:06:14,272
顶部空间被钉住。我要拖动Ctrl +拖动

119
00:06:14,341 --> 00:06:16,975
到这个角落，并设置我的trailing和底部。

120
00:06:17,044 --> 00:06:19,544
所以他们会从那里开始，所以现在如果我去了

121
00:06:19,613 --> 00:06:22,914
在这里进入横向模式，你可以看到它

122
00:06:22,983 --> 00:06:26,251
销到边缘，所以我有这个有趣的形状。现在，

123
00:06:26,319 --> 00:06:29,654
我主要是在这里做这个，因为我想

124
00:06:29,723 --> 00:06:33,424
展示当你的界限发生变化时，你的视图会发生什么。

125
00:06:33,493 --> 00:06:36,527
因为在这里，当我们旋转，我们的bounds将是

126
00:06:36,596 --> 00:06:40,065
变化非常显着，从高而瘦到宽广

127
00:06:40,133 --> 00:06:42,800
短。所以在我们开始玩纸牌之前，

128
00:06:42,869 --> 00:06:44,969
我只是要做一些绘画，

129
00:06:45,038 --> 00:06:47,472
告诉你如何绘图与核心图形和

130
00:06:47,540 --> 00:06:50,041
像在讲座中讲的UI bezier path。所以

131
00:06:50,110 --> 00:06:53,344
让我们先画一个圆圈，在我们的中间只是一个圆圈

132
00:06:53,413 --> 00:06:57,281
查看使用核心图形，并查看代码的样子。

133
00:06:57,350 --> 00:07:00,318
所以在核心图形中，我们总是首先获取上下文。

134
00:07:00,387 --> 00:07:03,855
所以我们不能在没有上下文的情况下绘制核心图形

135
00:07:03,924 --> 00:07:06,391
我们通过这样做得到了我们的理解

136
00:07:06,459 --> 00:07:10,562
UIGraphicsGetCurrentContext。现在，这可能会返回零，

137
00:07:10,631 --> 00:07:14,031
这就是为什么我们要这样做，但它永远不会返回零

138
00:07:14,100 --> 00:07:16,567
在你的直角内。好吧，可能会转向，

139
00:07:16,636 --> 00:07:19,170
在其他情况下返回零，但在这种环境下，

140
00:07:19,239 --> 00:07:20,471
它总是会回来，

141
00:07:20,540 --> 00:07:23,040
但是我们仍然会这样做 - 让我们在那里。我们可以

142
00:07:23,109 --> 00:07:25,576
做感叹号，我们只是要做，如果让。

143
00:07:25,645 --> 00:07:29,447
所以，现在我有一个上下文，现在我可以告诉上下文

144
00:07:29,516 --> 00:07:33,184
做某些事情，转移到，好吧，我可以做到。

145
00:07:33,252 --> 00:07:37,422
我可以添加行，像这样的事情。添加曲线，

146
00:07:37,491 --> 00:07:40,625
我可以添加这些基本上是绘制路径的东西，

147
00:07:40,694 --> 00:07:43,461
对，就像一条线在四处移动。所以我会

148
00:07:43,529 --> 00:07:47,565
做一个圆圈。所以我会用一个叫做addArc的。

149
00:07:47,634 --> 00:07:51,670
一个addArc是有点酷，这就像需要一个点和

150
00:07:51,738 --> 00:07:55,240
然后围绕着一个圆圈大圆弧。

151
00:07:55,308 --> 00:07:57,876
而我只是要用这个来解决这个问题

152
00:07:57,944 --> 00:08:01,079
创建一个圈子。所以当addArc创建一个路径时，

153
00:08:01,148 --> 00:08:03,581
它想知道这个通告的中心是什么

154
00:08:03,650 --> 00:08:04,982
你正在走的道路。

155
00:08:05,051 --> 00:08:08,286
而且我会把它作为我绘画区域的中心。和

156
00:08:08,355 --> 00:08:12,924
什么矩形指定我的绘图区域？边界，好吧，我的

157
00:08:12,992 --> 00:08:16,460
var边界这样做。所以我要在这里创建一个CGPoint，

158
00:08:16,529 --> 00:08:19,531
其中，x坐标是我的bounds中点。

159
00:08:19,599 --> 00:08:22,900
而我要创建y坐标是我的bounds

160
00:08:22,969 --> 00:08:26,204
y中点。所以我在中间指定

161
00:08:26,273 --> 00:08:29,240
我的绘画领域，这是我的bounds。半径，

162
00:08:29,309 --> 00:08:33,111
我只是要做100分，好的大圆圈。

163
00:08:33,179 --> 00:08:36,414
这里的起始角度和结束角度是弧度，

164
00:08:36,482 --> 00:08:40,452
不是度数，不是0到360，它是弧度，0到2 pi。

165
00:08:40,520 --> 00:08:43,421
每个人都知道弧度吗？如果你知道什么是弧度。

166
00:08:43,489 --> 00:08:46,958
好吧，大家好，所以0到2 pi。而0，顺便说一下，

167
00:08:47,027 --> 00:08:50,228
是在右边。 0不是直线上升，

168
00:08:50,297 --> 00:08:52,163
就像你想象的那样，它是在右边。

169
00:08:52,232 --> 00:08:53,664
所以我要从右边开始

170
00:08:53,733 --> 00:08:55,233
我要绕着我的圈子走。

171
00:08:55,302 --> 00:08:56,867
我可以顺时针或逆时针走，

172
00:08:56,936 --> 00:08:58,869
没关系，因为我一路走来。所以

173
00:08:58,938 --> 00:09:01,406
我怎么走？那么，这是pi的2倍。和

174
00:09:01,474 --> 00:09:06,477
在这里有一个非常好的，不断的，

175
00:09:06,546 --> 00:09:10,448
CGFloat.pi。好的，这就是我如何能在一个CG中获得pi，

176
00:09:10,517 --> 00:09:12,217
作为CGFloat。我可以顺时针或

177
00:09:12,285 --> 00:09:16,354
逆时针，没关系。好，那么

178
00:09:16,423 --> 00:09:18,790
现在我已经创建了一些路径，一些在这里绘图。

179
00:09:18,858 --> 00:09:21,526
所以我可以在我的情况下做其他事情，

180
00:09:21,595 --> 00:09:25,230
例如，我可以设置LineWidth，而不是LineCap

181
00:09:25,298 --> 00:09:28,433
LineWidth，5点宽。这是一个相当厚实，

182
00:09:28,502 --> 00:09:32,136
不是超厚的，而是合理的。我，当然，

183
00:09:32,205 --> 00:09:35,440
可以设置我想用这些静态绘制的颜色

184
00:09:35,508 --> 00:09:39,811
在UIColor的变种。比方说，我们的setFill绿色。

185
00:09:39,879 --> 00:09:42,680
这是我们最喜欢的填充颜色。和UIColor.red为

186
00:09:42,748 --> 00:09:47,018
我们的笔画颜色。好吧，我可以设置任何颜色。和

187
00:09:47,087 --> 00:09:52,524
那么我可以问上下文，例如，stroke path。

188
00:09:52,592 --> 00:09:56,928
所以让我们在这里做strokePath。你会认为我可以

189
00:09:56,996 --> 00:10:01,166
说context.fillPath。让我们看看这是否会stroke和

190
00:10:01,234 --> 00:10:04,401
填充，而不会。原因是那个时候

191
00:10:04,470 --> 00:10:07,972
我们在上下文中绘制，实际上稍有不同

192
00:10:08,040 --> 00:10:10,875
比使用我在幻灯片中展示的UIBezierPath。

193
00:10:10,943 --> 00:10:14,879
在上下文中，当我们这样做一个strokePath的时候，

194
00:10:14,947 --> 00:10:19,483
它消耗的路径。好吧，它用完了路径。所以

195
00:10:19,552 --> 00:10:22,153
当我们在下一行做fillPath的时候，没有路径。

196
00:10:22,222 --> 00:10:24,355
我们必须重新开始。所以

197
00:10:24,424 --> 00:10:26,790
这是UIBezierPath的一大优势。所以

198
00:10:26,859 --> 00:10:30,862
让我们在这里做同样的事情，但使用UIBezierPath，

199
00:10:30,931 --> 00:10:35,032
好吧？所以我要说让路径= UIBezierPath。

200
00:10:35,101 --> 00:10:36,400
我们将从一个空的开始。

201
00:10:36,469 --> 00:10:38,903
它，我会告诉你如何创建一个贝塞尔路径

202
00:10:38,972 --> 00:10:42,307
从一条路径开始。然后我可以做同样的事情，

203
00:10:42,375 --> 00:10:45,776
几乎完全相同的方法如上。事实上，

204
00:10:45,845 --> 00:10:49,514
我要在这里复制和粘贴完全相同的代码。

205
00:10:49,582 --> 00:10:52,416
在UIBezierPath中，名称稍有不同，

206
00:10:52,485 --> 00:10:55,219
但他们正在做同样的事情，如lineWidth。

207
00:10:55,288 --> 00:10:56,520
你不要说setLineWidth，

208
00:10:56,589 --> 00:11:00,692
这只是对这些对象的一个​​变种。所以你把它设置为5.0。

209
00:11:00,760 --> 00:11:06,230
你仍然通过这样设置你的颜色。和

210
00:11:06,299 --> 00:11:10,668
这里的区别，虽然，我可以说path.stroke。

211
00:11:10,737 --> 00:11:13,204
那个路径，那个UIBezierPath，

212
00:11:13,272 --> 00:11:16,808
仍然作为一个对象存在，所以我可以说path.fill。

213
00:11:16,876 --> 00:11:18,342
我也可以移动路径或

214
00:11:18,411 --> 00:11:20,611
把它缩小一点，然后再敲一下。

215
00:11:20,680 --> 00:11:23,247
你看我在说什么？所以我可以使用我建立的这条路

216
00:11:23,316 --> 00:11:26,584
这个弧线一遍又一遍。这就是整个问题

217
00:11:26,653 --> 00:11:31,022
这种类型的构建在这个结构体中，还是这个类，

218
00:11:31,091 --> 00:11:32,790
UIBezierPath。所以我们会摆脱这一点。

219
00:11:32,859 --> 00:11:35,726
让我们看看这是什么。这将是

220
00:11:35,795 --> 00:11:39,030
非常相似，但是，当然，它会stroke和

221
00:11:39,099 --> 00:11:43,101
填写该路径。哎呀，我按播放？

222
00:11:48,841 --> 00:11:52,977
好吧，你看，它在那里抚摸着，充满了。

223
00:11:53,046 --> 00:11:55,480
好吧，现在我们在这里看着一个圆圈，

224
00:11:55,548 --> 00:11:57,248
我会做一些有趣的事情。

225
00:11:57,317 --> 00:12:01,286
我要旋转这个手机风景。和什么形状

226
00:12:01,354 --> 00:12:04,189
你认为我们会在这里？任何人都想猜？

227
00:12:05,859 --> 00:12:09,994
不幸的是，不是一个圆圈。我们希望它是一个圆圈，但是

228
00:12:10,063 --> 00:12:15,400
这是一个椭圆形。那么为什么我们得到这个？因为默认情况下，

229
00:12:15,469 --> 00:12:18,302
当你改变你的试图的bounds，

230
00:12:18,371 --> 00:12:22,973
它只需要这些位并将它们缩放到新的尺寸。

231
00:12:23,042 --> 00:12:25,542
有时这可能是你想要的，但是

232
00:12:25,611 --> 00:12:28,579
很多时候，这绝对不是你想要的，

233
00:12:28,648 --> 00:12:32,083
对？那么我们如何阻止呢？那么，我们想要做的是

234
00:12:32,152 --> 00:12:36,421
当我们改变我们的bounds和重新调用这个代码

235
00:12:36,489 --> 00:12:38,923
让我们在新的空间再次画圆。所以

236
00:12:38,991 --> 00:12:42,893
我们该怎么做？让我们回到我们的故事板这里，

237
00:12:42,962 --> 00:12:47,231
看看我们的看法。如果我们检查我们的视图，

238
00:12:47,300 --> 00:12:51,769
内容模式首先是检查员的顶部，

239
00:12:51,837 --> 00:12:53,771
比例填充，对不对？

240
00:12:53,840 --> 00:12:57,508
所以当边界发生变化时，它会缩放比特以填充。和

241
00:12:57,577 --> 00:13:01,713
我们想改变这个重画。所以内容模式重绘

242
00:13:01,781 --> 00:13:05,316
意味着当我的边界改变时再次调用我的绘制矩形。所以

243
00:13:05,385 --> 00:13:10,454
现在当我们跑步时，我们可以看到我们的圈子。和

244
00:13:10,523 --> 00:13:13,558
当我们旋转到风景，我要重绘，和

245
00:13:13,626 --> 00:13:16,360
因此，把它画成一个圆圈，这是我的意图。

246
00:13:16,429 --> 00:13:17,895
Tha是我们的绘图代码，

247
00:13:17,964 --> 00:13:20,031
它画了一个圆圈。所以这一点很重要，

248
00:13:20,100 --> 00:13:22,200
特别是在你的作业。你正在做这些设置卡。

249
00:13:22,268 --> 00:13:24,802
你得到了你的squ，，钻石，等等。

250
00:13:24,870 --> 00:13:27,438
你什么时候，如果你的界限是在一张卡片上改变的，

251
00:13:27,507 --> 00:13:30,007
你不希望它像挤压其他一样

252
00:13:30,076 --> 00:13:35,012
形状。好的，这样就足够了

253
00:13:35,081 --> 00:13:39,049
用Core Graphics和

254
00:13:39,118 --> 00:13:43,921
UIBezierPath。让我们现在安定下来画一张卡片。

255
00:13:43,989 --> 00:13:49,793
现在什么是卡的部分？我们已经有了角落，

256
00:13:49,862 --> 00:13:52,130
对？卡的角落，这是排名和

257
00:13:52,198 --> 00:13:54,932
在角落里的西装。在中间，我们也有

258
00:13:55,001 --> 00:13:57,801
某种脸上的卡片图像，或者我们有一堆点子。

259
00:13:57,870 --> 00:14:00,304
这些小东西叫做点子。心和俱乐部和

260
00:14:00,373 --> 00:14:02,940
钻石，我们在那里得到了一堆点子。所以，就是这样

261
00:14:03,008 --> 00:14:05,810
我们如何建立我们的卡。但实际上，卡片有

262
00:14:05,878 --> 00:14:08,446
另一件事，几乎总是有圆润的边缘，

263
00:14:08,514 --> 00:14:10,948
对？你知道，如果你曾经玩过牌，

264
00:14:11,017 --> 00:14:13,718
你不希望锋利的边缘因为它捕捉的东西和

265
00:14:13,787 --> 00:14:15,753
像这样的东西。所以你需要漂亮的圆边。所以

266
00:14:15,822 --> 00:14:18,722
让我们从头开始，画出我们卡的背景

267
00:14:18,791 --> 00:14:21,725
作为一个四舍五入。现在你真的知道如何做到这一点

268
00:14:21,794 --> 00:14:23,527
使用UI视图的图层，

269
00:14:23,596 --> 00:14:26,197
这是分配两个提示。但

270
00:14:26,265 --> 00:14:29,667
我要直接使用UIBezierPath来绘制它。所以我

271
00:14:29,736 --> 00:14:34,572
只是要在这里说，实际上，让路径，或者你可以称之为

272
00:14:34,640 --> 00:14:39,443
一个roundedRect因为这是我想要的，在我的背景下，

273
00:14:39,512 --> 00:14:43,180
= UIBezierPath。而且我将使用不同的构造函数

274
00:14:43,249 --> 00:14:45,616
比我以前使用。而且你看到有很多

275
00:14:45,684 --> 00:14:50,555
椭圆和rects，但是这里是一个用于roundedRect的。所以

276
00:14:50,623 --> 00:14:52,523
我会得到，做这个roundRect。

277
00:14:52,592 --> 00:14:56,026
这是问我你在哪里roundRect适合。

278
00:14:56,095 --> 00:14:58,396
所以我显然希望它在我的范围内。

279
00:14:58,464 --> 00:15:00,631
这将填补我的全部范围。

280
00:15:00,700 --> 00:15:04,034
然后这个角落半径是多少点的半径

281
00:15:04,103 --> 00:15:08,072
转角是。而现在我要成立

282
00:15:08,140 --> 00:15:12,176
那到一个魔术数字。我们不是真的想要蓝色，

283
00:15:12,245 --> 00:15:15,713
这是文字。我们不希望这些在我们的代码。

284
00:15:15,781 --> 00:15:18,449
这些都很糟糕，我很快就会摆脱这一切

285
00:15:18,518 --> 00:15:21,552
这里。为什么我们不想要那些？因为如果我们真的，

286
00:15:21,620 --> 00:15:24,422
从字面上有这样的神奇数字，我们想收集

287
00:15:24,491 --> 00:15:27,024
他们都进入我们有常数的地方。

288
00:15:27,093 --> 00:15:28,192
所以我们可以修改它们

289
00:15:28,261 --> 00:15:30,428
了解我们选择的和所有的。

290
00:15:30,496 --> 00:15:31,863
我们不会通过我们的代码来传播这一切。

291
00:15:31,931 --> 00:15:34,365
如果我们要改变常量，

292
00:15:34,433 --> 00:15:37,267
我们正在寻找一个圆形的圆形。但现在，我们会的

293
00:15:37,336 --> 00:15:39,837
离开这个方式。好的，所以我得到了我的四舍五入。

294
00:15:39,906 --> 00:15:43,540
实际上，我要做的第一件事就是

295
00:15:43,609 --> 00:15:47,144
我会告诉它，我希望它成为剪辑区域

296
00:15:47,213 --> 00:15:50,148
我所有的绘画。所以我有这个不错的四舍五入，

297
00:15:50,216 --> 00:15:52,950
这是我的卡的边缘，我不想画外面

298
00:15:53,019 --> 00:15:56,821
那roundedRect。通过真理，我的绘画都必须在里面。

299
00:15:56,890 --> 00:15:58,922
现在，我不认为我会写任何代码

300
00:15:58,991 --> 00:16:01,792
外。但在你的任务三，你可能会。

301
00:16:01,861 --> 00:16:03,894
因为在任务三，你将不得不画

302
00:16:03,963 --> 00:16:06,964
波浪形状。用弧和线或什么的，和

303
00:16:07,033 --> 00:16:09,800
那么其中一种填充模式是条纹。所以你会有

304
00:16:09,869 --> 00:16:12,102
在那里画条纹。那么，想象一下，画一个

305
00:16:12,171 --> 00:16:14,671
条纹从一个波浪的边缘到另一个边缘。

306
00:16:14,740 --> 00:16:16,707
这几乎是不可能的。

307
00:16:16,776 --> 00:16:19,543
更好，如果你只是你的squigle是一个路径，

308
00:16:19,612 --> 00:16:22,880
添加它作为剪辑，现在你可以绘制这些线条，

309
00:16:22,949 --> 00:16:25,783
就像你在一本着色书里两岁的时候，

310
00:16:25,852 --> 00:16:27,918
画出他们的路径。它会被裁剪，所以

311
00:16:27,987 --> 00:16:30,287
这一切都在里面。你明白你为什么要裁剪？

312
00:16:30,356 --> 00:16:33,390
所以在这里我不在乎，但我只是想告诉你什么

313
00:16:33,459 --> 00:16:36,727
它看起来像这样的。现在，我想要我的卡

314
00:16:36,796 --> 00:16:41,531
当然是白色，所以我会说UIColor.white.setFill（）。

315
00:16:41,600 --> 00:16:44,835
然后我要填补我的四舍五入。我的四舍五入是

316
00:16:44,904 --> 00:16:48,239
只是一个贝塞尔的路径，所以我可以说填充。

317
00:16:48,307 --> 00:16:51,875
所以让我们来看看。这工作，因为现在，希望，

318
00:16:51,944 --> 00:16:57,314
我们应该为我们的卡四舍五入。而我们不。

319
00:16:57,383 --> 00:17:00,685
看到它在这里仍然有锋利的边缘，看到这些锋利的边缘

320
00:17:00,753 --> 00:17:03,487
就在这儿？为什么这仍然有尖锐的边缘？

321
00:17:03,556 --> 00:17:06,590
那么，实际上，这个代码工作完美。它画了

322
00:17:06,659 --> 00:17:11,495
在白色背景的一个完善的白色被舍入的rect。所以

323
00:17:11,564 --> 00:17:13,831
我们看不到它，它坐在一个白色的背景上。

324
00:17:13,900 --> 00:17:16,600
所以我们需要回到我们的故事板，

325
00:17:16,669 --> 00:17:20,537
并改变这个，以便它不是白色的背景。所以

326
00:17:20,606 --> 00:17:23,707
我们想要什么颜色的背景？其实，

327
00:17:23,776 --> 00:17:28,345
我们希望它是清楚的。因为当我们画一个四舍五入

328
00:17:28,414 --> 00:17:30,948
总之，我们希望看到的部分

329
00:17:31,017 --> 00:17:33,517
四舍五入的角落，无论在哪里

330
00:17:33,586 --> 00:17:35,586
的背景。所以我们希望它是清楚的。但

331
00:17:35,654 --> 00:17:37,855
只要我们开始谈论清楚和

332
00:17:37,924 --> 00:17:42,059
我们认为透视，我们需要谈论

333
00:17:42,128 --> 00:17:45,696
这个开关在这里，是不透明的开关。

334
00:17:45,764 --> 00:17:49,734
正如我在讲座中所说的，这是默认的，并且

335
00:17:49,802 --> 00:17:51,968
假设你没有任何透视的部分，

336
00:17:52,037 --> 00:17:54,771
没有透明度，而且在绘制时效率会更高。

337
00:17:54,840 --> 00:17:57,674
所以如果我们确实使用效率较低的透明度，

338
00:17:57,743 --> 00:17:58,543
但我们在这里需要它，

339
00:17:58,611 --> 00:18:00,511
因为我们需要我们的角落来展示，

340
00:18:00,580 --> 00:18:04,281
我们必须关掉这个。所以不要忘记把它关掉，

341
00:18:04,350 --> 00:18:08,619
如果你要在你看来做任何透明的事情。

342
00:18:08,687 --> 00:18:12,289
好的，现在我们已经四舍五入了。你看到圆形

343
00:18:12,358 --> 00:18:15,860
就在那里，我们在风景和景观都有

344
00:18:15,928 --> 00:18:18,462
肖像，好的。所以这很好。好的，我们走了

345
00:18:18,531 --> 00:18:21,298
一个好的开始。现在，我们要做我们的角落。

346
00:18:21,367 --> 00:18:25,135
所以，我们的角落，记住，是排序和西装，我要走了，

347
00:18:25,204 --> 00:18:28,072
它实际上可能会更容易绘制角落

348
00:18:28,141 --> 00:18:31,108
与一个NSAttributedString，直接在我的drawRect。

349
00:18:31,177 --> 00:18:34,011
大概可以做五行代码。

350
00:18:34,080 --> 00:18:37,415
但是，我会用15行代码

351
00:18:37,483 --> 00:18:38,983
用UI标签来做。

352
00:18:39,051 --> 00:18:42,453
因为我想告诉你如何建立你的用户界面视图，

353
00:18:42,522 --> 00:18:46,690
出于其他观点，通过使他们对你的子视图。然后

354
00:18:46,759 --> 00:18:50,528
我们会用drawRect来做一些其他的绘图，这也是

355
00:18:50,596 --> 00:18:53,697
只有几条线路，都非常有效。

356
00:18:53,766 --> 00:18:57,768
所以我要如何在我的用户界面标签上做这个，我是要创建的

357
00:18:57,837 --> 00:19:01,438
使用属性字符串作为文本的UI标签。

358
00:19:01,507 --> 00:19:06,777
这个属性字符串将会看起来像这样。

359
00:19:06,846 --> 00:19:08,679
所以，如果它有，为了

360
00:19:08,748 --> 00:19:12,249
比方说，让我们选择五颗心。所以

361
00:19:12,318 --> 00:19:15,853
我正在做五个人的心，这是我的角落

362
00:19:15,921 --> 00:19:18,455
大牌。所以我只是要创建一个属性字符串，

363
00:19:18,524 --> 00:19:21,592
这是五回车，

364
00:19:21,660 --> 00:19:25,162
心。这是我要创建的属性字符串。至

365
00:19:25,231 --> 00:19:29,233
做这个工作，我的属性字符串需要两个属性。

366
00:19:29,302 --> 00:19:31,268
属性字符串有属性，我只需要两个。

367
00:19:31,337 --> 00:19:34,705
一个是字体的大小。我想让字体变大

368
00:19:34,773 --> 00:19:38,008
卡大，小字体，如果我的卡很小。

369
00:19:38,077 --> 00:19:40,578
另一件事是这个需要被集中，

370
00:19:40,646 --> 00:19:43,814
因为我不希望这五个在这里，排队

371
00:19:43,883 --> 00:19:46,884
心脏的左边缘。我想要五个中心

372
00:19:46,952 --> 00:19:50,054
心，对不对？我可能会像十颗心一样。

373
00:19:50,123 --> 00:19:52,556
这十个实际上可能比心脏更广泛。但

374
00:19:52,625 --> 00:19:54,425
我想要把这两件事情集中起来。所以

375
00:19:54,494 --> 00:19:56,693
我会告诉你一个属性的字符串，

376
00:19:56,762 --> 00:20:00,130
如何做字体，以及如何对文字进行对中。所以

377
00:20:00,199 --> 00:20:04,368
让我们来创造一些实用的功能。

378
00:20:04,437 --> 00:20:08,239
漂亮的通用功能。我会调用给它，

379
00:20:08,308 --> 00:20:12,876
这将是私人的，我会调用给它

380
00:20:12,945 --> 00:20:18,782
centeredattributedString。那么这个功能呢

381
00:20:18,851 --> 00:20:22,119
要做的是它会采取一个字符串和字体大小，和

382
00:20:22,188 --> 00:20:25,389
返回一个以该字体为中心的NSattributedString

383
00:20:25,457 --> 00:20:28,025
尺寸。所以这是一个字符串，

384
00:20:28,094 --> 00:20:31,128
一些字符串作为我们要做的字符串。在我们的情况下，

385
00:20:31,196 --> 00:20:34,698
这将是五个回车的心脏，它会

386
00:20:34,766 --> 00:20:39,036
采取一些字体大小。字体大小当然是CGFloats，

387
00:20:39,104 --> 00:20:42,907
图中的所有照片点编号都是CGFloat和

388
00:20:42,975 --> 00:20:47,011
它会返回一个NSAattributedString。所以

389
00:20:47,080 --> 00:20:49,446
这就是这个小功能要做的事情。

390
00:20:49,515 --> 00:20:52,716
因为我们需要这个绘制这个角落的一块。好的，

391
00:20:52,785 --> 00:20:53,651
我们先做字体吧。

392
00:20:53,719 --> 00:20:55,886
所以我要创建一个字体。要做到这一点，

393
00:20:55,954 --> 00:20:59,523
我要使用这些首选字体。因为这张卡，

394
00:20:59,592 --> 00:21:02,159
卡上有什么，是用户信息，所以

395
00:21:02,228 --> 00:21:04,929
我想使用首选字体，而不是像系统字体或

396
00:21:04,997 --> 00:21:07,264
任何东西。所以我用UIFont来做

397
00:21:07,333 --> 00:21:10,835
静态方法，preferredFont（forTextStyle。

398
00:21:10,903 --> 00:21:14,705
在文本样式中，我要使用的是.body，body字体，

399
00:21:14,773 --> 00:21:17,874
因为它实际上不是一个标题或一个脚注或

400
00:21:17,943 --> 00:21:21,812
标题，这是一种正文。但我会扩大规模

401
00:21:21,881 --> 00:21:25,015
幸运的是，你可以用withSize来表示字体

402
00:21:25,084 --> 00:21:26,851
给它你想要的fontSize，

403
00:21:26,919 --> 00:21:30,287
这是我的方法这个参数。所以这很好

404
00:21:30,356 --> 00:21:32,389
我已经创建了首选字体，正文字体和

405
00:21:32,458 --> 00:21:34,224
我已经把它缩放到我想要的尺寸。

406
00:21:34,293 --> 00:21:37,093
我得弄清楚我的卡片有多大。

407
00:21:37,162 --> 00:21:39,530
但是这有一个大问题。

408
00:21:39,599 --> 00:21:43,366
如果有人继续，我们在这里去模拟器。

409
00:21:43,435 --> 00:21:44,701
我的模拟器在哪里？和

410
00:21:44,770 --> 00:21:49,006
如果我在设备上转到“设置”，然后转到“常规”

411
00:21:49,074 --> 00:21:53,277
无障碍，更大的文字。看，我有一个小滑块

412
00:21:53,346 --> 00:21:57,180
这可以改变我的所有应用程序中的文本的大小。

413
00:21:57,249 --> 00:22:00,951
那么，除非我处理，否则我的所有应用程序都不会包含此应用

414
00:22:01,019 --> 00:22:05,322
事实上，我在这里固定的字体大小。所以我呢

415
00:22:05,391 --> 00:22:08,291
真的想要的是，这是这个字体大小，但是

416
00:22:08,360 --> 00:22:10,861
如果他们把这个滑块，我想它是更大和

417
00:22:10,930 --> 00:22:12,796
如果他们把这个滑块放下来，我希望它变小。

418
00:22:12,864 --> 00:22:15,766
幸运的是，有一个很好的方法可以做到这一点

419
00:22:15,835 --> 00:22:18,235
只需将字体重置为相同的UIFontMetrics。

420
00:22:18,304 --> 00:22:22,573
所以这个UIFontMetrics在它里面有一个很棒的功能

421
00:22:22,641 --> 00:22:26,276
可以为特定的文本样式创建字体指标。

422
00:22:26,345 --> 00:22:28,946
再次，身体字体在那里。和

423
00:22:29,015 --> 00:22:33,450
那么你可以从另一种字体得到缩放的字体。所以

424
00:22:33,519 --> 00:22:36,386
你只要给它一个字体，这个我在这里创建的，

425
00:22:36,455 --> 00:22:40,357
它会根据那个小滑块进行缩放。所以

426
00:22:40,426 --> 00:22:43,360
不要忘记这行代码。否则，用户

427
00:22:43,429 --> 00:22:46,163
视力受损的人，甚至像我这样的老人，

428
00:22:46,232 --> 00:22:49,033
谁，你知道，需要大字体，我们设置一个更高一点，

429
00:22:49,101 --> 00:22:52,036
和你的应用程序不会去做。你的卡片，

430
00:22:52,104 --> 00:22:54,371
你的纸牌，还会有小文本，所以

431
00:22:54,440 --> 00:22:57,775
如果你在做字体，不要忘记这一行。

432
00:22:57,843 --> 00:22:59,143
好的，如何对中，

433
00:22:59,211 --> 00:23:00,710
我想把五个中心放在心上。

434
00:23:00,779 --> 00:23:04,748
那么，我们会用另一个小类型来做到这一点

435
00:23:04,817 --> 00:23:08,285
叫段落风格。我要创造

436
00:23:08,354 --> 00:23:13,157
一个NSMutableParagraphStyle。所以paragraphStyle

437
00:23:13,226 --> 00:23:15,125
封装了一个段落的所有内容，

438
00:23:15,194 --> 00:23:18,428
像它的对齐和类似的东西。所以我只是设置

439
00:23:18,497 --> 00:23:20,998
无论我想在那里。就像在这种情况下，我想

440
00:23:21,067 --> 00:23:23,667
要设置的路线，我要把它设置为中心。所以

441
00:23:23,735 --> 00:23:27,238
这使得整个文本段落都集中在一起

442
00:23:27,306 --> 00:23:30,875
水平。就是这样了。现在，我可以回来了

443
00:23:30,943 --> 00:23:33,110
具有这些属性的NSAttributedString，

444
00:23:33,179 --> 00:23:36,547
我很好走。所以让我们使用相同的

445
00:23:36,615 --> 00:23:42,052
我们之前使用的确切初始化器。所以这里是字符串。

446
00:23:42,121 --> 00:23:44,521
这是这里的函数的参数，字符串。

447
00:23:44,590 --> 00:23:46,089
然后在这里的属性，

448
00:23:46,158 --> 00:23:47,991
我只是要把字典放进去。

449
00:23:48,060 --> 00:23:49,627
我不会把它放在另一个酒吧，或者

450
00:23:49,695 --> 00:23:53,464
这样的事情让我们把它放进去，所以我

451
00:23:54,800 --> 00:23:59,770
为NSAttributedStringKey .paragraphStyle做

452
00:23:59,839 --> 00:24:03,907
例。所以这是关键之一，价值就是这个

453
00:24:03,976 --> 00:24:07,411
我刚创建的段落风格，然后我也可以做.font

454
00:24:07,479 --> 00:24:10,480
的字体。注意，我不必每次都输入这个。

455
00:24:10,549 --> 00:24:13,316
事实上，我甚至不必第一次打字，

456
00:24:13,385 --> 00:24:18,254
因为Swift知道这个东西需要什么类型的参数。

457
00:24:18,323 --> 00:24:23,193
所以，它会自动推断出这部分。所以

458
00:24:23,262 --> 00:24:26,930
而已。好的，很好的可重用的功能，将创建此

459
00:24:26,999 --> 00:24:29,032
这种归因力量。所以

460
00:24:29,101 --> 00:24:33,403
现在我要创建一个小的私人变种，我会

461
00:24:33,472 --> 00:24:38,308
调用cornerString。串，

462
00:24:38,377 --> 00:24:42,245
它只是要返回一个centeredAttributedString

463
00:24:42,314 --> 00:24:46,716
这个，五个在心上。所以不知何故，我需要有我的

464
00:24:46,785 --> 00:24:51,622
等级加上回车，+suit，然后我会去，

465
00:24:51,691 --> 00:24:55,792
哇，那么我将需要一些字体大小。

466
00:24:55,861 --> 00:24:57,160
谁知道那会是什么？

467
00:24:57,229 --> 00:24:58,596
那么我不得不谈论这个，

468
00:24:58,664 --> 00:25:01,898
因为它的字体大小。这将取决于

469
00:25:01,967 --> 00:25:05,702
我的卡有多大我的卡很大，那会很大。

470
00:25:05,771 --> 00:25:07,537
所以我们在这里有几件事要处理。一，

471
00:25:07,606 --> 00:25:10,441
我们需要排名和西装。所以扑克牌必须有

472
00:25:10,509 --> 00:25:13,577
某种方式来设置等级和套装。现在，我要让我的

473
00:25:13,645 --> 00:25:17,648
等级是一个整数，我会让我的西装是一个字符串。

474
00:25:19,051 --> 00:25:21,885
现在这与我们的模型是不同的。

475
00:25:21,954 --> 00:25:25,088
模型有排名和字符串是枚举，请记住？

476
00:25:25,157 --> 00:25:28,124
但谁在乎？这是一个观点，它对此一无所知

477
00:25:28,193 --> 00:25:31,862
模型。这是一个通用的卡片图纸视图。

478
00:25:31,930 --> 00:25:34,498
它对这个特定的模型一无所知。所以

479
00:25:34,567 --> 00:25:36,333
它代表了它的等级和事实

480
00:25:36,401 --> 00:25:39,703
以完全不同的方式适应，完美的罚款。

481
00:25:39,772 --> 00:25:43,140
谁的工作是在模型和视图之间进行转换？

482
00:25:43,209 --> 00:25:45,709
当然，控制器。所以，你会看到代码

483
00:25:45,778 --> 00:25:48,845
在我们的控制器之间转换模型之间，

484
00:25:48,914 --> 00:25:52,382
想到这个视图是什么等级和套装。

485
00:25:52,451 --> 00:25:53,450
我也是，我不想要

486
00:25:53,518 --> 00:25:55,686
作为一个初始化器，它被用作没有初始化器。所以

487
00:25:55,754 --> 00:26:01,458
让我们开始吧，让我们从Hearts的这个5，5开始。

488
00:26:01,527 --> 00:26:07,263
让我从这里抓住一颗心。这里的心，

489
00:26:07,332 --> 00:26:10,300
复制。好吧。所以我们就有五颗心和

490
00:26:10,368 --> 00:26:12,969
还有另外一个东西，就是这个牌面

491
00:26:13,038 --> 00:26:17,341
或面朝下？所以我需要一个isfaceup。她是公牛，而且

492
00:26:17,409 --> 00:26:20,544
我们将从头开始，让我们说。现在，

493
00:26:20,613 --> 00:26:25,015
当你有这样的视觉影响方式的变数

494
00:26:25,084 --> 00:26:29,686
视图会画出来，你必须考虑这个事实

495
00:26:29,755 --> 00:26:35,025
如果这改变了排名，你的观点需要重新绘制自己，

496
00:26:35,093 --> 00:26:38,929
对？如果你改变了排名，你必须重画。所以

497
00:26:38,998 --> 00:26:43,633
你是怎样做的？对于didSet来说，这是非常好用的。

498
00:26:43,702 --> 00:26:45,669
所以当这个排名变化的时候

499
00:26:45,737 --> 00:26:50,407
有人将排名设置为11，对于杰克，我们必须重绘。

500
00:26:50,475 --> 00:26:52,976
我们如何让自己重新绘制？大家记得吗？

501
00:26:53,044 --> 00:26:58,248
setNeedsDisplay

502
00:26:58,317 --> 00:27:00,317
所以这会导致我们的drawRect被调用，

503
00:27:00,386 --> 00:27:03,119
最终。所以我们不能直接调用我们的drawRect。我们刚刚

504
00:27:03,188 --> 00:27:07,257
不得不告诉系统，嘿，我们需要显示。

505
00:27:07,325 --> 00:27:10,227
我们的观点还有另一个需要发生的事情。

506
00:27:10,295 --> 00:27:13,297
我们有子视图放弃我们的观点的一部分，所以

507
00:27:13,366 --> 00:27:16,132
我们需要有这些子视图。

508
00:27:16,201 --> 00:27:19,670
现在，我们没有在子视图中使用自动布局，

509
00:27:19,738 --> 00:27:23,640
我们把他们放在角落里的地方，但是

510
00:27:23,709 --> 00:27:27,310
我们仍然需要说setNeedsLayout。所以

511
00:27:27,379 --> 00:27:28,478
我们的子视图得到了布置。

512
00:27:28,547 --> 00:27:31,081
现在，如果你没有任何子视图，你不必这样说

513
00:27:31,150 --> 00:27:32,516
那需要铺设，或者

514
00:27:32,584 --> 00:27:35,418
不受等级变化的影响。在我们的情况下，

515
00:27:35,487 --> 00:27:37,721
它绝对确实改变了排名。所以

516
00:27:37,790 --> 00:27:40,958
我们会在这里为我们所有的小公共汽车这样做，

517
00:27:41,026 --> 00:27:43,460
因为如果人们改变这些事情

518
00:27:43,529 --> 00:27:46,195
这将改变我们的卡的外观。

519
00:27:46,264 --> 00:27:49,700
不要忘了这件事，总是要这样做，

520
00:27:49,768 --> 00:27:52,802
这两者中的任何一个，或者两者都有，每次都有

521
00:27:52,871 --> 00:27:56,306
一个公众变种，有人可以改变你的卡的外观。

522
00:27:57,443 --> 00:28:00,677
好吧，现在，我们有排名和诉讼。

523
00:28:00,746 --> 00:28:04,581
不幸的是，排名是int，所以我不能说rank + suit。和

524
00:28:04,650 --> 00:28:07,250
那么还有，我在这里有这个魔法数字的问题，

525
00:28:07,319 --> 00:28:08,785
不知何故，我必须选择一个字体大小。

526
00:28:08,854 --> 00:28:11,554
所以为了加速这个演示的一点点，

527
00:28:11,623 --> 00:28:16,359
我其实有一点扩展我的扑克牌。

528
00:28:16,428 --> 00:28:19,763
哎呀，就在这里，这个小小的延伸就在这里。

529
00:28:19,831 --> 00:28:22,732
这是它的全部，它不是很大。和

530
00:28:22,801 --> 00:28:25,769
这已经抓住了我所有的小蓝数字，

531
00:28:25,838 --> 00:28:31,508
我的神奇数字，作为静态的结构。

532
00:28:31,577 --> 00:28:36,813
所以这就是我们在Swift中做常量的方法。

533
00:28:36,881 --> 00:28:40,717
我们做一个私人结构，我们给它一个名字，有时它

534
00:28:40,786 --> 00:28:43,653
可能被称为常量。我叫它SizeRatio，

535
00:28:43,722 --> 00:28:46,623
因为我所有的常数都是关于比例的

536
00:28:46,692 --> 00:28:50,026
的角落，或字体，到我的卡的大小。

537
00:28:50,095 --> 00:28:51,828
所以我称之为SizeRatio。

538
00:28:51,897 --> 00:28:54,998
然后在这里，我有cornerFontSizeToBoundsHeight，

539
00:28:55,067 --> 00:28:57,133
我有cornerRadiusToBoundsHeight，

540
00:28:57,202 --> 00:28:59,036
我有cornerOffsetToCornerRadius，

541
00:28:59,105 --> 00:29:00,904
我有faceCardImageSizeToBoundsSize。

542
00:29:00,972 --> 00:29:04,341
这些都是我挑选的比例，我认为会

543
00:29:04,409 --> 00:29:06,943
看起来不错。然后我甚至创造了一些计算

544
00:29:07,012 --> 00:29:10,146
像cornerRadius这样的属性，需要高度和

545
00:29:10,215 --> 00:29:14,117
乘以比例。所以这是它的样子

546
00:29:14,186 --> 00:29:17,887
使用一个这样宣布的常量，SizeRatio.whatever，

547
00:29:17,956 --> 00:29:21,558
或者如果你有一个常量，它可能是常量。

548
00:29:21,627 --> 00:29:25,328
你知道这个怎么样在这里看起来不错。

549
00:29:25,397 --> 00:29:25,928
这就是我们如何做到的。

550
00:29:25,997 --> 00:29:27,063
所以我有这3件事情，

551
00:29:27,132 --> 00:29:29,966
cornerRadius，cornerOffset和cornerFontSize

552
00:29:30,035 --> 00:29:32,602
让我摆脱了蓝色的数字。

553
00:29:32,671 --> 00:29:35,438
相反，使用与我的大小有关的东西

554
00:29:35,507 --> 00:29:38,775
卡的高度。我也把这个人扔在这里，

555
00:29:38,843 --> 00:29:42,379
rankString只是一个将1变成A和11变成的变量

556
00:29:42,447 --> 00:29:45,849
J和12分成Q，其他所有分成几个。所以

557
00:29:45,918 --> 00:29:48,952
我可以有一个字符串，让我在这里上去的时候

558
00:29:49,021 --> 00:29:52,189
我在这里创建这个小字符串。代替

559
00:29:52,257 --> 00:29:55,358
说等级加字符加西装，我会说，

560
00:29:55,427 --> 00:29:57,660
等级字符串加字符术语加西装。

561
00:29:57,729 --> 00:30:00,797
这是这个，这意味着人物回归，对吗？

562
00:30:00,866 --> 00:30:02,598
去下一行。而现在，

563
00:30:02,667 --> 00:30:07,504
我的字体大小可以是这个cornerFontSize，其中之一，

564
00:30:07,572 --> 00:30:12,141
一旦我在这里创造。同样，我的角落Radius

565
00:30:12,210 --> 00:30:16,313
在这里，现在是16，现在可以成为cornerRadius。

566
00:30:16,381 --> 00:30:19,549
这是我创建的另一个。所以看看

567
00:30:19,618 --> 00:30:23,153
我是如何将所有常量隔离到这个不错的，

568
00:30:23,221 --> 00:30:24,821
我甚至用一些扩展名。

569
00:30:24,890 --> 00:30:26,523
这不会是一个延伸，但是

570
00:30:26,592 --> 00:30:29,325
我只是把它放在自己的空间。而当我在这里，

571
00:30:29,394 --> 00:30:32,162
顺便说一下，我还添加了一些扩展到CGRect和

572
00:30:32,230 --> 00:30:35,331
CGPoint就像放大矩形，或者放大一些东西，或者

573
00:30:35,400 --> 00:30:38,802
得到左边的一半，只是为了方便。

574
00:30:38,871 --> 00:30:40,770
这将使我的代码看起来更清洁。

575
00:30:40,839 --> 00:30:42,205
而且你已经知道如何做到这一点。

576
00:30:42,274 --> 00:30:43,940
我们用随机和整型的艺术来做到这一点，

577
00:30:44,009 --> 00:30:47,744
像这样的东西。好吧，所以我们正在接近

578
00:30:47,812 --> 00:30:50,346
现在就做这个工作。我们真正需要做的是

579
00:30:50,415 --> 00:30:53,717
创建这些UILabels。所以我要为他们创造一个变种，

580
00:30:53,786 --> 00:30:56,786
私人变种我会有一个upperLeft，

581
00:30:56,855 --> 00:30:59,222
upperLeftCornerLabel，好的，

582
00:30:59,291 --> 00:31:03,126
这将是键入UILabel。接着，

583
00:31:03,195 --> 00:31:08,732
我会有一个lowerRightCornerLabel

584
00:31:08,801 --> 00:31:13,336
到UILabel。现在，我需要创建这个UILabel，

585
00:31:13,405 --> 00:31:17,174
所以我要创建一个小功能来做到这一点，

586
00:31:17,243 --> 00:31:20,677
私人func createCornerLabel，它的

587
00:31:20,746 --> 00:31:24,081
只是要返回一个UILabel。这将是非常简单的。

588
00:31:24,149 --> 00:31:27,717
我只是要创建一个UILabel并返回它，但是

589
00:31:27,786 --> 00:31:31,254
我必须做一点这个配置。

590
00:31:31,323 --> 00:31:34,291
我们会在一秒钟之内做到这一点。所以在这里，而不是这个

591
00:31:34,359 --> 00:31:38,795
声明这个标签，我会说= createCornerLabel。

592
00:31:38,864 --> 00:31:42,632
然后在这里，createCornerLabel，oops，

593
00:31:42,701 --> 00:31:47,003
不是Repl_host，怎么样createCornerLabel。

594
00:31:47,072 --> 00:31:50,173
好吧，现在，这是一旦它赶上了我

595
00:31:50,242 --> 00:31:52,676
并编译，会创造这个错误。

596
00:31:52,744 --> 00:31:55,545
这是什么错误？不能使用实例成员

597
00:31:55,613 --> 00:31:59,316
属性初始值设定项中的'createCornerLabel'标签。

598
00:32:00,785 --> 00:32:03,319
那么，当然，我正在这里初始化一个属性，

599
00:32:03,388 --> 00:32:06,823
在这里，我正在试图自己调用一个方法。和

600
00:32:06,892 --> 00:32:09,125
我们知道，直到我们完全初始化，

601
00:32:09,194 --> 00:32:12,128
我们不能自己调用​​方法。所以有了这个，

602
00:32:12,197 --> 00:32:14,998
这是老渔获22，所以任何人想说我们怎么可能

603
00:32:15,067 --> 00:32:20,036
解决这个问题？好的。懒。好，大家好吧。

604
00:32:20,104 --> 00:32:21,872
懒惰，确切地说。所以懒得这么做

605
00:32:21,940 --> 00:32:24,708
这些东西直到他们才会被初始化

606
00:32:24,776 --> 00:32:26,660
这将是事后完全初始化。所以，

607
00:32:26,661 --> 00:32:28,545
被要求，

608
00:32:28,613 --> 00:32:31,681
这是平等的。好的，所以我们有这个UILabel。

609
00:32:31,750 --> 00:32:33,950
我们需要做些什么来初始化我们的标签？真

610
00:32:34,019 --> 00:32:38,387
只有几件事情。一个是我需要在标签上设置这个栏，

611
00:32:38,456 --> 00:32:41,624
这是行数，因为默认值是1。

612
00:32:41,693 --> 00:32:45,228
默认情况下，UILabel只有一行。所以如果我有两条线

613
00:32:45,297 --> 00:32:49,065
就像五颗心一样，只能看到五颗星。

614
00:32:49,134 --> 00:32:52,402
心脏不会被显示。所以我会把它改成0

615
00:32:52,471 --> 00:32:54,604
我可以将其更改为2，但是我会将其更改为0。

616
00:32:54,672 --> 00:32:57,841
先生，你的需要是什么意思？

617
00:32:57,909 --> 00:33:01,444
标签。所以我把它拿到0.所以这真的是唯一的

618
00:33:01,513 --> 00:33:04,648
我不得不说。唯一的我要做的事情

619
00:33:04,716 --> 00:33:07,584
这个标签是作为我自己的子视图添加的。

620
00:33:09,421 --> 00:33:11,788
如果我不添加它作为一个子视图，那么它不会在那里，

621
00:33:11,857 --> 00:33:14,223
它永远不会画。好的？所以我必须添加它作为一个子视图。

622
00:33:14,292 --> 00:33:16,993
所以你只需要创建一个CornerLabel即可。

623
00:33:17,062 --> 00:33:20,663
但是，我需要定位这些标签。

624
00:33:20,732 --> 00:33:22,098
我必须把它们放在正确的地方，对吧？所以

625
00:33:22,167 --> 00:33:24,667
我应该把一个在左上角，一个在下面

626
00:33:24,736 --> 00:33:28,638
对。那么，我在哪里做我的代码？好，

627
00:33:28,707 --> 00:33:32,742
我必须这样做每一次我的bounds变化，

628
00:33:32,811 --> 00:33:35,011
特别是对于右下角的那个。好的。

629
00:33:35,080 --> 00:33:37,447
左上角的那个实际上是靠近我的原点。

630
00:33:37,516 --> 00:33:40,450
无论我的bounds是什么，这可能是正确的。

631
00:33:40,518 --> 00:33:42,485
但是在左下角的景观中，

632
00:33:42,554 --> 00:33:45,221
这是正确的方式，而不是很远，然后进入

633
00:33:45,290 --> 00:33:47,924
肖像，它的方式，只有一点点，

634
00:33:47,992 --> 00:33:50,526
对？因此，右下角的人正在移动

635
00:33:50,595 --> 00:33:52,395
当我们的bounds变化的地方，

636
00:33:52,464 --> 00:33:54,230
当我们旋转或任何理由

637
00:33:54,299 --> 00:33:57,900
我们的bounds会改变。那么我们可以放在哪里

638
00:33:57,969 --> 00:34:00,703
一些代码，当我们的bounds改变时做些事情？

639
00:34:00,772 --> 00:34:04,775
这就是layoutSubviews所使用的方法。

640
00:34:04,843 --> 00:34:08,111
要UIView方法，请确保你调用超级，

641
00:34:08,179 --> 00:34:11,881
因为UIView在布置Subviews方面非常棒。

642
00:34:11,950 --> 00:34:16,452
它使用自动布局。所有这些我们正在做的自动布局的东西，

643
00:34:16,521 --> 00:34:19,288
这就是UIview知道如何布局的所有东西

644
00:34:19,357 --> 00:34:21,558
你的子视图。现在，这两个子视图，

645
00:34:21,626 --> 00:34:23,693
我没有做任何控制拖动。事实上，

646
00:34:23,762 --> 00:34:26,296
我在代码中创建它们，对不对？我创建了UILabel

647
00:34:26,365 --> 00:34:30,433
在这里代码。所以，我必须自己做布局，

648
00:34:30,501 --> 00:34:32,869
layoutSubviews是你做的地方。

649
00:34:32,938 --> 00:34:35,838
任何时候您的子视图都需要根据任何原因进行布局，

650
00:34:35,907 --> 00:34:38,875
这将被系统调用。你不叫它。

651
00:34:38,944 --> 00:34:43,179
如果你想调用它，你可以调用setNeedsLayout。

652
00:34:43,247 --> 00:34:46,249
和setNeedsLayout，系统最终会调用这个。

653
00:34:46,318 --> 00:34:48,651
就像你做setNeedsDisplay一样，

654
00:34:48,720 --> 00:34:51,254
系统最终会调用这个。好的？

655
00:34:51,322 --> 00:34:54,057
非常非常相似好的，所以我们现在布置子视图。

656
00:34:54,126 --> 00:34:58,394
我们要做的就是把这个UILabel，这个左上角，和

657
00:34:58,463 --> 00:35:01,064
右下角的标签，将它们移到正确的位置。那么让我们来做

658
00:35:01,132 --> 00:35:03,666
实际上，这是一个非常简单的方法。

659
00:35:03,735 --> 00:35:07,604
所以我只是要设置我的upperLeftCornerLabel.frame。

660
00:35:07,673 --> 00:35:11,240
请记住，在UIView中，frame是它的位置，

661
00:35:11,309 --> 00:35:14,343
bounds是我们绘制的地方，frame设置它。所以

662
00:35:14,412 --> 00:35:18,848
我要把它的起源基本上等于我的起源，

663
00:35:18,917 --> 00:35:24,821
但是offsetBy，所以我在CGPoint中添加了这个小偏移量。

664
00:35:24,889 --> 00:35:27,390
它只是移动了一些点，

665
00:35:27,459 --> 00:35:29,893
抵消它。所以我要用这个来抵消它

666
00:35:29,962 --> 00:35:33,396
我有的角落偏移。所以角落偏移，

667
00:35:33,465 --> 00:35:37,634
这是我在这里常常做的事情之一，

668
00:35:37,703 --> 00:35:40,570
那只是通过了小曲线。

669
00:35:40,639 --> 00:35:44,274
我不想在这里画曲线，所以

670
00:35:44,342 --> 00:35:47,977
我需要从roundedRect中稍微​​移动一下。

671
00:35:48,046 --> 00:35:50,846
好的？就是这样了。现在，我们不在那里。

672
00:35:50,915 --> 00:35:53,783
我们已经把它定位了，但是我们还没有真正设定

673
00:35:53,852 --> 00:35:57,988
这个字符串就可以了。所以我会再创造一点

674
00:35:58,056 --> 00:36:01,658
函数在这里我要调用configureCornerLabel，

675
00:36:01,727 --> 00:36:06,062
我会把这个UpperLeftCornerLabel传递给它。

676
00:36:06,130 --> 00:36:11,167
在这里面，这是一个小私人func。我们会通过

677
00:36:11,236 --> 00:36:15,538
这个标签。我们并不需要外部名称，因为

678
00:36:15,606 --> 00:36:18,708
函数的名字意味着外部名字，

679
00:36:18,777 --> 00:36:24,580
这是UILabel。所以在这里，我要配置它。

680
00:36:24,649 --> 00:36:26,415
而且我实际上并不需要做太多的配置。

681
00:36:26,484 --> 00:36:31,287
有一件事我肯定需要做这个标签设置它

682
00:36:31,356 --> 00:36:35,925
归档文字是我的cornerString。记得，

683
00:36:35,994 --> 00:36:38,261
cornerString是这个东西在这里。

684
00:36:38,330 --> 00:36:41,397
这个小家伙只是得到一个centeredAttributedString

685
00:36:41,466 --> 00:36:43,632
rankStrin \ n适当的大小，

686
00:36:43,701 --> 00:36:45,401
取决于我们的卡有多大。

687
00:36:45,470 --> 00:36:47,404
所以我们肯定需要这样做。

688
00:36:47,472 --> 00:36:50,506
当我这样做的时候，还有什么可能需要做我的标签？

689
00:36:50,575 --> 00:36:53,042
那么，有一点是我想要的标签是正确的大小。

690
00:36:53,111 --> 00:36:57,146
好的？我希望它是一个完美的尺寸来包装

691
00:36:57,215 --> 00:37:03,586
这东西。幸运的是，标签有一个叫做sizeToFit的方法

692
00:37:03,655 --> 00:37:08,791
它会调整标签的大小以适应其内容。唯一棘手的

693
00:37:08,860 --> 00:37:11,861
关于这个事情，但是，如果这个标签已经有一些

694
00:37:11,929 --> 00:37:15,164
宽度，你说sizeToFit，它会使它更高和

695
00:37:15,233 --> 00:37:17,634
保持宽度。那么，我们不想要那个。

696
00:37:17,702 --> 00:37:19,402
我们想要做所有事情，所以我会说，

697
00:37:19,471 --> 00:37:27,009
label.frame.size = CGsize.0。

698
00:37:27,078 --> 00:37:30,447
所以我要在sizeToFit之前清除它的大小。

699
00:37:30,515 --> 00:37:33,983
这样，它将在两个方向上扩展，跨越和

700
00:37:34,052 --> 00:37:36,752
下。对于sizeToFit你来说，这是一个古老的小技巧

701
00:37:36,821 --> 00:37:42,758
必须知道那里。而最后一件事，真是棘手的事情，

702
00:37:42,827 --> 00:37:46,496
如果我们没有面子，怎么办？

703
00:37:46,565 --> 00:37:49,899
我们没有正视这些角落吗？当然不是。

704
00:37:49,968 --> 00:37:52,702
我们不希望卡的背面有这个。那会

705
00:37:52,771 --> 00:37:55,171
如果回来的话，真的很容易玩很多游戏

706
00:37:55,240 --> 00:37:57,574
卡上有角落。我们不希望这样，

707
00:37:57,642 --> 00:38:01,577
所以我要配置标签隐藏，

708
00:38:01,646 --> 00:38:07,817
不突出显示。隐藏，如果我们没有面子。

709
00:38:07,886 --> 00:38:10,586
好的？所以如果我们面朝下，那么我会隐藏的。

710
00:38:10,655 --> 00:38:12,288
所以这里是使用Hidden的例子。

711
00:38:12,357 --> 00:38:14,791
它保存在子视图，列表，一切，

712
00:38:14,860 --> 00:38:17,760
保持在正确的位置，只是隐藏它。好的？

713
00:38:17,829 --> 00:38:19,595
相反，我们要画出我们的卡的背面，

714
00:38:19,664 --> 00:38:22,665
不管怎么样好的。这是一个很好的例子

715
00:38:22,733 --> 00:38:26,469
在那里使用isHidden。好的。它应该工作。

716
00:38:26,538 --> 00:38:28,204
我们来看看能不能拿到鞋面，

717
00:38:28,272 --> 00:38:34,243
至少这个左上角是绘制的。在那里。

718
00:38:34,312 --> 00:38:36,846
五颗心。看上去不错。我们来看看它是否有效

719
00:38:36,914 --> 00:38:40,049
去风景。哇！不仅是正确的位置，而且

720
00:38:40,117 --> 00:38:43,186
看，因为卡比较短，所以它更小

721
00:38:43,255 --> 00:38:47,490
我们不想用我们大字体的一半卡。

722
00:38:48,960 --> 00:38:51,694
所以这很好。那另一个角落呢？好的，

723
00:38:51,763 --> 00:38:54,430
另一个角落是有点难以定位

724
00:38:54,499 --> 00:38:57,433
因为我们的起源在左上角

725
00:38:57,502 --> 00:38:58,835
我们正试图放下右下方。

726
00:38:58,903 --> 00:39:00,670
但这并不坏，所以我们试试吧

727
00:39:00,739 --> 00:39:04,473
这样做。这是我们的lowerRightCornerLabel。它的

728
00:39:04,542 --> 00:39:08,578
frame.origin。那么，我会逐步建立这个。我

729
00:39:08,647 --> 00:39:13,249
要开始做一个点，这是我的界限.maxX，所以

730
00:39:13,318 --> 00:39:17,520
一直到右边，y是我的界限。最大，

731
00:39:17,589 --> 00:39:21,324
一直到底部。好的？但

732
00:39:21,393 --> 00:39:23,993
我不能把它放在那里。如果我试图把它放在那里，让我们来

733
00:39:24,062 --> 00:39:29,131
画出一张照片，以便看到。我在画下面

734
00:39:29,200 --> 00:39:32,902
边缘现在。好的，这是我的卡的下边缘

735
00:39:32,971 --> 00:39:36,639
我试图把这个东西放在这里所以我不能把它放在这里。

736
00:39:36,708 --> 00:39:39,142
如果我把它放在这里，这将是原点，

737
00:39:39,210 --> 00:39:42,245
它会在这里，甚至在卡上。所以我需要

738
00:39:42,314 --> 00:39:46,449
首先将这个点移到拐角处，然后，

739
00:39:46,517 --> 00:39:50,320
这个宽度和高度的整个距离

740
00:39:50,388 --> 00:39:53,555
小东西，所以我需要在这里做一个双跳

741
00:39:53,624 --> 00:39:56,726
在这里得到这个起源，所以这将在那里。可以，然后呢

742
00:39:56,795 --> 00:39:58,727
我只是要做double的offset。

743
00:39:58,796 --> 00:40:03,399
我要做的第一个抵消是-cornerOffset和

744
00:40:03,468 --> 00:40:08,438
-cornerOffset，让我通过roundedRect。

745
00:40:08,507 --> 00:40:12,141
然后我会再次offset

746
00:40:12,210 --> 00:40:16,980
-lowerRightCornerLabel.frame.- size.width，

747
00:40:17,048 --> 00:40:20,749
和-lowerRightCornerlabel.frame.-

748
00:40:20,818 --> 00:40:25,187
size.height。你看我是如何移动原点的

749
00:40:25,256 --> 00:40:27,723
回到那里，每个人都很酷。可以，然后呢

750
00:40:27,792 --> 00:40:31,561
那个位置呢，这是错误的，cornerOffset，对吗？

751
00:40:31,629 --> 00:40:35,498
所以那个位置就是它，当然我们必须配置它

752
00:40:35,566 --> 00:40:38,701
以及。所以让我们在这里做同样的事情

753
00:40:38,769 --> 00:40:42,037
我们要配置我们的右下角。因为它需要

754
00:40:42,106 --> 00:40:44,774
以完全相同的方式进行配置。并使用角落的字符串

755
00:40:44,842 --> 00:40:50,647
无论如何，让我们看看它是什么样子。右下，

756
00:40:50,715 --> 00:40:55,852
哎呀。我没有在那里完成lowerRightCornerLabel，

757
00:40:55,920 --> 00:41:05,295
好吧，有趣的。

758
00:41:05,363 --> 00:41:07,597
那么这不是很对吗？

759
00:41:07,665 --> 00:41:12,268
好吧，它是在正确的位置，但五颗心

760
00:41:12,337 --> 00:41:16,038
应该倒过来吧？如果你看一张卡，

761
00:41:16,107 --> 00:41:19,842
一张可以颠倒的扑克牌，好的。

762
00:41:19,910 --> 00:41:23,012
那么，我怎么把这个东西倒过来呢。

763
00:41:23,081 --> 00:41:25,514
那么，这是超级简单的

764
00:41:25,583 --> 00:41:30,019
在iOS中，因为每个视图都有一个var，

765
00:41:30,087 --> 00:41:35,591
lowerRightCornerLabel有一个var，它叫做transform。

766
00:41:35,660 --> 00:41:38,428
而变换就是所谓的仿射变换，

767
00:41:38,496 --> 00:41:41,864
有多少人知道仿射变换是什么？好的，

768
00:41:41,933 --> 00:41:43,199
没有人，基本上差不多。

769
00:41:43,268 --> 00:41:45,234
所以仿射变换非常简单，

770
00:41:45,302 --> 00:41:49,772
它只是一个blob，一个代表一个规模的东西，

771
00:41:49,841 --> 00:41:53,542
翻译和轮换。好的，就是这三件事。

772
00:41:53,611 --> 00:41:57,146
所以你可以看一个UI视图并旋转它，缩放它

773
00:41:57,215 --> 00:42:00,816
只需要这个小小的变体就可以翻译所有你想要的东西。现在

774
00:42:00,885 --> 00:42:02,885
当然我们正在用框架来定位事物

775
00:42:02,953 --> 00:42:05,721
这样的东西，但这是一个额外的方式来控制

776
00:42:05,790 --> 00:42:07,690
它的定位，缩放和旋转。

777
00:42:07,759 --> 00:42:11,627
现在这一切都将是明智的翻译。所以

778
00:42:11,695 --> 00:42:14,763
这将是翻译的位。所以，如果你做到了

779
00:42:14,832 --> 00:42:18,267
更大，它可能看起来像锯齿，边缘，像素化。

780
00:42:18,336 --> 00:42:21,037
但是我们不会把它做大。相反，我们只是想要

781
00:42:21,106 --> 00:42:25,574
旋转它。所以你可能会认为我们可以做到这一点。

782
00:42:25,643 --> 00:42:28,745
我们来看AffineTransform.identity

783
00:42:28,813 --> 00:42:31,881
转化，这样就意味着不旋转，不缩放，

784
00:42:31,949 --> 00:42:33,816
未翻译，只是一个身份。和

785
00:42:33,885 --> 00:42:35,785
你以为我可以说旋转它。

786
00:42:35,854 --> 00:42:37,953
顺便说一下，变换只有三种方法。

787
00:42:38,022 --> 00:42:40,890
旋转，转换和缩放，就是这些。所以，

788
00:42:40,959 --> 00:42:43,793
如果我创建了一个旋转的，我想要多少

789
00:42:43,862 --> 00:42:47,296
旋转这个，如果我想把它颠倒？好的，

790
00:42:47,365 --> 00:42:51,233
以弧度？丕，对吗？因为我想转身，

791
00:42:51,302 --> 00:42:54,770
转过来好一点，所以它倒过来。所以，我可以

792
00:42:54,839 --> 00:42:59,641
只要说CGFloat.pi，但这不会实际工作。

793
00:42:59,710 --> 00:43:02,311
这很接近，但不起作用，所以让我告诉你为什么这样

794
00:43:02,380 --> 00:43:05,681
不会相当工作。所以如果这篇文章在这里会做到这一点。

795
00:43:05,750 --> 00:43:09,952
好吧，这里是我的角落，在这里，这里是

796
00:43:10,020 --> 00:43:14,357
这五件事情是现在。这是正确的一面

797
00:43:14,425 --> 00:43:17,293
喜欢这个。其实这里我们会在一张纸上做。所以

798
00:43:17,362 --> 00:43:21,497
这是我的五颗心。我想要它

799
00:43:21,565 --> 00:43:25,601
像这样颠倒吧？好吧，那就是我想要的。

800
00:43:25,670 --> 00:43:29,939
但是，如果我旋转它，它围绕原点旋转。和

801
00:43:30,008 --> 00:43:33,909
我们的起源的左上角。所以，如果我旋转它，Pi，哇，

802
00:43:33,978 --> 00:43:38,014
它会在那里。你看到这个问题？所以

803
00:43:38,082 --> 00:43:40,249
这将是倒挂，但不是在正确的地方。

804
00:43:40,318 --> 00:43:43,052
所以我需要旋转它并翻译它。所以

805
00:43:43,120 --> 00:43:46,022
我要做的是我要先把它翻译成

806
00:43:46,090 --> 00:43:50,993
在这里到另一个角落，然后我要旋转它。 Woho，

807
00:43:51,061 --> 00:43:52,261
它会工作。

808
00:43:52,330 --> 00:43:56,932
好吧那就让我们来做吧。我们在哪里，我的肩膀在哪里？

809
00:43:57,001 --> 00:43:58,867
这是旋转器，所以我要保持旋转。

810
00:43:58,936 --> 00:44:05,274
我仍然想要做。旋转但我想要

811
00:44:05,342 --> 00:44:08,611
做一个翻译，所以我要留下。翻译

812
00:44:08,680 --> 00:44:11,413
通过和多少我想翻译？我要

813
00:44:11,482 --> 00:44:16,219
按照我右下角的整个宽度和高度来平移。

814
00:44:16,287 --> 00:44:23,226
lowerRightCornerLabel.frame.size.width和

815
00:44:23,294 --> 00:44:28,764
lowerRightCornerLabel.frame.s-

816
00:44:28,833 --> 00:44:32,935
ize.height。所以我正在考虑身份，我正在翻译它

817
00:44:33,004 --> 00:44:37,840
下到角落，然后我旋转它。我也可以

818
00:44:37,908 --> 00:44:40,843
有点翻译它到中心，并旋转它

819
00:44:40,912 --> 00:44:43,946
然后移回去。这是另一种常见的做法

820
00:44:44,014 --> 00:44:46,983
那个旋转。但是，我们走了，这是颠倒的

821
00:44:47,051 --> 00:44:51,854
它工作，即使在其他反弹的大小。好的，

822
00:44:51,923 --> 00:44:54,456
优秀，所以我们使用了子视图。我们已经使用布局

823
00:44:54,525 --> 00:44:56,992
子视图使其始终处于正确的位置，

824
00:44:57,061 --> 00:45:00,929
一切都很好看。我们去检查一下

825
00:45:00,998 --> 00:45:04,433
确保我们的滑块，

826
00:45:04,502 --> 00:45:08,004
记住这个滑块在这里设置。记住我们可以

827
00:45:08,072 --> 00:45:09,872
把它放大一点，让我们去确保这是工作。

828
00:45:09,941 --> 00:45:13,809
我打算把它设置成相当大的字体。和

829
00:45:13,877 --> 00:45:16,345
希望当我回到我的应用程序，

830
00:45:16,414 --> 00:45:21,049
它应该有一个大的字体，但它没有。

831
00:45:21,118 --> 00:45:24,187
为什么它没有大字体？这很奇怪。

832
00:45:24,255 --> 00:45:28,090
实际上，它确实，它只是从来没有重新。

833
00:45:28,159 --> 00:45:31,994
如果我改变了我的反弹，

834
00:45:32,062 --> 00:45:36,064
现在我看到了大字体。所以这是一个问题。

835
00:45:36,133 --> 00:45:40,903
当这个滑块移动，我们需要找出它移动。和

836
00:45:40,972 --> 00:45:43,672
你可以用一个叫做的函数来做到这一点

837
00:45:43,741 --> 00:45:48,143
TraitCollectionDidChange。所以

838
00:45:48,212 --> 00:45:51,146
性格，我们会在几个星期内谈论性状。

839
00:45:51,215 --> 00:45:55,284
性格有很多与你旋转，是你

840
00:45:55,352 --> 00:45:57,820
风景，你是肖像吗，像这样的东西是特质。

841
00:45:57,888 --> 00:46:01,557
而且，你的字体大小一般。所以

842
00:46:01,626 --> 00:46:04,526
当这些事情发生变化时，特征集合就被调用。

843
00:46:04,595 --> 00:46:09,565
在这里，我只是要setNeedsDisplay和

844
00:46:09,634 --> 00:46:13,368
setNeedsLayout，好吧。所以有了我的特质

845
00:46:13,437 --> 00:46:16,139
控制我们如何绘制变化的东西，

846
00:46:16,207 --> 00:46:20,709
那么我会重绘。所以现在如果我们回去，

847
00:46:20,778 --> 00:46:22,911
现在我们的字体很大，如果我们把它们设置的很大，

848
00:46:22,980 --> 00:46:25,514
所以他们会开始大。然后我回去了

849
00:46:25,583 --> 00:46:30,085
设置他们在这里在我的设置小，

850
00:46:30,154 --> 00:46:35,657
回到正常的尺寸，哎呀，对不起。我会去的，明白了，

851
00:46:35,726 --> 00:46:41,330
什么？我们走了，所以把它恢复正常。只要去这里，

852
00:46:41,398 --> 00:46:43,799
回到我们的扑克牌，它重新正常。

853
00:46:43,867 --> 00:46:47,636
好吧，因为它发现那个滑块已经移动了。所以

854
00:46:47,704 --> 00:46:49,972
小小的事情，你必须记住要做到这一点

855
00:46:50,041 --> 00:46:54,610
我们会在路上谈更多的特质。我们走吧

856
00:46:54,678 --> 00:46:58,414
回来，并做一些布局的东西，采取一点

857
00:46:58,482 --> 00:47:02,150
打破我们的卡，并做布局。所以现在，

858
00:47:02,219 --> 00:47:04,754
我们有这张卡占据了整个的东西

859
00:47:04,822 --> 00:47:07,556
空间，实际上，我会再次使卡宽，所以我们

860
00:47:07,625 --> 00:47:09,858
可以看到它好一点。所以我只是回到这里

861
00:47:09,927 --> 00:47:15,330
使它宽，所以这张卡不是真正的卡形。

862
00:47:15,399 --> 00:47:18,734
牌不像这样高又瘦，当然，

863
00:47:18,802 --> 00:47:23,105
卡在这里绝对不是这张卡，

864
00:47:23,174 --> 00:47:25,874
没有卡看起来像那样。这是荒谬的，

865
00:47:25,943 --> 00:47:29,545
我们不希望这样。我们希望它看起来更像一张卡片

866
00:47:29,614 --> 00:47:31,346
是什么让一张卡看起来像一张卡？好，

867
00:47:31,415 --> 00:47:35,450
这是它的长宽比。对，宽度，关系

868
00:47:35,519 --> 00:47:38,954
宽度的高度，所以我们想改变这一点。所以要做

869
00:47:39,022 --> 00:47:42,757
我们不能把边缘固定到边缘了。

870
00:47:42,826 --> 00:47:46,462
所以让我们把我们的约束钉到边缘

871
00:47:46,530 --> 00:47:49,631
而不是让他们钉住让我们让他们更大

872
00:47:49,700 --> 00:47:53,468
大于或等于我们，我们的卡不会离开边缘

873
00:47:53,537 --> 00:47:55,538
但它并不固定在边缘。所以

874
00:47:55,606 --> 00:47:58,974
我们如何轻松地做到这一点，或者你可以找出所有的问题

875
00:47:59,043 --> 00:48:02,344
通过选择它和在视图上的约束

876
00:48:02,412 --> 00:48:05,547
去你的另一边的这个其他检查员

877
00:48:05,616 --> 00:48:09,151
属性检查员，称为尺寸检查员。

878
00:48:09,219 --> 00:48:12,388
看到这里是我的约束，这是我的四个约束。

879
00:48:12,457 --> 00:48:15,658
所以即使我把鼠标放在他们身上，他们也会强调。

880
00:48:15,726 --> 00:48:18,160
所以，现在他们都是平等的，他们是固定的。

881
00:48:18,228 --> 00:48:21,430
好吧，等于十六，固定在边缘，等于十六。

882
00:48:21,498 --> 00:48:23,532
你可以通过编辑它们来改变这个等于

883
00:48:23,601 --> 00:48:24,800
把它改成大于。

884
00:48:24,869 --> 00:48:27,769
我们最后一次这样做，我们可以做到这一点

885
00:48:27,838 --> 00:48:30,973
我们所有的人。只是让他们都只是咨询。

886
00:48:31,041 --> 00:48:34,310
而且我们不要在底部做底部，

887
00:48:34,378 --> 00:48:37,513
让我们继续，只是做大于或等于。和

888
00:48:37,582 --> 00:48:40,248
同样的事情，大于或等于，我们会做16。

889
00:48:40,317 --> 00:48:43,219
所以至少在所有方面都是一样的。

890
00:48:43,287 --> 00:48:47,523
所以现在，这些边缘的限制只是建议。

891
00:48:47,592 --> 00:48:51,727
他们只是说要确保你没有超过16分

892
00:48:51,796 --> 00:48:54,329
从边缘。所以这很好。但现在，

893
00:48:54,398 --> 00:48:58,467
线条都是红色的，你看到一切都变红了？

894
00:48:58,536 --> 00:49:01,837
那是因为我们不再指定这张牌的位置

895
00:49:01,906 --> 00:49:04,840
应该是了。由于我们不是固定的

896
00:49:04,909 --> 00:49:08,144
边缘，它应该是。那么，我们先来修复

897
00:49:08,212 --> 00:49:11,780
这个长宽比问题。好的，我想要卡片

898
00:49:11,848 --> 00:49:15,751
有一个宽高比，你知道，有点像广告左右。

899
00:49:15,819 --> 00:49:19,988
基本上五到八下来似乎是典型的

900
00:49:20,057 --> 00:49:22,758
卡比例。事实证明，你可以

901
00:49:22,827 --> 00:49:26,295
通过控制拖动来修复视图的比例。

902
00:49:26,364 --> 00:49:28,830
但是你不能像我们这样做的时候把它拖到另一个视角

903
00:49:28,899 --> 00:49:33,101
我们正在抓住边缘。您可以控制拖动到自己。

904
00:49:33,170 --> 00:49:34,636
当你控制回自己时，

905
00:49:34,705 --> 00:49:37,506
你可以选择固定宽度，高度，

906
00:49:37,574 --> 00:49:40,175
或者这个视图的宽高比。所以我会修复

907
00:49:40,244 --> 00:49:43,779
纵横比。所以现在，我添加了一个约束，看

908
00:49:43,847 --> 00:49:46,415
在这里，它修复了长宽比。

909
00:49:46,484 --> 00:49:50,519
当然，我不希望长宽比为259到461。

910
00:49:50,588 --> 00:49:55,357
所以我要编辑五到八个。

911
00:49:55,426 --> 00:49:57,159
所以我在此之后解决这个问题。

912
00:49:57,228 --> 00:49:59,961
这还没有说什么东西

913
00:50:00,030 --> 00:50:02,565
应该是或应该是什么大小或

914
00:50:02,633 --> 00:50:05,267
这样的事情所以让我们来另一个约束

915
00:50:05,336 --> 00:50:07,002
说中间会是正确的。

916
00:50:07,071 --> 00:50:09,538
所以你看我是怎么用蓝色的短线去掉它的

917
00:50:09,606 --> 00:50:13,542
完美的中间？现在我要控制拖动

918
00:50:13,610 --> 00:50:17,679
卡在这里回到我的外部视图。而这一次，

919
00:50:17,748 --> 00:50:20,616
而不是在我已经拥有的那些顶端

920
00:50:20,685 --> 00:50:23,419
大于或等于一个，我会选择中心，

921
00:50:23,487 --> 00:50:26,756
水平和垂直。你注意到这个说，

922
00:50:26,824 --> 00:50:30,025
水平和垂直安全区域。所以

923
00:50:30,094 --> 00:50:32,394
每个视图都知道它是安全区域。

924
00:50:32,463 --> 00:50:36,632
这是安全的地方，它可以绘制的地方没有压倒一切或

925
00:50:36,700 --> 00:50:39,835
冲击其他观点空间。所以这个

926
00:50:39,903 --> 00:50:43,605
橙色的视图，它的安全区不包括这个地方

927
00:50:43,674 --> 00:50:46,942
在哪里面部识别和一天的时间。

928
00:50:47,011 --> 00:50:48,577
所有在这里，所以它不会在那里绘制。

929
00:50:48,645 --> 00:50:51,746
这里也不包括这个小酒吧。

930
00:50:51,815 --> 00:50:54,449
如果底部有条形按钮或标题

931
00:50:54,518 --> 00:50:57,286
在顶部，它不会包括那个和

932
00:50:57,355 --> 00:51:00,656
这一切都是自动的，不仅是自动的，而且随着它的变化。

933
00:51:00,725 --> 00:51:02,992
这个约束条件会自动调整。

934
00:51:03,060 --> 00:51:05,560
所以，如果你把标题放在这个视图的顶部，

935
00:51:05,629 --> 00:51:08,864
让我们说下降，然后我的卡将下降

936
00:51:08,933 --> 00:51:11,733
新安全区的中心。所以这是安全的

937
00:51:11,802 --> 00:51:15,871
所有的地方。我们总是在创造约束

938
00:51:15,939 --> 00:51:20,041
查看安全区域，好吗？好的，现在我已经说了

939
00:51:20,110 --> 00:51:23,579
但是事情还是红的。他们为什么还是红色？

940
00:51:23,647 --> 00:51:26,314
那么，因为我没有说这个观点有多大。

941
00:51:26,383 --> 00:51:28,784
我已经说过纵横比是多少以及它在哪里

942
00:51:28,853 --> 00:51:30,853
我说过，它不能通过边缘，但

943
00:51:30,921 --> 00:51:33,889
我没有说过它是多大。一个非常小的卡会

944
00:51:33,958 --> 00:51:37,359
在这里满足所有这些限制吧？

945
00:51:37,427 --> 00:51:39,961
非常小的卡会走出去的边缘。它可能是

946
00:51:40,030 --> 00:51:42,965
比例的正确方面，可能是中等或更大

947
00:51:43,033 --> 00:51:45,934
不会走到边缘的卡片可以完成所有的事情

948
00:51:46,003 --> 00:51:50,005
这些，好吗？那么，我如何告诉系统，我想要你

949
00:51:50,074 --> 00:51:53,775
尽可能大，仍然满足这个？好，

950
00:51:53,844 --> 00:51:57,979
我会通过固定来做到这一点。通过拖累自己，

951
00:51:58,048 --> 00:52:01,416
我的宽度。而我要设定我目前259的宽度，

952
00:52:01,485 --> 00:52:04,553
我要编辑它。顺便说一句，现在解决这个问题

953
00:52:04,621 --> 00:52:07,022
看起来不是红的，因为我已经设定了它的高度。

954
00:52:07,091 --> 00:52:11,726
但我希望它更大。我会说我想要它，

955
00:52:11,795 --> 00:52:16,465
比方说800宽。好，现在尽快尝试

956
00:52:16,534 --> 00:52:19,467
有一个约束说，这是800宽。

957
00:52:19,536 --> 00:52:23,672
哇，我们又红了。现在我们为什么是红色？我们是红色的

958
00:52:23,741 --> 00:52:27,075
现在因为这些限制不能得到满足。

959
00:52:27,144 --> 00:52:30,112
没有办法，你可以是800宽，也没有

960
00:52:30,180 --> 00:52:33,382
走下坡路。基本上，这就是问题所在。

961
00:52:33,451 --> 00:52:35,951
现在，我们该如何解决这个问题？那么所有这些

962
00:52:36,019 --> 00:52:39,488
其他的限制，除了我得到的那些宽度。

963
00:52:39,557 --> 00:52:41,123
如果我没有这些边缘限制，

964
00:52:41,191 --> 00:52:43,458
它可以走下坡路，得到它。长宽比，

965
00:52:43,527 --> 00:52:45,994
这就是我想要的卡看起来像，得到它。

966
00:52:46,062 --> 00:52:48,597
在中心，我一定要把卡放在中间。

967
00:52:48,666 --> 00:52:51,433
宽度，以及我想它是800但是

968
00:52:51,501 --> 00:52:53,835
真的，我只是希望它变得很大。

969
00:52:53,904 --> 00:52:57,239
所以，800宽度对我来说并不重要，

970
00:52:57,308 --> 00:53:00,909
换句话说，它是较低优先级的约束。

971
00:53:00,978 --> 00:53:03,478
所以，我可以告诉系统，通过在这里和

972
00:53:03,547 --> 00:53:06,415
编辑这个约束，并改变它的优先级。

973
00:53:06,483 --> 00:53:08,850
你在那里看到1000优先？

974
00:53:08,919 --> 00:53:12,621
这是最大的优先事项，这是必需的优先事项。

975
00:53:12,689 --> 00:53:16,058
所以，我们可以选择低于1000 cuz的任何优先级

976
00:53:16,127 --> 00:53:18,793
这是1000。而这将不那么重要。

977
00:53:18,862 --> 00:53:21,630
所以我们仍然尽可能地尽力满足它。

978
00:53:21,698 --> 00:53:24,466
但它不会覆盖任何其他的。

979
00:53:24,535 --> 00:53:26,100
我们通过点击优先级来做到这一点。

980
00:53:26,169 --> 00:53:27,636
我们可以输入一个数字，或者

981
00:53:27,705 --> 00:53:29,972
我们可以选择一些知名的，

982
00:53:30,040 --> 00:53:33,641
像高度重视。哇，看看发生了什么事。

983
00:53:33,710 --> 00:53:36,111
所有的红色都消失了，它使事情变得尽可能大。

984
00:53:36,180 --> 00:53:38,247
它仍然满足所有的限制。

985
00:53:38,316 --> 00:53:41,783
这是在这里和这里做的。

986
00:53:41,852 --> 00:53:44,753
看，它使它尽可能大，仍然有

987
00:53:44,821 --> 00:53:48,857
中间是五到八的宽高比。所以，

988
00:53:48,926 --> 00:53:52,894
这是约束优先的魔力，好吧。制造

989
00:53:52,963 --> 00:53:55,830
不重要的约束具有较低的优先级。

990
00:53:55,899 --> 00:53:59,168
所以我们会尽量给你尽可能多的，但是

991
00:53:59,236 --> 00:54:02,237
它会放弃那些较低优先级的。

992
00:54:02,305 --> 00:54:05,441
大家都很酷吗？好吧，现在我们得到了这个东西

993
00:54:05,509 --> 00:54:08,043
看起来更像一张卡片。它有一个卡长宽比。

994
00:54:08,112 --> 00:54:12,514
所以让我们回过头来看看这里。然后回去

995
00:54:12,583 --> 00:54:15,583
把它画出来，因为我们还只是做了角落而已

996
00:54:15,652 --> 00:54:18,887
我们需要休息。所以我们接下来做一下面子

997
00:54:18,956 --> 00:54:23,025
中间和一张脸牌，我们需要某种形象。

998
00:54:23,094 --> 00:54:25,727
我要通过画一幅图像来做到这一点，

999
00:54:25,796 --> 00:54:28,930
而我恰好碰巧在这里，某个地方，

1000
00:54:28,999 --> 00:54:30,965
不是这个。这个人在这里。

1001
00:54:31,034 --> 00:54:34,836
面对卡片，一堆面子卡片图象。喔，好的

1002
00:54:34,905 --> 00:54:38,640
而我只是将所有这些图像拖入我的项目。

1003
00:54:38,709 --> 00:54:41,142
那么，我把它们放在哪里？这就是这个

1004
00:54:41,211 --> 00:54:45,847
Assets.xeassets适用于图标所在的位置。

1005
00:54:45,916 --> 00:54:47,716
你可以在这里拖动你想要的任何图像。

1006
00:54:47,784 --> 00:54:51,052
所以，我可以抓住所有这些图像，全部拖入。

1007
00:54:51,121 --> 00:54:54,156
现在当我这样做的时候，看起来好像有些人没来

1008
00:54:54,225 --> 00:54:56,157
在，这些说@ 2x的。

1009
00:54:56,226 --> 00:55:00,362
你看，@ 2x？不，那些没有拖进去。是的，他们做到了。

1010
00:55:00,430 --> 00:55:04,266
那@ 2x意味着它和没有的一样

1011
00:55:04,334 --> 00:55:07,068
@ 2x，但分辨率是其两倍。

1012
00:55:07,137 --> 00:55:11,273
所以把它们作为一个2倍的版本，两倍的分辨率。

1013
00:55:11,342 --> 00:55:15,510
现在，一些设备有三个分辨率，像iPhone加

1014
00:55:15,579 --> 00:55:18,880
例如。那么这个决议我没有任何卡片

1015
00:55:18,949 --> 00:55:21,383
它会回落到使用2倍分辨率。

1016
00:55:21,451 --> 00:55:25,721
但我可能应该添加3倍的解决方案，我所有的卡。

1017
00:55:25,789 --> 00:55:28,022
现在，我拖入这些jpeg，

1018
00:55:28,091 --> 00:55:30,993
这是告诉我它的名字。它从中得到了

1019
00:55:31,061 --> 00:55:33,428
jpeg的文件名，但你可以重命名这些

1020
00:55:33,497 --> 00:55:34,329
任何你想要的。

1021
00:55:34,398 --> 00:55:38,533
我已经方便地命名他们的等级套装。好的？所以我可以

1022
00:55:38,602 --> 00:55:43,539
找到他们。把这些图像放在我的脸上就是了

1023
00:55:43,607 --> 00:55:47,376
在我的 draw(rect) 看这些的问题。所以

1024
00:55:47,444 --> 00:55:50,311
让我们去我们的扑克牌视图。回到我们的draw rect

1025
00:55:50,380 --> 00:55:56,184
我们在这里绘制我们的roundRect。现在我们要说。

1026
00:55:56,253 --> 00:56:01,089
我们可以让facecardimage =，更好

1027
00:56:01,157 --> 00:56:05,894
去这里，UIImage。所以UIImage是一件事情

1028
00:56:05,963 --> 00:56:09,331
代表一个图像，如果你看它的构造函数，

1029
00:56:09,399 --> 00:56:12,067
它有不少，但其中的一个是，

1030
00:56:12,135 --> 00:56:16,137
命名。而现在你只需指定名称和这个

1031
00:56:16,206 --> 00:56:20,441
名字必须匹配在这里的xcassets这个名字。

1032
00:56:20,510 --> 00:56:24,046
好吧，这是我们的等级字符串，

1033
00:56:26,050 --> 00:56:30,953
加上我们的西装。好的，这就是名字。所以，如果我们能够

1034
00:56:31,021 --> 00:56:33,555
发现那我们一定找到了一张面子牌。

1035
00:56:33,623 --> 00:56:35,857
所以现在我们要把这张脸卡片图像。

1036
00:56:35,926 --> 00:56:39,861
画出来，然后我们画出来

1037
00:56:39,930 --> 00:56:42,431
我要把它画在我的边界，但实际上我

1038
00:56:42,499 --> 00:56:45,300
真的不想在我的全部范围内画这张牌，

1039
00:56:45,369 --> 00:56:47,969
它可能会粉碎到角落里，对吧？

1040
00:56:48,038 --> 00:56:50,271
所以我会采取这个界限和

1041
00:56:50,340 --> 00:56:53,975
在这里把我的一个常量缩小一点，

1042
00:56:54,044 --> 00:56:55,877
这里不变，所以

1043
00:56:55,946 --> 00:56:58,580
这是SizeRatio.FaceCardImageSizeR-

1044
00:56:58,648 --> 00:57:02,517
我现在已经把它定为75％了。所以我会

1045
00:57:02,586 --> 00:57:06,655
有我的面子卡在那里是全尺寸的75％。

1046
00:57:06,723 --> 00:57:09,491
就是这样，这就是所有你需要做的绘制图像。

1047
00:57:09,559 --> 00:57:11,326
真的很容易得到他们的名字和

1048
00:57:11,395 --> 00:57:14,296
然后把它们画在一个矩形中。所以让我们去改变

1049
00:57:14,364 --> 00:57:18,633
我们的卡是面子卡，怎么样，让我们​​说一个杰克，

1050
00:57:18,702 --> 00:57:22,904
11是Jack。确保这绘制和

1051
00:57:22,973 --> 00:57:26,241
它应该是这里卡的大小的75％。

1052
00:57:26,310 --> 00:57:31,413
它是，它是，当我们旋转绘制它更小。

1053
00:57:31,481 --> 00:57:33,348
因为它是相比我们的bounds绘制它，

1054
00:57:33,417 --> 00:57:36,684
当我们旋转时，我们的bounds正在改变。所以

1055
00:57:36,753 --> 00:57:40,021
这是超级酷。什么点子？那么，如果我们头部

1056
00:57:40,090 --> 00:57:43,858
回到排名B5，然后在中间我们画

1057
00:57:43,927 --> 00:57:47,095
五颗心，五颗小心。那么，我不会

1058
00:57:47,163 --> 00:57:50,632
浪费我们的讲课时间去做那个代码，

1059
00:57:50,700 --> 00:57:52,100
因为它非常简单直接的代码和

1060
00:57:52,169 --> 00:57:53,234
你不会学到任何新东西。

1061
00:57:53,303 --> 00:57:54,502
你当然可以离线看看，

1062
00:57:54,571 --> 00:57:57,906
我将在网上发布这个代码。所以

1063
00:57:57,975 --> 00:58:01,543
我已经在这里，但它叫做drawPips。所以

1064
00:58:01,612 --> 00:58:03,244
有这个函数drawPips。

1065
00:58:03,313 --> 00:58:07,215
它的工作方式是数据驱动的，就像五个一样

1066
00:58:07,284 --> 00:58:10,385
行两个点，然后一个点在中间，和

1067
00:58:10,454 --> 00:58:12,921
然后在底部两个点，对不对？或八是两个

1068
00:58:12,989 --> 00:58:15,690
两两两等，所以只是数据驱动。和

1069
00:58:15,759 --> 00:58:18,193
它实际上只是做一个for循环，并通过for

1070
00:58:18,262 --> 00:58:21,563
循环和绘制一个点或两个点和

1071
00:58:21,632 --> 00:58:24,199
只是下来，然后绘制很多行。

1072
00:58:24,267 --> 00:58:26,801
它有一个很酷的小嵌入式功能，

1073
00:58:26,870 --> 00:58:30,238
你注意到函数可以在Swift的函数里面。

1074
00:58:30,306 --> 00:58:33,542
这个createPipString只是创建一个归因于中心

1075
00:58:33,610 --> 00:58:36,544
字符串，但它没有五个。我只是点子

1076
00:58:36,613 --> 00:58:38,313
其中的一部分，但我仍然居中这是很好的

1077
00:58:38,381 --> 00:58:41,115
它将它绘制在卡的中心。它有点挑选

1078
00:58:41,184 --> 00:58:43,885
通过猜测什么是正确的大小和大小

1079
00:58:43,954 --> 00:58:45,854
看看有多大，然后调整它

1080
00:58:45,923 --> 00:58:48,423
它选择完美的大小点来修复，

1081
00:58:48,492 --> 00:58:50,825
以适应可用的空间。所以你可以看和

1082
00:58:50,894 --> 00:58:54,496
看看我如何使用中心属性字符串在那里。好的，

1083
00:58:54,565 --> 00:58:58,366
这是非常多的。所以，如果不是面子卡，那么我们

1084
00:58:58,435 --> 00:59:03,138
想画点子，让我们看看这是否适合我们的五个。

1085
00:59:09,313 --> 00:59:12,347
看起来不错，让我们看看，我们将它旋转，更小，

1086
00:59:12,416 --> 00:59:16,518
这一切都变小了。很容易做到这一点，对不对？

1087
00:59:16,586 --> 00:59:20,955
现在我们对这个东西有点意见了，

1088
00:59:21,024 --> 00:59:21,890
还有另一件事，对不起，

1089
00:59:21,959 --> 00:59:24,926
我们必须画出我们卡的背面，好吧。

1090
00:59:24,994 --> 00:59:27,595
所以它真的应该只做这个东西，如果它面朝上，

1091
00:59:27,664 --> 00:59:31,332
好吧。如果是的话，只能用点子做面子卡

1092
00:59:31,401 --> 00:59:33,835
面对，我们已经做到这一点，如果没有面对，

1093
00:59:33,903 --> 00:59:37,139
它隐藏了我们的小标签，对吧？

1094
00:59:37,207 --> 00:59:40,441
这是隐藏的，隐藏我们的标签，这是很好的。但如果我们

1095
00:59:40,510 --> 00:59:44,312
卡面朝下，那么我们需要显示卡的背面。

1096
00:59:44,381 --> 00:59:46,114
所以我会用图像来做到这一点。

1097
00:59:46,182 --> 00:59:49,918
我要说如果让cardBackImage = UIImage

1098
00:59:54,224 --> 00:59:58,026
再次，命名，我会把它称为cardback。

1099
00:59:58,094 --> 00:59:59,327
所以我要去找

1100
00:59:59,396 --> 01:00:02,931
一个名为cardback的图像，如果我能找到它，那么我会去的

1101
01:00:03,000 --> 01:00:05,600
有吸引力。而这一次，我要把它画在我的整个

1102
01:00:05,669 --> 01:00:07,602
因为它不会碰到任何角落，

1103
01:00:07,670 --> 01:00:10,405
因为我面朝下，角落不在那里。所以

1104
01:00:10,473 --> 01:00:13,608
我需要一个名为cardback的图像。所以我要结束了

1105
01:00:13,677 --> 01:00:16,545
这里来资产，我必须把一个名为cardback的图像。

1106
01:00:16,614 --> 01:00:19,081
所以我要在这里抓住这个形象

1107
01:00:19,149 --> 01:00:21,950
这是我的斯坦福形象。而我只是要重新命名

1108
01:00:22,018 --> 01:00:25,186
就在这里cardback，所以这是我的cardback。

1109
01:00:25,255 --> 01:00:27,655
注意它只有那里较低的分辨率版本，

1110
01:00:27,724 --> 01:00:29,290
它没有添加时间2X，但是

1111
01:00:29,359 --> 01:00:33,261
我可以拖动更高的分辨率版本来提供更高的

1112
01:00:33,330 --> 01:00:35,630
像这样的决议。而这一个是如此

1113
01:00:35,699 --> 01:00:37,666
高分辨率，甚至还有一棵小树，

1114
01:00:37,734 --> 01:00:40,568
好的，那很好。没有法律说它有

1115
01:00:40,637 --> 01:00:43,104
只是一个放大版本的同样的事情。所以

1116
01:00:43,172 --> 01:00:45,974
现在我有了cardback，所以现在，让我们去做我们的

1117
01:00:46,043 --> 01:00:52,113
卡面朝下设置我们的isFaceUp在这里是错误的

1118
01:00:52,182 --> 01:00:55,216
好的，跑步，我们会看到我们卡的背面。

1119
01:00:55,285 --> 01:00:56,751
希望我们看不到任何角落，

1120
01:00:56,820 --> 01:00:59,287
我们没有看到任何脸，我们没有看到任何点子。我们不会

1121
01:00:59,356 --> 01:01:01,790
看到任何的东西，我们只会有我们的后面

1122
01:01:01,858 --> 01:01:04,092
卡。这是一个高分辨率的设备

1123
01:01:04,161 --> 01:01:06,895
我们得到了2X版本。而且你可以看到它实际上

1124
01:01:06,963 --> 01:01:09,464
有点棘手，我们真的可以在这里使用3X版本，

1125
01:01:09,533 --> 01:01:14,436
这将是很好的。好，现在下一步，如果我真的

1126
01:01:14,504 --> 01:01:17,905
发展这是我想要在这里上升到我的排名

1127
01:01:17,974 --> 01:01:21,142
并适合每个级别和每一个西装面对和尝试

1128
01:01:21,211 --> 01:01:22,911
面朝下，并确保这一切工作。

1129
01:01:22,980 --> 01:01:26,547
那么，你可以想象一下，如果我必须这样做。好吧，做一个六

1130
01:01:26,616 --> 01:01:30,117
然后一个俱乐部和运行。不，好吧，这是七，运行。

1131
01:01:30,186 --> 01:01:33,521
所有的事情都要回去了，这将是单调乏味的

1132
01:01:33,590 --> 01:01:36,024
四处奔跑。什么是真棒，所以我可以看到

1133
01:01:36,093 --> 01:01:39,226
在界面生成器中的这个纸牌视图。

1134
01:01:39,295 --> 01:01:42,063
当然，我可以这样做，我不会提到它。

1135
01:01:42,132 --> 01:01:44,432
那么我们去这里，你怎么做？

1136
01:01:44,501 --> 01:01:50,371
您只需将@IBdesignable放在您的视图之前。

1137
01:01:50,440 --> 01:01:51,572
如果你把它放在那里，

1138
01:01:51,641 --> 01:01:53,275
那么当你去接口建设者，

1139
01:01:53,343 --> 01:01:57,145
它会编译你的观点，把它放在环境中

1140
01:01:57,214 --> 01:02:01,015
放在这里。现在是空白，为什么是空白？好，

1141
01:02:01,084 --> 01:02:03,618
它实际上是空白的，因为它面朝下，而且

1142
01:02:03,686 --> 01:02:08,456
图像不适用于在界面构建器中命名的图像。

1143
01:02:08,525 --> 01:02:11,025
举个例子，如果我再把这张脸抬起来，

1144
01:02:11,094 --> 01:02:14,429
你会发现它可以和点子一起工作，因为他们没有

1145
01:02:14,498 --> 01:02:17,899
使用任何图像。好的，回到我的故事板。

1146
01:02:17,968 --> 01:02:21,870
看，我有点，我也有我的角落的东西。可以，然后呢

1147
01:02:21,938 --> 01:02:24,772
它甚至做子视图。那么这些图像呢？

1148
01:02:24,841 --> 01:02:25,807
我要怎么做图像

1149
01:02:25,875 --> 01:02:28,075
因为这不仅仅是卡回来的问题，而是

1150
01:02:28,144 --> 01:02:32,513
如果我把它做成一张脸牌，

1151
01:02:32,582 --> 01:02:34,649
面卡是由图像。所以

1152
01:02:34,718 --> 01:02:36,851
我正在找角落，但我没有得到我的形象。

1153
01:02:36,919 --> 01:02:40,722
那么，事实证明，有另一个版本的图像命名

1154
01:02:40,791 --> 01:02:44,625
你可以使用，这将与两个工作。所以

1155
01:02:44,694 --> 01:02:46,394
它会在您运行时命名的图像，

1156
01:02:46,463 --> 01:02:50,298
但它也将与你的图像命名，

1157
01:02:52,168 --> 01:02:55,269
当你在界面生成器环境中。

1158
01:02:55,338 --> 01:02:57,638
它看起来是一样的，我甚至无法记住它自己，

1159
01:02:57,707 --> 01:03:01,909
所以我不得不在这里写下来。 in: Bundle

1160
01:03:01,978 --> 01:03:07,348
(for: self.classForCoder),

1161
01:03:07,417 --> 01:03:13,287
compatibleWith：traitCollection，

1162
01:03:13,356 --> 01:03:17,691
好的。我想我输入的是正确的。所以这是额外的

1163
01:03:17,760 --> 01:03:20,995
你需要的几个参数，你把它放在你所有的图像名称

1164
01:03:21,064 --> 01:03:23,731
如果你想在界面生成器中使用这些东西。

1165
01:03:23,800 --> 01:03:25,867
所以现在如果我们去Interface Builder，没关系，

1166
01:03:25,935 --> 01:03:29,403
它显示的形象。但这只是战斗的一半

1167
01:03:29,472 --> 01:03:31,639
因为，如果我想查看所有的卡片和

1168
01:03:31,708 --> 01:03:35,810
确保他们正在工作，我仍然必须回到这里

1169
01:03:35,879 --> 01:03:39,113
改变这些行列和适合

1170
01:03:39,182 --> 01:03:41,782
然后回去再看一遍。那真的很酷

1171
01:03:41,851 --> 01:03:44,719
如果我可以提出检查员，点击我的卡，

1172
01:03:44,788 --> 01:03:47,321
而不是只看到视图的属性，如果我能

1173
01:03:47,390 --> 01:03:50,258
看到等级和西装，脸上，不会太棒了。

1174
01:03:50,327 --> 01:03:53,828
如果我可以延长这个检查员，那么，

1175
01:03:53,897 --> 01:03:57,198
当然我们也可以这样做。我们所要做的就是放

1176
01:03:57,266 --> 01:04:01,269
@IBInspectable在我们想要的任何变种前面

1177
01:04:01,337 --> 01:04:05,507
在Interface Builder中进行检查。所以我要把它

1178
01:04:05,575 --> 01:04:09,077
在我所有的变数上，我会让他们都受到检查。

1179
01:04:09,145 --> 01:04:13,681
这里唯一的窍门就是你必须明确输入

1180
01:04:13,750 --> 01:04:19,087
任何IBInspectable，你都不能让这个被Swift推断出来。

1181
01:04:19,156 --> 01:04:22,590
因为Swift擅长推理，

1182
01:04:22,659 --> 01:04:26,828
界面生成器不是那么多，不太好。

1183
01:04:26,897 --> 01:04:29,030
好，那我们走吧现在，如果我点击我的视图，

1184
01:04:29,098 --> 01:04:33,834
看看这个，排名，我可以试试5。

1185
01:04:33,903 --> 01:04:38,739
我可以试试12，好吗？我可以试试2，

1186
01:04:38,808 --> 01:04:43,912
我甚至可以通过我的卡片，就像这样。

1187
01:04:43,981 --> 01:04:48,583
而且因为我已经把我的西服当成了一个字符串，

1188
01:04:48,652 --> 01:04:53,221
我甚至可以把X当作我的西装。

1189
01:04:53,290 --> 01:04:59,493
这样可行？好吧，这就是所有绘画的东西。

1190
01:04:59,562 --> 01:05:02,630
现在我们回到学习一下多点触摸。

1191
01:05:02,699 --> 01:05:07,668
所以我要回到我们的幻灯片。我们正在运行

1192
01:05:07,737 --> 01:05:10,305
有点晚了，所以我要放大这些。好吧，

1193
01:05:10,373 --> 01:05:13,941
所以我们已经看到了如何绘制，现在我们如何获得多点触摸？

1194
01:05:14,010 --> 01:05:15,676
我们如何获得所有这些手势

1195
01:05:15,745 --> 01:05:18,980
人们可以用手指在屏幕上做什么？

1196
01:05:19,049 --> 01:05:21,916
你可以自己得到所有的触摸事件，

1197
01:05:21,985 --> 01:05:24,152
这是合法的。你可以，看着他们，

1198
01:05:24,220 --> 01:05:25,619
当它移动时看每个手指，

1199
01:05:25,688 --> 01:05:28,489
但那会非常乏味，所以我们不这样做。

1200
01:05:28,558 --> 01:05:31,492
相反，我们让iOS看看所有这些小动作

1201
01:05:31,561 --> 01:05:36,831
把它们变成手势，比如轻扫，捏，泛，

1202
01:05:36,899 --> 01:05:40,969
挖掘。所以这是我们编程这个东西的水平。

1203
01:05:41,038 --> 01:05:43,905
好的，现在手势都代表iOS

1204
01:05:43,974 --> 01:05:46,507
与这个类UIGestureRecognizer。

1205
01:05:46,576 --> 01:05:50,178
这是一个从所有这些手指识别手势的东西

1206
01:05:50,247 --> 01:05:53,281
动作。好吧，那个班是抽象的，好的，

1207
01:05:53,350 --> 01:05:56,250
它本身不知道如何识别任何手势。但

1208
01:05:56,319 --> 01:05:59,354
有很多它的子类知道如何识别

1209
01:05:59,422 --> 01:06:03,224
各种手势。所以当你识别一个手势时

1210
01:06:03,293 --> 01:06:06,394
实际上有两个部分。一个是，你必须告诉

1211
01:06:06,463 --> 01:06:09,364
一个看法，请开始认识捏，

1212
01:06:09,433 --> 01:06:13,334
请开始认识水龙头。那你必须

1213
01:06:13,403 --> 01:06:16,070
提供一个处理程序，以便当它识别它时，

1214
01:06:16,139 --> 01:06:18,973
它调用了一些函数，所以有两个部分。

1215
01:06:19,042 --> 01:06:22,476
首先，要求视图识别一个手势，

1216
01:06:22,545 --> 01:06:25,413
令人惊讶的是经常由控制器完成，或者

1217
01:06:25,481 --> 01:06:29,350
在你的故事板。通常这就是你添加手势的方式。

1218
01:06:29,419 --> 01:06:32,153
有时一个视图会为自己添加一个手势识别器，

1219
01:06:32,222 --> 01:06:34,389
如果它完全是固有的，

1220
01:06:34,458 --> 01:06:37,291
像滚动视图将添加捏和

1221
01:06:37,360 --> 01:06:38,626
平移手势本身，

1222
01:06:38,695 --> 01:06:41,496
因为没有这些手势，它甚至不是一个滚动视图。

1223
01:06:41,564 --> 01:06:43,598
但是很多时候，这是控制。

1224
01:06:43,667 --> 01:06:46,533
第二件事，手势的处理，

1225
01:06:46,602 --> 01:06:48,936
如果它影响模型的东西，

1226
01:06:49,005 --> 01:06:51,238
那么控制器将要处理它。

1227
01:06:51,307 --> 01:06:54,441
如果这只是影响事物的方式

1228
01:06:54,510 --> 01:06:58,546
查看，那么视图往往会直接处理它。所以

1229
01:06:58,615 --> 01:07:01,615
我们将在我们的小演示中看到这两个例子。

1230
01:07:01,684 --> 01:07:04,986
所以，第一部分，你如何给视图添加一个手势？

1231
01:07:05,054 --> 01:07:07,555
你如何看待这个视图，开始认识到这一点？

1232
01:07:07,623 --> 01:07:11,692
那么，通常我们在一个outlet的didSet设置

1233
01:07:11,761 --> 01:07:15,095
setter。所以在这里我有一个视图，我认为

1234
01:07:15,164 --> 01:07:18,933
想要认出锅。好吧，这是一些看法，我想要它

1235
01:07:19,002 --> 01:07:22,803
识别平移手势。所以在这个outlet的didSet，

1236
01:07:22,872 --> 01:07:27,041
记住这个didSet在iOS连接了这个插座的时候被调用

1237
01:07:27,110 --> 01:07:29,944
到你想要平移的视图。然后，我要去

1238
01:07:30,012 --> 01:07:33,481
创建一个名为UIGestureRecognizer的具体实例

1239
01:07:33,550 --> 01:07:37,117
一个UIPanGestureRecognizer。现在所有的识别器

1240
01:07:37,186 --> 01:07:40,354
有相同的初始化器。它有两个论点，即目标，

1241
01:07:40,423 --> 01:07:42,856
这是要处理这个问题的对象，

1242
01:07:42,925 --> 01:07:46,394
它通常是控制器或视图本身。

1243
01:07:46,462 --> 01:07:49,764
然后它有行动，这只是名字

1244
01:07:49,832 --> 01:07:52,667
用#selector围绕它的方法。你看到了

1245
01:07:52,736 --> 01:07:56,537
那里有黄色的选择器？这将被称为

1246
01:07:56,606 --> 01:08:00,341
当这个手势开始识别一个pan发生。

1247
01:08:03,313 --> 01:08:07,949
那么，一旦我们创建了一个UIPanGestureRecognizer，

1248
01:08:08,017 --> 01:08:09,417
我们问的视图，

1249
01:08:09,485 --> 01:08:12,420
请开始认识到这一点。我们通过调用来做到这一点

1250
01:08:12,489 --> 01:08:15,256
addGestureRecognizer。而一个视图可以有多少姿态

1251
01:08:15,325 --> 01:08:16,291
识别器，如你所愿。

1252
01:08:16,359 --> 01:08:18,826
它可以同时识别20种不同的手势

1253
01:08:18,895 --> 01:08:20,929
时间，这很好。

1254
01:08:20,997 --> 01:08:23,230
好的，现在让我们来谈谈处理程序。所以

1255
01:08:23,299 --> 01:08:26,567
当pan开始发生时，处理程序会被调用。

1256
01:08:26,636 --> 01:08:29,537
handler's会是我们看到的那种pan方法

1257
01:08:29,605 --> 01:08:33,541
在那边。而在这个方法里面，我们将会有

1258
01:08:33,609 --> 01:08:35,610
能够获得有关pan的信息。

1259
01:08:35,679 --> 01:08:38,812
那么，每种手势都有自己的信息。

1260
01:08:38,881 --> 01:08:41,982
就像捏你的手势有你正在捏的规模，

1261
01:08:42,051 --> 01:08:45,119
pan手势是pan发生的地方。所以，如果你

1262
01:08:45,188 --> 01:08:48,056
在码头查看UIPanGestureRecognizer，

1263
01:08:48,124 --> 01:08:50,859
你会看到它有像translationInView方法。

1264
01:08:50,927 --> 01:08:54,028
这告诉你在那个视图中pan的位置。

1265
01:08:54,097 --> 01:08:57,565
还是速度，现在平移有多快？

1266
01:08:57,634 --> 01:09:00,201
甚至setTranslation，让你重置

1267
01:09:00,269 --> 01:09:03,638
那翻译在视图中，所以你得到增量平移。

1268
01:09:03,706 --> 01:09:07,075
而不是连续的长度，你有多远

1269
01:09:07,143 --> 01:09:08,476
自从pan开始以来，

1270
01:09:08,545 --> 01:09:11,445
你知道自从上次pan移动以来你有多少了。

1271
01:09:11,514 --> 01:09:13,982
好的，有时可能有用。现在，

1272
01:09:14,050 --> 01:09:16,584
抽象超类UIGestureRecognizer，

1273
01:09:16,653 --> 01:09:20,120
它也有一个非常重要的变量称为状态。所以

1274
01:09:20,189 --> 01:09:23,257
这整个手势识别器的东西是一个状态机，并且

1275
01:09:23,326 --> 01:09:24,892
这个状态var代表那个。

1276
01:09:24,961 --> 01:09:28,696
所以只要一个手势成为可能，

1277
01:09:28,765 --> 01:09:31,032
像一个pan。大概一个手指倒下，

1278
01:09:31,101 --> 01:09:31,999
现在有可能。

1279
01:09:32,068 --> 01:09:35,669
然后一旦移动，就进入开始状态，

1280
01:09:35,738 --> 01:09:39,974
好的，所以这个锅已经开始了。然后随着手指的移动，

1281
01:09:40,042 --> 01:09:43,377
它保持在改变的状态。但它确实在不断移动

1282
01:09:43,446 --> 01:09:45,513
从改变的状态到改变的状态

1283
01:09:45,581 --> 01:09:49,217
过度。现在，每当这些状态变化发生时，

1284
01:09:49,285 --> 01:09:52,587
该处理程序被调用。谁处理这件事

1285
01:09:52,656 --> 01:09:54,755
有机会做到这一点。所以对于一个pan手势，

1286
01:09:54,824 --> 01:09:57,758
每当事情发生时你就会得到。

1287
01:09:57,827 --> 01:09:59,627
然后最终手指上升，

1288
01:09:59,695 --> 01:10:03,398
它结束了，你得到了。所以你的处理程序只是

1289
01:10:03,466 --> 01:10:05,533
每当状态机发生变化时调用。

1290
01:10:05,602 --> 01:10:09,103
现在，有些东西，如滑动，也是离散的

1291
01:10:09,172 --> 01:10:12,139
swipe滑动发生或没有。你不会得到

1292
01:10:12,208 --> 01:10:15,710
当你的手指飞过屏幕时，这是一个谨慎的

1293
01:10:15,779 --> 01:10:18,646
手势。你只是得到了，或者滑动，

1294
01:10:18,715 --> 01:10:23,384
.recognised得到发送到您的处理程序一次，就是这样。

1295
01:10:23,452 --> 01:10:26,254
但是对于持续的手势，你会得到.changed。

1296
01:10:26,322 --> 01:10:29,456
现在，还有两个有趣的状态，

1297
01:10:29,525 --> 01:10:33,127
和被取消。所以失败可能会发生，当你有多个

1298
01:10:33,196 --> 01:10:36,330
手势，其中一个胜利。

1299
01:10:36,398 --> 01:10:38,900
就像我们说的，我不知道，一个轻拍手势和

1300
01:10:38,968 --> 01:10:41,302
pan手势。那么，只要你放下鼠标，

1301
01:10:41,371 --> 01:10:42,536
它可能是其中之一。

1302
01:10:42,605 --> 01:10:45,172
但是一旦它不能马上回来

1303
01:10:45,241 --> 01:10:48,276
当你触及。不久，当你回来，就像，

1304
01:10:48,344 --> 01:10:51,078
它不能再成为一个pan了，

1305
01:10:51,147 --> 01:10:54,415
因为它基本上失败了。所以它可能会进入失败的状态，

1306
01:10:54,483 --> 01:10:57,952
但只有在实际启动的情况下不会的

1307
01:10:58,020 --> 01:11:00,922
如果没有那么远的话，首先会被认可。

1308
01:11:00,990 --> 01:11:03,758
然后这么取消是另一个

1309
01:11:03,826 --> 01:11:07,561
有趣。而这种情况发生了很多拖放。

1310
01:11:07,630 --> 01:11:10,664
哪一个，你开始了什么，它开始了，

1311
01:11:10,733 --> 01:11:14,635
而且进展顺利。但是，然后发生拖动，并且

1312
01:11:14,704 --> 01:11:18,305
现在它被取消了。无论你是什么手势，都认可。

1313
01:11:18,374 --> 01:11:20,041
所以你想找失败和取消，和

1314
01:11:20,109 --> 01:11:24,211
确保你清理或其他。拿走东西

1315
01:11:24,280 --> 01:11:28,215
关闭屏幕或其他，因为你的手势已经

1316
01:11:28,284 --> 01:11:32,286
失败了，或者被别的东西取消了。好吧，

1317
01:11:32,355 --> 01:11:35,356
所以给这个信息，我们的泛处理程序，

1318
01:11:35,424 --> 01:11:37,525
锅的处理程序是什么样的？

1319
01:11:37,594 --> 01:11:40,061
好的，所以这只是泛泛而谈

1320
01:11:40,129 --> 01:11:42,996
pan手势识别器本身就交给我们。和

1321
01:11:43,065 --> 01:11:46,533
我们打开状态，我们总是打开状态。

1322
01:11:46,602 --> 01:11:48,169
如果它改变或结束了，

1323
01:11:48,237 --> 01:11:50,671
注意我正在使用fallthrough，但我可以

1324
01:11:50,739 --> 01:11:54,475
在那里说。所以如果它改变或结束，

1325
01:11:54,543 --> 01:11:57,411
我的锅还在移动，或者我刚刚完成。

1326
01:11:57,480 --> 01:12:00,247
然后，我要通过调用找出pan的位置

1327
01:12:00,316 --> 01:12:02,683
translationin: view

1328
01:12:02,751 --> 01:12:07,154
然后，我会根据pan的位置做一些事情。

1329
01:12:07,223 --> 01:12:08,288
也许如果我在找

1330
01:12:08,357 --> 01:12:12,159
增量pan，我会重置为零。所以

1331
01:12:12,228 --> 01:12:16,797
下一个将从零开始并且是递增的。所以

1332
01:12:16,866 --> 01:12:19,733
就是这样，做这些处理程序很简单。现在有些什么

1333
01:12:19,802 --> 01:12:21,902
PanGesture以外的具体处理程序？

1334
01:12:21,971 --> 01:12:26,373
那么PinchGesture。它的信息是规模。所以

1335
01:12:26,442 --> 01:12:29,477
如果我从这里开始捏，我去两次宽，

1336
01:12:29,545 --> 01:12:31,979
这是2.0的规模。或者如果我从这里开始

1337
01:12:32,048 --> 01:12:35,782
去一半宽，这是0.5。而且还有速度

1338
01:12:35,851 --> 01:12:38,986
一。有RotationGesture，就像旋转一个旋钮。

1339
01:12:39,055 --> 01:12:41,122
两指手势转动旋钮。

1340
01:12:41,190 --> 01:12:44,124
而在弧度，它会告诉你多少旋钮已经

1341
01:12:44,193 --> 01:12:46,960
转成弧度。有一个SwipeGesture，你可以，

1342
01:12:47,029 --> 01:12:49,029
现在滑动是比这些其他有点不同

1343
01:12:49,098 --> 01:12:52,232
在你配置滑动。多少个手指？

1344
01:12:52,301 --> 01:12:54,235
什么方向，左，右，上，下？

1345
01:12:54,303 --> 01:12:57,772
然后通过添加它来打开滑动手势。和

1346
01:12:57,840 --> 01:13:01,075
那么当滑动发生时，你会得到，你的

1347
01:13:01,144 --> 01:13:04,512
处理程序将使用.ended调用。所以就是这样

1348
01:13:04,580 --> 01:13:06,747
不，它不同于你在前面配置

1349
01:13:06,816 --> 01:13:09,016
那么它只是告诉你它是否识别它。

1350
01:13:10,186 --> 01:13:11,052
有TapGesture，

1351
01:13:11,121 --> 01:13:12,887
这感觉就像滑动一样，

1352
01:13:12,955 --> 01:13:14,121
一个离散的手势，但实际上，

1353
01:13:14,189 --> 01:13:16,757
既然是双击和其他的东西，你总是

1354
01:13:16,826 --> 01:13:20,027
通常只能通过TapGesture找到。

1355
01:13:20,096 --> 01:13:23,130
但是你也可以像轻扫手势那样配置多少次轻敲，

1356
01:13:23,199 --> 01:13:27,801
多少个手指等，还有长时间的按压。长

1357
01:13:27,870 --> 01:13:30,804
按是你把手指放在屏幕上足够的

1358
01:13:30,873 --> 01:13:33,507
时间，并开始认识到它。这是令人惊讶的

1359
01:13:33,576 --> 01:13:36,209
一个连续的手势，因为当你把它压在你的

1360
01:13:36,278 --> 01:13:38,045
手指可能会移动一点点

1361
01:13:38,113 --> 01:13:39,946
没关系，这不是一个pan。好的，

1362
01:13:40,015 --> 01:13:41,882
因为它只能移动一点点。但

1363
01:13:41,951 --> 01:13:45,285
如果它移动一点，你会得到。

1364
01:13:45,354 --> 01:13:47,955
你可以配置你允许的移动量

1365
01:13:48,024 --> 01:13:50,992
在LongPress之前需要多长时间才能按下。

1366
01:13:51,060 --> 01:13:53,628
这一个被拖放很多中断。

1367
01:13:53,696 --> 01:13:57,031
因为拖放使用LongPress。这就是你如何选择

1368
01:13:57,099 --> 01:13:58,765
LongPress是拖放的东西。

1369
01:13:58,834 --> 01:14:00,734
所以如果你有长按，还有一些拖延和

1370
01:14:00,803 --> 01:14:03,270
放下去，你知道系统是非常聪明的

1371
01:14:03,339 --> 01:14:06,040
找出你真正想要的是哪一个。但

1372
01:14:06,109 --> 01:14:08,109
这可能会导致您的长时间按下被取消。

1373
01:14:09,545 --> 01:14:12,413
好吧，让我们来看看所有这些与演示，

1374
01:14:12,481 --> 01:14:15,015
我们只剩下五分钟了，但我想我们可以做到

1375
01:14:15,084 --> 01:14:18,186
在五或十分钟内。我们要添加三个手势

1376
01:14:18,254 --> 01:14:20,454
给我们的纸牌。要添加一个滑动，

1377
01:14:20,523 --> 01:14:23,457
这是要翻转，虽然我们的扑克牌。所以这是会的

1378
01:14:23,526 --> 01:14:25,459
影响我们的模型。所以我们的模型就是那副牌

1379
01:14:25,528 --> 01:14:27,394
这是我们的控制器将不得不

1380
01:14:27,463 --> 01:14:31,131
做。然后，我们将有水龙头将卡翻过来。我们

1381
01:14:31,200 --> 01:14:34,635
要在故事板上添加手势来点击，

1382
01:14:34,704 --> 01:14:38,338
即使在代码中。然后我们要捏哪个

1383
01:14:38,407 --> 01:14:41,976
我要用来调整脸牌的大小和

1384
01:14:42,045 --> 01:14:43,677
这是唯一的东西，所以处理程序

1385
01:14:43,746 --> 01:14:46,847
这将是在视图中。因为我不会回来

1386
01:14:46,916 --> 01:14:48,882
星期五的幻灯片，再没有一节，

1387
01:14:48,951 --> 01:14:51,652
Homecoming周。这次我们有冲突的时间表，所以

1388
01:14:51,720 --> 01:14:53,120
本周我们不能做结构化的部分，

1389
01:14:53,188 --> 01:14:56,357
不幸。下周我们将开始做多个MVC，

1390
01:14:56,425 --> 01:14:59,059
查看控制器生命周期，并希望我们会进入

1391
01:14:59,128 --> 01:15:03,564
动画以及下周。好吧，我们在这里，

1392
01:15:03,633 --> 01:15:05,666
让我们看起来更好一点。

1393
01:15:05,735 --> 01:15:10,404
让我们回去，得到一个更好，更好的东西，

1394
01:15:10,472 --> 01:15:12,406
也许这次俱乐部。

1395
01:15:12,475 --> 01:15:16,176
回到这里，让x会有我们的俱乐部。好的，

1396
01:15:16,245 --> 01:15:20,748
所以我们有很好看的卡。而且，让我们先刷一下。

1397
01:15:20,816 --> 01:15:25,319
所以，刷卡，做刷卡让我们得到两个我们的

1398
01:15:27,857 --> 01:15:30,924
控制器和我们同时在屏幕上查看。

1399
01:15:30,993 --> 01:15:33,026
所以这里是我们的控制器。它只有一副牌，

1400
01:15:33,095 --> 01:15:37,198
它并没有真正做任何事情。想为此添加一个手势

1401
01:15:37,266 --> 01:15:41,134
玩扑克牌的视图。我需要一个出口。

1402
01:15:41,203 --> 01:15:43,103
我的控制器不能用插座与那个东西交谈。

1403
01:15:43,172 --> 01:15:46,173
所以我只是要控制拖动像我会拖动任何东西

1404
01:15:46,242 --> 01:15:48,442
做一个出口。点击这里，这将是一个出路。

1405
01:15:48,511 --> 01:15:52,446
这将是我的playCardView是出路。

1406
01:15:52,515 --> 01:15:54,881
这里是。当这个连接起来，

1407
01:15:54,950 --> 01:15:57,318
我要立即添加调节器识别器。

1408
01:15:57,386 --> 01:16:01,522
所以我会在这个时候做这个，所以那个时候

1409
01:16:01,591 --> 01:16:05,559
iOS设置它来执行我的代码。我会去刷一下。

1410
01:16:05,628 --> 01:16:09,429
所以，我要创建一个滑动手势，

1411
01:16:09,498 --> 01:16:12,599
UISwipeGestureRecognizer。

1412
01:16:12,668 --> 01:16:16,670
而构造函数是这个目标动作的东西。

1413
01:16:16,739 --> 01:16:19,473
由于刷卡即将翻转卡片，就这样了

1414
01:16:19,541 --> 01:16:23,243
影响模型。所以它必须由我来处理，

1415
01:16:23,312 --> 01:16:27,848
控制器。好吧，自我是目标。视图不能

1416
01:16:27,917 --> 01:16:30,851
触摸模型，所以它不可能做滑动。和

1417
01:16:30,920 --> 01:16:32,786
那么选择器可以是任何功能。所以，

1418
01:16:32,855 --> 01:16:35,856
我将会有一个名为nextCard的函数

1419
01:16:35,925 --> 01:16:38,292
下一张牌。这甚至不会有任何参数。

1420
01:16:38,361 --> 01:16:41,195
这将是我想要在滑动时被调用的动作

1421
01:16:41,264 --> 01:16:45,132
发生。所以，我只是说#selecto和

1422
01:16:45,201 --> 01:16:46,600
然后我给了它的名字。

1423
01:16:46,669 --> 01:16:50,171
下一张牌，它没有任何参数，但如果它，我只是把

1424
01:16:50,239 --> 01:16:52,606
在那里的args。但是它没有任何参数

1425
01:16:52,675 --> 01:16:55,542
我们不需要那个。Selector(nextCard) 所以

1426
01:16:55,611 --> 01:16:58,245
这是我的轻扫手势。现在我们需要配置滑动

1427
01:16:58,314 --> 01:17:00,714
手势。例如，我可以设定方向。

1428
01:17:00,782 --> 01:17:04,451
例如，我可以说它向左滑动。轻扫到

1429
01:17:04,520 --> 01:17:08,656
你甚至可以说右边向右或向右滑动。

1430
01:17:08,724 --> 01:17:11,725
可以在那里放一些数组符号

1431
01:17:11,794 --> 01:17:14,828
左和右。所以现在我已经有了我的滑动

1432
01:17:14,897 --> 01:17:18,765
这将是一个单一的，我们有什么？

1433
01:17:18,834 --> 01:17:22,069
是的，所以这是一个错误。我要点击

1434
01:17:22,138 --> 01:17:25,005
在上面。这将导致我们的屏幕在这里得到所有的诡计，

1435
01:17:25,074 --> 01:17:27,608
所以让我们移动它。让我们来看看这个错误。

1436
01:17:27,677 --> 01:17:30,243
它说#selector的参数指的是

1437
01:17:30,312 --> 01:17:33,848
到一个实例方法nextCard(),，它的作用。

1438
01:17:33,916 --> 01:17:37,384
这不会暴露给Objective-C。我的天哪，

1439
01:17:37,453 --> 01:17:41,688
这整个机制是建立在Objective-C的机制之上的

1440
01:17:41,757 --> 01:17:45,759
目标行动。所以任何方法将是行动

1441
01:17:45,828 --> 01:17:49,963
手势识别器必须标记@objc。那出口

1442
01:17:50,032 --> 01:17:53,133
这个方法脱离了Swift到Objective C的运行时间

1443
01:17:53,202 --> 01:17:57,037
这是iOS运行的基础。即使使用Swift代码，

1444
01:17:57,105 --> 01:18:00,273
仍然得到了Objective-C的运行时间。好吧，那就是这个样子

1445
01:18:00,342 --> 01:18:03,043
就是这样。这总是必须的，只是标记它objc，

1446
01:18:03,111 --> 01:18:06,446
这不是什么大不了的事情，只要把它标上就可以了。好吧，

1447
01:18:06,515 --> 01:18:11,151
让我们回到我们的分屏。这和这个，

1448
01:18:11,220 --> 01:18:15,355
重新排列一切。回到自动。

1449
01:18:15,424 --> 01:18:18,759
好，现在我们有了这个SwipeGestureRecognizer，

1450
01:18:18,828 --> 01:18:20,827
我们需要问这个问题，

1451
01:18:20,896 --> 01:18:24,131
请开始认识它。所以我们说玩CardView，

1452
01:18:24,199 --> 01:18:28,134
添加这个GestureRecognizer(swipe)

1453
01:18:28,203 --> 01:18:30,637
现在它将开始认识到它。

1454
01:18:30,706 --> 01:18:33,440
这就是我们需要做的。现在这下一张卡

1455
01:18:33,509 --> 01:18:35,742
是要通过我们的卡片翻转的东西。所以

1456
01:18:35,811 --> 01:18:38,278
我们如何实现呢？我只是想说如果我能得到

1457
01:18:38,347 --> 01:18:42,349
我的套牌中有一张卡。因为我的套牌可能是空的。

1458
01:18:42,418 --> 01:18:43,917
这就是为什么如果放在那里我必须要做的。

1459
01:18:43,986 --> 01:18:46,519
然后我需要设置扑克牌视图的等级

1460
01:18:46,588 --> 01:18:49,156
等于某事。我需要设置扑克牌视图

1461
01:18:49,225 --> 01:18:52,559
适合等于某事。现在这里是控制器的地方

1462
01:18:52,628 --> 01:18:57,198
从事两者之间的转换工作。所以

1463
01:18:57,266 --> 01:18:59,966
我们要通过说'card's.rank来转换，

1464
01:19:00,035 --> 01:19:03,170
幸运的是，我们有订购卡的订单，而且

1465
01:19:03,238 --> 01:19:07,941
card.suit有它的原始价值。好的，

1466
01:19:08,010 --> 01:19:11,277
所以这只是模型之间的转换

1467
01:19:11,346 --> 01:19:13,747
那里的景色。大家都知道了？所以

1468
01:19:13,816 --> 01:19:15,482
让我们试试看，如果这个工作。

1469
01:19:15,551 --> 01:19:18,952
所以这应该刷卡通过滑动随机卡。

1470
01:19:19,021 --> 01:19:23,156
所以，我们走吧，轻扫，果然，看看。

1471
01:19:23,225 --> 01:19:26,960
通过滑动。所以这很简单，对吧？只要有

1472
01:19:27,029 --> 01:19:29,696
该甲板。我们所要做的只是设置纸牌视图

1473
01:19:29,765 --> 01:19:31,965
每次显示不同的卡片。好吧，

1474
01:19:32,034 --> 01:19:35,369
接下来我们要做的就是点击翻牌。

1475
01:19:35,437 --> 01:19:39,406
所以点击，我甚至不会在这里做这个代码。

1476
01:19:39,475 --> 01:19:42,543
相反，我要过去这里了

1477
01:19:42,611 --> 01:19:46,980
从这个角度来看，从这里抓一个水龙头的手势。

1478
01:19:47,049 --> 01:19:49,250
这是倒底的。看看所有这些手势，

1479
01:19:49,318 --> 01:19:51,885
捏，旋转，滑动。这里是水龙头，和

1480
01:19:51,953 --> 01:19:55,055
我要把它拖到我想识别水龙头的视图。

1481
01:19:55,124 --> 01:19:57,891
这是我的扑克牌视图。我把它放下，然后显示出来，

1482
01:19:57,960 --> 01:20:01,362
如果我们放大你可以看到它，在这个标题栏上起来

1483
01:20:01,430 --> 01:20:03,864
这里。你看到那里，点击手势？

1484
01:20:03,933 --> 01:20:05,699
你可以点击它并检查它。

1485
01:20:05,768 --> 01:20:07,968
对，多少水龙头？有多少触摸？

1486
01:20:08,037 --> 01:20:12,239
您也可以通过拖动来设置一个Action。所以

1487
01:20:12,308 --> 01:20:15,209
我要在这里设置一个行动。我会把它叫做flipCard，

1488
01:20:15,278 --> 01:20:17,278
因为这是我想要它做的，翻转卡。

1489
01:20:17,346 --> 01:20:19,879
我想解决这个问题。就像任何行动一样，

1490
01:20:19,948 --> 01:20:23,050
我想要它来解决这个问题。所以这里是我的翻转卡。

1491
01:20:23,118 --> 01:20:26,587
在这里翻转卡，我只是想说

1492
01:20:26,655 --> 01:20:31,792
playingCardView.isFaceUp =不能玩CardView.isFaceUp。

1493
01:20:31,860 --> 01:20:34,094
好吧，我只是要把卡翻过来，就是这样。

1494
01:20:34,162 --> 01:20:37,998
所以有些手势很容易写。实际上，

1495
01:20:38,066 --> 01:20:41,267
我稍微缩略了一下。现在，如果我点击，你

1496
01:20:41,336 --> 01:20:45,873
看看它是如何翻转它。好吧，现在我知道我们正在赶，

1497
01:20:45,941 --> 01:20:47,441
但实际上我要在这里做正确的事情。

1498
01:20:47,509 --> 01:20:50,277
这真的不应该是这样的。我应该切换

1499
01:20:50,346 --> 01:20:55,115
发送者，这是识别器的状态，和

1500
01:20:55,183 --> 01:21:00,053
确保我们在结束的情况下做到这一点。

1501
01:21:00,122 --> 01:21:02,556
现在通常不会那么做，

1502
01:21:02,625 --> 01:21:05,225
但我不想告诉你这是什么

1503
01:21:05,294 --> 01:21:09,062
真的有点不正确。好的，然后是最后一个

1504
01:21:09,131 --> 01:21:13,033
我们要做的就是捏住面部的大小

1505
01:21:13,102 --> 01:21:18,071
卡。那么，要做到这一点，我需要回到我的视图，

1506
01:21:18,140 --> 01:21:21,075
我的视图，我的自定义视图在这里。和

1507
01:21:21,143 --> 01:21:23,910
我需要改变这一点，所以现在，

1508
01:21:23,979 --> 01:21:28,181
其实，我们到这里吧。好的，视图。

1509
01:21:28,250 --> 01:21:32,252
好吧，现在我的脸牌大小，请记住这一点

1510
01:21:32,321 --> 01:21:35,355
一个常数。这SizeRatio.faceCardImageSizeTo-

1511
01:21:35,424 --> 01:21:38,124
BoundsSize，所以我会改变这是一个变种。

1512
01:21:38,193 --> 01:21:41,761
我会把它叫做faceCardScale。好的，

1513
01:21:41,830 --> 01:21:43,797
所以我需要创建一个新的变种来做到这一点。所以我们走吧，

1514
01:21:43,866 --> 01:21:47,167
在顶部做所有的事情。所以我们可以在这里很容易地看到，

1515
01:21:47,236 --> 01:21:51,037
var faceCardScale。这将是一个CGFloat。

1516
01:21:51,106 --> 01:21:56,610
我会把它设置成等于那个常量。不要忘记做

1517
01:21:56,679 --> 01:22:01,114
这个。好的，虽然我们并不需要

1518
01:22:01,183 --> 01:22:03,917
setNeedsLayout因为改变卡的大小，

1519
01:22:03,985 --> 01:22:06,887
faceCard不会影响角落，好吧。所以

1520
01:22:06,955 --> 01:22:11,057
我不需要重新布局。所以我有了faceCardScale，

1521
01:22:11,126 --> 01:22:14,160
所以现在我要创建一个小功能

1522
01:22:14,229 --> 01:22:16,162
成为捏手势的处理程序。

1523
01:22:16,231 --> 01:22:19,366
好吧，我会调用给它，调整，我有一个很好的名字

1524
01:22:19,435 --> 01:22:21,902
这里很容易理解它是什么。

1525
01:22:21,971 --> 01:22:28,108
我叫什么东西？ adjustFaceCardScale（byHandlin-

1526
01:22:28,177 --> 01:22:33,647
gGestureRecodnizedBy recognizer: UIPinch)

1527
01:22:33,716 --> 01:22:38,852
现在，这是一个故意长的名字。

1528
01:22:38,921 --> 01:22:41,254
所以你会明白，这是处理程序

1529
01:22:41,323 --> 01:22:44,858
手势。由于它是一个处理程序，它需要是@objc，

1530
01:22:44,927 --> 01:22:48,161
当然。而在这里面，我只是要开机

1531
01:22:48,230 --> 01:22:50,630
识别者的状态，就像我一直所做的那样。

1532
01:22:50,699 --> 01:22:54,168
这就是我们在这些处理程序中的标准做法。和

1533
01:22:54,236 --> 01:22:57,604
如果它改变了，那么捏就改变了

1534
01:22:57,673 --> 01:23:01,575
如果结束了，那么我要设置我的faceCardScale，

1535
01:23:01,644 --> 01:23:04,645
这件事我刚刚在这里创建好了，

1536
01:23:04,714 --> 01:23:09,349
是* = recognitionizer.scale。

1537
01:23:09,417 --> 01:23:12,319
现在，我只想要增量更改，因为我正在改变

1538
01:23:12,387 --> 01:23:14,988
每一次的规模。所以，否则，它会的

1539
01:23:15,057 --> 01:23:17,958
刚开始是指数级的。所以我要重设

1540
01:23:18,027 --> 01:23:21,928
每当发生这种情况时，识别器的比例就会变成1.0。

1541
01:23:21,997 --> 01:23:25,198
然后我们会忽略国家的其他所有州

1542
01:23:25,267 --> 01:23:30,304
机。我们不在乎什么时候开始，所有的东西。所以

1543
01:23:30,372 --> 01:23:33,307
现在我们会有这个adjustFaceCardScale（byHandlin-

1544
01:23:33,375 --> 01:23:38,011
gGesture recognizer)被添加回我们的控制器中

1545
01:23:38,080 --> 01:23:40,747
一个捏手势。所以在这里我要创造一个捏手势。

1546
01:23:40,816 --> 01:23:43,950
让pinch = UIPinchGestureRecognizer，

1547
01:23:44,019 --> 01:23:47,554
相同的目标无为而为，但是

1548
01:23:47,622 --> 01:23:51,825
这一次的目标是要成为的PlayCardView。

1549
01:23:51,894 --> 01:23:53,260
它会直接处理这个。

1550
01:23:53,329 --> 01:23:55,062
这不会去控制器，和

1551
01:23:55,131 --> 01:24:02,469
选择器就是我们那边的那个方法。

1552
01:24:02,538 --> 01:24:07,040
好吧，在我们看来，我会称之为捏。好的，

1553
01:24:07,109 --> 01:24:10,243
现在我只需要告诉playCardView添加

1554
01:24:10,312 --> 01:24:14,247
这个手势识别器捏，它会开始识别。

1555
01:24:14,316 --> 01:24:18,886
好的，让我们来看看。哎呀，

1556
01:24:18,954 --> 01:24:23,357
我在这里做错了什么？它说什么？

1557
01:24:25,260 --> 01:24:29,830
没有解决，好吧，让我们在这里使用scape完成，调整，

1558
01:24:29,898 --> 01:24:32,866
对不起，PlayCardView。我需要说的是，

1559
01:24:32,935 --> 01:24:36,937
PlayingCardView。这是那里的问题，处理程序。

1560
01:24:37,005 --> 01:24:45,412
对于那个很抱歉。好的，让我们找一张面子牌。

1561
01:24:45,481 --> 01:24:47,948
这里是。你怎么捏在模拟器？

1562
01:24:48,017 --> 01:24:50,484
你按住选项，你会得到这些灰色的东西，和

1563
01:24:50,553 --> 01:24:55,555
当你下降，你会捏。所以

1564
01:24:55,624 --> 01:24:57,357
看看这只是如何影响这个视图？

1565
01:24:57,425 --> 01:25:00,627
这不会影响其他任何东西，影响所有的牌

1566
01:25:03,399 --> 01:25:06,967
就是这样。好的，最后很抱歉。你会

1567
01:25:07,035 --> 01:25:08,802
在你的任务三中做所有这些事情，

1568
01:25:08,871 --> 01:25:10,470
刚刚出去了这是在一个星期内，

1569
01:25:10,538 --> 01:25:13,139
换句话说在下周三的演讲之前。和

1570
01:25:13,208 --> 01:25:14,374
那我一定会见到你

1571
01:25:14,443 --> 01:25:15,508
其实我星期一见。

1572
01:25:15,577 --> 01:25:16,543
如果你有问题，

1573
01:25:16,612 --> 01:25:19,012
我一如既往在这里。 >>对于

1574
01:25:19,081 --> 01:25:22,916
更多，请访问我们的stanford.edu。

