1
00:00:00,401 --> 00:00:04,536
[音乐]

2
00:00:04,605 --> 00:00:09,208
斯坦福大学。 >>好的，好吧，

3
00:00:09,276 --> 00:00:14,846
欢迎来到8号讲座，CS193P，2017年秋季。今天

4
00:00:14,915 --> 00:00:18,183
这完全是关于动画，只是要继续一点

5
00:00:18,251 --> 00:00:20,819
我们上次谈到的情况。有三种

6
00:00:20,888 --> 00:00:22,087
我今天要谈的信息。

7
00:00:22,156 --> 00:00:25,924
第一个是UIView属性动画。和

8
00:00:25,992 --> 00:00:27,492
这正是它听起来像。

9
00:00:27,561 --> 00:00:31,462
您可以在视图上为这些黄色属性制作动画。

10
00:00:31,531 --> 00:00:34,066
这真的是你可以用这个动画的唯一东西

11
00:00:34,135 --> 00:00:37,569
UIView属性动画机制。但

12
00:00:37,637 --> 00:00:39,370
它非常强大。你有框架和

13
00:00:39,439 --> 00:00:42,441
中心，动画的观点的立场。你已经

14
00:00:42,509 --> 00:00:45,343
获得了动画视图大小的边界，

15
00:00:45,412 --> 00:00:48,112
尽管只是暂时的，因为它是框架

16
00:00:48,181 --> 00:00:50,816
这决定你在哪里。如果你打算制作

17
00:00:50,884 --> 00:00:53,285
它更大，占据更多空间。

18
00:00:53,353 --> 00:00:56,321
在超级视图中，你必须设置框架。转型，

19
00:00:56,389 --> 00:00:58,490
这是超级强大的，我们看到用卡，

20
00:00:58,558 --> 00:01:00,659
我们在那里颠倒了角落。所以

21
00:01:00,727 --> 00:01:03,428
你可以做旋转，你也可以做比例缩放，

22
00:01:03,496 --> 00:01:06,831
实际上，这可能是一种更好的缩放比例

23
00:01:06,900 --> 00:01:09,901
试图嘲笑你的界限。然后一个不透明的，

24
00:01:09,969 --> 00:01:12,837
另一个好的，出入意见淡出，出现和

25
00:01:12,906 --> 00:01:15,573
消失，和背景颜色。我们几乎从不做

26
00:01:15,642 --> 00:01:18,476
那，但你可以这样做。所以这个工作的方式是

27
00:01:18,545 --> 00:01:22,013
一个名为UIView Property Animator的类，并不奇怪。

28
00:01:22,082 --> 00:01:26,217
它适用于闭包。基本上它的工作方式

29
00:01:26,286 --> 00:01:29,821
你是否在你的属性动画师身上设置了一堆东西，

30
00:01:29,890 --> 00:01:32,791
UIView属性动画师，来说一下你是什么样的动画

31
00:01:32,860 --> 00:01:36,227
想。需要多长时间，曲线走向何方

32
00:01:36,296 --> 00:01:39,531
通过这个过程快速或慢慢它会这样做。如果你

33
00:01:39,599 --> 00:01:42,667
在你开始之前想延迟。所有这些东西。

34
00:01:42,736 --> 00:01:45,269
你设置好了，然后你给它一个闭包。在里面

35
00:01:45,338 --> 00:01:50,041
闭包只是修改这些属性的代码。所以

36
00:01:50,110 --> 00:01:52,744
就是这样，那么它会动画这些变化

37
00:01:52,813 --> 00:01:56,214
你以你描述的方式要求。

38
00:01:56,283 --> 00:01:59,651
好的，这是一个超级简单的动画方式

39
00:01:59,720 --> 00:02:02,754
视图中的属性。所以让我们来看看它的外观

40
00:02:02,823 --> 00:02:06,124
现在就调用它。我甚至不会去表面

41
00:02:06,192 --> 00:02:09,794
UIViewPropertyAnimator的力量，它是惊人的。您可以

42
00:02:09,863 --> 00:02:12,197
创建动画。你可以向后擦洗它们

43
00:02:12,266 --> 00:02:14,833
前锋。你可以让他们自动重复和

44
00:02:14,902 --> 00:02:16,034
相反，做所有这些事情。

45
00:02:16,103 --> 00:02:19,004
我只会谈谈使用它的最简单方法

46
00:02:19,073 --> 00:02:22,573
这是运行属性动画器的这个类方法。

47
00:02:22,642 --> 00:02:25,844
好的，这个东西会创建一个属性动画

48
00:02:25,913 --> 00:02:29,348
立即开始运行。现在它的论据是非常的

49
00:02:29,416 --> 00:02:32,351
简单。第一个持续时间是多久

50
00:02:32,419 --> 00:02:34,919
动画即将发生。所以你可以做到

51
00:02:34,988 --> 00:02:37,956
一秒钟的动画，或十秒钟，完全取决于你。

52
00:02:38,025 --> 00:02:40,825
延迟是你开始之前需要等待的时间

53
00:02:40,894 --> 00:02:43,895
动画。为什么你想延迟开始动画？

54
00:02:43,964 --> 00:02:46,097
那么，也许你有一些其他的动画是你想要的

55
00:02:46,166 --> 00:02:50,001
等待一段时间的定义，虽然有办法

56
00:02:50,070 --> 00:02:52,771
连锁动画，以便当一个完成后，

57
00:02:52,839 --> 00:02:54,973
你开始另一个，但它可能会延迟

58
00:02:55,041 --> 00:02:57,542
那个原因。然后我们稍后会讨论的选项，

59
00:02:57,611 --> 00:03:00,411
只是各种选项，你想如何运行动画。和

60
00:03:00,480 --> 00:03:03,748
那么所有重要的闭包在那里，动画，

61
00:03:03,817 --> 00:03:07,219
它不需要任何参数，不会返回这个闭包的参数

62
00:03:07,287 --> 00:03:09,120
你只需要输入代码即可

63
00:03:09,189 --> 00:03:11,522
修改这些属性。

64
00:03:11,591 --> 00:03:14,893
然后还有一个完成闭包。这会得到

65
00:03:14,962 --> 00:03:18,096
当动画实际完成运行时调用。

66
00:03:18,165 --> 00:03:20,331
那完成之一在那里有一个参数，

67
00:03:20,400 --> 00:03:23,067
哪个职位要么是开始，

68
00:03:23,136 --> 00:03:25,102
因为你可能会倒过来运行这个动画，

69
00:03:25,171 --> 00:03:28,173
信不信由你。或者它结束了，所以动画全部结束

70
00:03:28,242 --> 00:03:31,275
到最后的路。或者如果动画被中断

71
00:03:31,344 --> 00:03:34,245
中间，那么位置将被称为当前，

72
00:03:34,314 --> 00:03:37,182
.current。这里是一个枚举，.current。

73
00:03:37,251 --> 00:03:39,384
为什么动画会在中间被打断？

74
00:03:39,453 --> 00:03:42,320
你开始另一个动画，使其中一个动画

75
00:03:42,389 --> 00:03:45,590
属性。然后那个动画获胜并且

76
00:03:45,659 --> 00:03:47,392
它开始接管。

77
00:03:47,461 --> 00:03:49,694
现在你可以有多个这些属性动画师去

78
00:03:49,763 --> 00:03:53,098
并排。所有修改不同的属性，但

79
00:03:53,166 --> 00:03:56,734
一旦开始选择另一个的属性，

80
00:03:56,803 --> 00:03:59,037
后者开始赢得接管。

81
00:03:59,106 --> 00:04:01,406
好吧，然后这一个将停止，去，

82
00:04:01,474 --> 00:04:05,310
说它与当前位置完成。现在，有

83
00:04:05,379 --> 00:04:08,212
从概念上理解一些非常重要的事情

84
00:04:08,281 --> 00:04:12,016
动画是如何工作的。我会告诉你一个例子

85
00:04:12,085 --> 00:04:15,120
在animator上调用此运行属性。那

86
00:04:15,188 --> 00:04:19,758
您传递给它的闭包会立即执行。

87
00:04:20,994 --> 00:04:23,762
它不需要五秒钟，或十秒钟，或

88
00:04:23,831 --> 00:04:25,797
不管这个封闭执行多久。

89
00:04:25,866 --> 00:04:26,931
它立即执行

90
00:04:27,000 --> 00:04:30,702
立即生效。所以，动画只是

91
00:04:30,771 --> 00:04:34,572
用户看到了什么。用户正在看你的

92
00:04:34,641 --> 00:04:37,409
动画发生超过五秒或十秒，但实际上它

93
00:04:37,478 --> 00:04:40,344
发生在你开始动画的那一刻。好的，

94
00:04:40,413 --> 00:04:43,715
所以这里有一个区别。这是现实，

95
00:04:43,783 --> 00:04:46,618
这是你的代码。那么所有这一切都会立即发生

96
00:04:46,686 --> 00:04:49,921
有这种情况发生在用户身上。

97
00:04:49,989 --> 00:04:52,023
这是随着时间的推移发生的。所以，

98
00:04:52,092 --> 00:04:55,093
这可能会令人困惑，因为你可能有一个动画

99
00:04:55,162 --> 00:04:57,361
你设定在两秒钟内离开，

100
00:04:57,430 --> 00:05:00,532
并开始运行两秒钟。而且，你知道你是

101
00:05:00,601 --> 00:05:03,601
思考，是的，我的动画，当它完成，我的框架或

102
00:05:03,670 --> 00:05:06,404
我的中心或我的阿尔法将会改变。但是，不，现在

103
00:05:06,472 --> 00:05:10,642
你开始动画师，它改变了东西。所以

104
00:05:10,711 --> 00:05:12,176
你必须考虑这两个时间表。

105
00:05:12,245 --> 00:05:14,379
这是什么让动画有点困难，

106
00:05:14,448 --> 00:05:16,814
正在考虑他们，我们称之为模型，但是

107
00:05:16,883 --> 00:05:19,050
与模型视图控制器无关。但

108
00:05:19,119 --> 00:05:20,985
你知道你的代码中的实际情况，并且

109
00:05:21,054 --> 00:05:23,188
那么如果我们愿意的话，这个演示文稿就是另外一回事了

110
00:05:23,257 --> 00:05:24,689
用户看到。

111
00:05:24,758 --> 00:05:25,923
好吧，那么

112
00:05:25,992 --> 00:05:29,427
在这里，我将采取完全不透明的观点

113
00:05:29,495 --> 00:05:32,830
我会淡出它，然后当它消失时我会去

114
00:05:32,899 --> 00:05:35,901
将其从父视图中删除。所以这基本上是成立的

115
00:05:35,969 --> 00:05:39,237
一个视图从屏幕动画中消失。首先，

116
00:05:39,306 --> 00:05:41,940
我只是检查，以确保我完全不透明，

117
00:05:42,009 --> 00:05:45,576
如果我的alpha是1，那么我在这里调用动画师。

118
00:05:45,645 --> 00:05:49,047
这部动画需要3秒钟才能淡出

119
00:05:49,115 --> 00:05:51,382
它不会开始直到现在2秒。

120
00:05:51,451 --> 00:05:53,552
这是前两个参数的意思。

121
00:05:53,620 --> 00:05:55,120
然后我选择了一个选项

122
00:05:55,188 --> 00:05:57,021
好玩，这是allowUserInteraction

123
00:05:57,090 --> 00:05:59,423
这意味着当它淡出，手势和

124
00:05:59,492 --> 00:06:02,694
东西仍然会对它起作用。除此以外，

125
00:06:02,763 --> 00:06:06,097
如果你没有指定这个，那么动画就会发生这种情况

126
00:06:06,165 --> 00:06:09,100
你知道，你无法做到这一点，

127
00:06:09,169 --> 00:06:12,971
点击东西或任何东西。那么这是我的动画。

128
00:06:13,040 --> 00:06:16,007
我的动画只是将我的透明度设置为零

129
00:06:16,076 --> 00:06:19,511
完全透明，对吗？所以，那发生了

130
00:06:19,579 --> 00:06:22,280
我立即调用这个方法。此方法正在运行

131
00:06:22,349 --> 00:06:25,383
属性动画师立即返回执行

132
00:06:25,451 --> 00:06:29,253
闭包。然后我完成了。

133
00:06:29,322 --> 00:06:32,190
如果事情没有中断就结束了，

134
00:06:32,259 --> 00:06:34,493
换句话说，我的确一直淡出到0，

135
00:06:34,561 --> 00:06:37,262
那么我会从我的父视图中删除自己。

136
00:06:37,330 --> 00:06:39,898
这就是这个小小的完成闭包

137
00:06:39,967 --> 00:06:43,701
关于。但通知我把印刷阿尔法等于什么？

138
00:06:43,770 --> 00:06:47,638
这就是说阿尔法等于0.你明白为什么？

139
00:06:47,707 --> 00:06:50,174
因为即使它需要5秒钟

140
00:06:50,243 --> 00:06:53,111
那个阿尔法去零，它立即变为零，

141
00:06:53,180 --> 00:06:57,081
因为我执行了这个动画。所以

142
00:06:57,150 --> 00:06:59,417
我说过，我确定你喜欢耶是有道理的，但是

143
00:06:59,486 --> 00:07:02,920
直到你开始编码它，你会喜欢哇，

144
00:07:02,989 --> 00:07:04,555
没错，我已经改变了，

145
00:07:04,624 --> 00:07:06,358
它只是没有出现在屏幕上，所以

146
00:07:06,426 --> 00:07:09,594
你必须习惯这一点。什么是一些

147
00:07:09,663 --> 00:07:11,596
你在做这些时可以做的选择

148
00:07:11,665 --> 00:07:14,466
动画？第一个从现状开始，

149
00:07:14,534 --> 00:07:16,835
如果你正在动画一些属性，然后你开始

150
00:07:16,903 --> 00:07:19,437
另一个动画，动画相同的属性。

151
00:07:19,505 --> 00:07:22,473
它是从房地产的真实价值出发的？

152
00:07:22,542 --> 00:07:25,543
它是如何设置的，像alpha等于零？那也是

153
00:07:25,612 --> 00:07:28,079
跳到透明并从那里开始动画制作？要么

154
00:07:28,147 --> 00:07:31,683
它会从其他动画中的哪个位置进行拾取？

155
00:07:31,752 --> 00:07:35,353
这是真的，你使用的是正在存在的alpha状态

156
00:07:35,422 --> 00:07:37,756
动画还是你使用的是真正的阿尔法状态

157
00:07:37,824 --> 00:07:40,458
代码中使用我们上一张幻灯片的是什么，

158
00:07:40,526 --> 00:07:45,163
会是零？好的，所以这有点像捡起来的

159
00:07:45,231 --> 00:07:48,232
只是使用真正的版本。如果我们这么做的话，我们会这么做

160
00:07:48,301 --> 00:07:50,134
有重叠的动画正在做

161
00:07:50,203 --> 00:07:54,272
两个不同的动画相同的属性。

162
00:07:54,340 --> 00:07:56,675
我们还有什么？我们得到了重复和autoreverse。

163
00:07:56,743 --> 00:07:58,442
所以你可以有动画，可以前进和

164
00:07:58,511 --> 00:08:00,679
向前和向后。

165
00:08:00,747 --> 00:08:02,780
这是一种循环。这很有趣。

166
00:08:02,849 --> 00:08:05,383
在底部看到这些曲线。曲线缓解，

167
00:08:05,451 --> 00:08:07,652
缓解。例如，从底部开始第三。

168
00:08:07,721 --> 00:08:09,554
这只是说，当你移动这个东西时，

169
00:08:09,623 --> 00:08:11,989
它是否线性移动？这是曲线线性的，

170
00:08:12,058 --> 00:08:14,825
这就像它会这样移动，或者它会这样

171
00:08:14,894 --> 00:08:17,695
缓缓地进入缓慢的行动，然后提升速度

172
00:08:17,764 --> 00:08:20,432
那么最后放慢速度？现在你为什么要这样做

173
00:08:20,500 --> 00:08:25,637
那？那些非常线性感觉很好的东西

174
00:08:25,705 --> 00:08:29,006
机器人和机械。在和缓解的事情

175
00:08:29,075 --> 00:08:31,909
然后放松一下，感觉更像是有人挑选了他们

176
00:08:31,978 --> 00:08:34,812
并将它们移动并放下。你看。所以

177
00:08:34,881 --> 00:08:37,315
它只是一种更自然的运动。所以喜欢

178
00:08:37,383 --> 00:08:40,585
移动你几乎总是想要曲线缓和的东西，

179
00:08:40,653 --> 00:08:44,188
缓解。但其他人可能会淡化为alpha。

180
00:08:44,257 --> 00:08:49,560
也许你不需要你可以线性淡出。所以

181
00:08:49,629 --> 00:08:51,730
这是视图动画，超级，超级简单。

182
00:08:51,798 --> 00:08:55,400
你只能动画这些属性。这很容易

183
00:08:55,468 --> 00:08:58,403
做。再一次，我只是抓了表面。

184
00:08:58,471 --> 00:09:01,071
我在UIViewPropertyAnimator中向您展示了一种方法。

185
00:09:01,140 --> 00:09:03,007
它有几十种方法，

186
00:09:03,076 --> 00:09:05,643
那里有很多的能力。好，如此

187
00:09:05,711 --> 00:09:08,079
现在我们来谈谈一个完全不同的有点动画。

188
00:09:08,148 --> 00:09:11,516
这是动画整个视图变化。

189
00:09:11,585 --> 00:09:14,452
所以你有一个看法，它会完全改变

190
00:09:14,520 --> 00:09:17,422
它的外观和你想在某些方面动画。

191
00:09:17,491 --> 00:09:18,956
而且有限的方法可以做到这一点。

192
00:09:19,025 --> 00:09:22,593
这种经典的例子是一张纸牌。当一场比赛

193
00:09:22,662 --> 00:09:26,063
卡面朝下，看起来像斯坦福标志或

194
00:09:26,132 --> 00:09:29,567
这是一张卡的背面。当它面朝上时，它有点和

195
00:09:29,636 --> 00:09:31,268
角落和所有这些东西。

196
00:09:31,337 --> 00:09:35,840
好的，当我想把我的卡翻过来时，我可以

197
00:09:35,908 --> 00:09:37,875
立即改变它，它会改变回来

198
00:09:37,944 --> 00:09:42,080
十分明显，但这可以让我真正地翻转它。

199
00:09:42,149 --> 00:09:44,915
就像一个3D看起来翻转。和

200
00:09:44,984 --> 00:09:47,918
你也可以从一个事物交叉解散到另一个事物。

201
00:09:47,987 --> 00:09:50,454
这些是你可以在这里做的两件大事。有卷毛

202
00:09:50,523 --> 00:09:52,924
从底部开始也是如此，这就像它卷起来一样，

203
00:09:52,993 --> 00:09:54,959
而你正在看它背后的一张纸

204
00:09:55,028 --> 00:09:56,627
这是新版本。但

205
00:09:56,696 --> 00:09:58,796
这只适用于填充整个屏幕的视图。

206
00:09:58,865 --> 00:10:01,498
好吧，那不适合，如果它真的没有效果

207
00:10:01,567 --> 00:10:06,771
在另一个视图内的视图。这种感觉不对。所以

208
00:10:06,840 --> 00:10:09,574
这是为了过渡只是平滑或

209
00:10:09,642 --> 00:10:12,744
将完整的变化动画化为视图。打牌

210
00:10:12,812 --> 00:10:14,913
就是一个典型的例子。你可以这样称呼它。

211
00:10:14,981 --> 00:10:17,648
你可以在UIView中使用这个方法。这是一种类方法

212
00:10:17,717 --> 00:10:21,920
称为View的转换。而你又给了，持续时间。

213
00:10:21,988 --> 00:10:24,522
你给出选项。与以前相同的选项。

214
00:10:24,591 --> 00:10:27,391
还有一些选择，如转换从左侧翻转，

215
00:10:27,460 --> 00:10:30,027
这意味着从左边缘翻转这个东西。

216
00:10:30,096 --> 00:10:31,262
你也可以从顶部翻转，

217
00:10:31,330 --> 00:10:34,231
从底部翻转，交叉溶解，

218
00:10:34,300 --> 00:10:37,201
那些东西。而现在，在动画块中，

219
00:10:37,270 --> 00:10:40,104
你不仅限于改变视图属性，

220
00:10:40,173 --> 00:10:41,706
你可以改变任何你想要的，

221
00:10:41,775 --> 00:10:44,041
这将使这件事看起来不同。和

222
00:10:44,110 --> 00:10:46,911
那么，动画系统所做的就是绘制你的动画

223
00:10:46,980 --> 00:10:50,682
在关闭之前查看。然后它执行闭包，

224
00:10:50,750 --> 00:10:54,385
之后绘制视图，然后将其翻转或

225
00:10:54,454 --> 00:10:57,222
交叉解散它，看看这里发生了什么？所以

226
00:10:57,290 --> 00:10:59,857
这是一个很大的变化的简单的动画师。

227
00:10:59,926 --> 00:11:02,059
扑克牌就是一个很好的例子，我们将会看到

228
00:11:02,128 --> 00:11:04,862
我要做的演示。好的，这就是数字

229
00:11:04,931 --> 00:11:08,198
二。这是第三。这个更强大一点，

230
00:11:08,267 --> 00:11:09,400
更复杂一点。

231
00:11:09,468 --> 00:11:13,104
动态动画，这是一个动画的小方法。

232
00:11:13,172 --> 00:11:16,541
在这里，我们将在我们的物体上设置物理属性

233
00:11:16,609 --> 00:11:20,377
意见，然后告诉他们去做他们所做的事情。所以

234
00:11:20,446 --> 00:11:24,548
我们正在谈论物理如密度，摩擦，重力。

235
00:11:24,617 --> 00:11:26,350
像这样的东西。你把它们放在那里

236
00:11:26,419 --> 00:11:30,088
那么他们只是开始移动，因为物理，它的作品。所以

237
00:11:30,156 --> 00:11:34,225
让我们来看看你是如何做到这一点的。首先，

238
00:11:34,294 --> 00:11:35,860
有三个步骤来实现它。

239
00:11:35,929 --> 00:11:37,628
首先，你需要一个动画师。

240
00:11:37,697 --> 00:11:40,364
这只是驱动动画的东西。

241
00:11:40,433 --> 00:11:43,501
它是一个名为UIDynamicAnimator的类的实例，

242
00:11:43,570 --> 00:11:46,270
它在初始化器中只需要一个参数，

243
00:11:46,339 --> 00:11:48,973
这是将成为参考的视图

244
00:11:49,042 --> 00:11:52,076
所有正在进行的动画的坐标系统。

245
00:11:52,145 --> 00:11:54,712
而这个视图的唯一要求，可以是任何视图

246
00:11:54,781 --> 00:11:58,182
你的应用。它只是一个超级视图，或者超级视图

247
00:11:58,251 --> 00:11:59,650
超级视图或超级视图的超级视图。

248
00:11:59,719 --> 00:12:02,319
它必须位于所有视图层次结构的顶部

249
00:12:02,388 --> 00:12:05,055
动画制作者将要制作动画的视图。

250
00:12:05,124 --> 00:12:07,725
但是这些视图并不一定都是相同的视图。

251
00:12:07,794 --> 00:12:09,494
他们可以在其他视图的子视图。

252
00:12:09,562 --> 00:12:12,396
只要他们都最终有这个视图。

253
00:12:12,465 --> 00:12:16,367
作为父视图的参考视图。所以很多时候人

254
00:12:16,435 --> 00:12:18,436
想让他们的整个视图控制器的视图，和

255
00:12:18,505 --> 00:12:19,970
这就是我在演示中要做的。

256
00:12:20,039 --> 00:12:22,039
成为参考视图因为我没有任何其他意见。

257
00:12:22,108 --> 00:12:24,642
但就像在你的任务中一样，你可能只是提出你的看法

258
00:12:24,711 --> 00:12:27,077
包含你的卡片是你的参考视图。

259
00:12:27,146 --> 00:12:29,547
因为你只会使卡片动起来。所以

260
00:12:29,616 --> 00:12:33,150
你不需要去更高的水平，好吗？事实上，

261
00:12:33,219 --> 00:12:35,286
保持较低的价格更好，因为它可以更多

262
00:12:35,355 --> 00:12:37,688
面向对象的动画代码放在它的位置

263
00:12:37,757 --> 00:12:40,057
实际上正在发生，而不是把一切都放在你的身上

264
00:12:40,126 --> 00:12:43,294
控制器。但我会顺便说一句，特别是当你

265
00:12:43,363 --> 00:12:45,296
看到我做的演示，这是非常轻量级的，

266
00:12:45,365 --> 00:12:48,299
你有可能在iOS开始时有这种倾向

267
00:12:48,368 --> 00:12:50,902
人们把所有东西放在视图控制器中

268
00:12:50,971 --> 00:12:54,038
也许它想要在自定义视图中降低水平。

269
00:12:54,107 --> 00:12:55,707
所以只是在那里思考食物。

270
00:12:55,775 --> 00:12:58,576
想想事情要达到什么水平。好，如此

271
00:12:58,645 --> 00:12:59,744
第一个是创建动画师，

272
00:12:59,812 --> 00:13:02,113
第二个是创造行为。

273
00:13:02,182 --> 00:13:06,583
所以这是描述这个视图中的事物是如何表现的。

274
00:13:06,652 --> 00:13:08,519
所以我们在谈论引力，而且

275
00:13:08,587 --> 00:13:11,121
不管事物是否相互碰撞，都是这样的。

276
00:13:11,190 --> 00:13:13,924
好的，那些是行为，并且你添加了行为

277
00:13:13,993 --> 00:13:16,560
动画师，所以动画师有一个添加行为的方法。

278
00:13:16,629 --> 00:13:19,697
你在创建一个行为之后调用它

279
00:13:19,766 --> 00:13:23,534
你只需添加它。现在只要您添加该行为。

280
00:13:23,602 --> 00:13:26,838
该动画师将开始执行该行为，

281
00:13:26,907 --> 00:13:28,372
无论是重力或碰撞还是

282
00:13:28,441 --> 00:13:31,175
随你。但目前还没有物品

283
00:13:31,244 --> 00:13:32,843
受到这些行为的影响。

284
00:13:32,912 --> 00:13:36,113
所以第三步是添加项目的行为。

285
00:13:36,182 --> 00:13:38,983
所以它创建了一个动画师，为动画师添加行为。

286
00:13:39,051 --> 00:13:41,852
现在添加项目的行为。您添加的时刻

287
00:13:41,921 --> 00:13:44,722
一个项目的行为，它会开始受到影响

288
00:13:44,791 --> 00:13:48,092
假设它在动画师中的行为。

289
00:13:48,161 --> 00:13:51,863
UIView是这里的项目，但实际上有

290
00:13:51,931 --> 00:13:55,433
不是UIView的，它是任何实现协议的对象

291
00:13:55,502 --> 00:13:57,835
UIDynamicItem，它不一定是一个视图。

292
00:13:57,903 --> 00:13:59,971
我会在一秒钟之内向你展示该协议。但

293
00:14:00,039 --> 00:14:04,008
UIViews是我们将项目传递给这些项目的99％

294
00:14:04,077 --> 00:14:07,278
行为。所以如果我说重力增加项目，项目1，

295
00:14:07,347 --> 00:14:10,247
第1项将立即开始感受重力的拉动。

296
00:14:10,316 --> 00:14:14,518
如果我在第1项中说对撞机，则立即开始第1项

297
00:14:14,587 --> 00:14:17,421
与作为项目添加的其他所有内容碰撞

298
00:14:17,490 --> 00:14:21,625
对撞机，在对撞机中。你不说去。就像

299
00:14:21,694 --> 00:14:24,194
只要你添加一个项目，它开始受到影响

300
00:14:24,263 --> 00:14:26,730
行为。如果你删除一件物品，它会立即停止

301
00:14:26,799 --> 00:14:28,099
受该行为影响。

302
00:14:30,103 --> 00:14:31,602
这是该视图实现的UI动态项目协议。

303
00:14:31,603 --> 00:14:33,102
可以，然后呢

304
00:14:33,172 --> 00:14:35,973
View实际上自动实现了其中的三个。

305
00:14:36,042 --> 00:14:39,009
它已经有了一个界限，中心和变革。可以，然后呢

306
00:14:39,078 --> 00:14:41,979
它会自动实现这些。然后是另外两个

307
00:14:42,048 --> 00:14:44,148
只是非常简单的事情与碰撞。

308
00:14:44,217 --> 00:14:45,883
我甚至不会谈论这些。

309
00:14:45,952 --> 00:14:49,987
但是你可以看到动态项目协议中的内容

310
00:14:50,056 --> 00:14:53,123
动画系统是能够动画的。

311
00:14:53,192 --> 00:14:56,227
它能够通过边界动画化大小。

312
00:14:56,296 --> 00:14:58,896
它能够通过中心动画化位置。

313
00:14:58,965 --> 00:15:01,766
而且它能够对变换进行动画处理，所以

314
00:15:01,835 --> 00:15:03,467
它可以旋转和缩放

315
00:15:03,536 --> 00:15:06,537
在这方面做任何事情都是非常需要的。

316
00:15:06,605 --> 00:15:10,041
它往往主要使用中心的变换来完成它

317
00:15:10,110 --> 00:15:14,244
动画。好的，注意的界限是只读的。

318
00:15:14,313 --> 00:15:17,214
所以界限只是针对显然看起来的视图

319
00:15:17,283 --> 00:15:19,082
在他们自己的绘画和东西的界限。

320
00:15:19,151 --> 00:15:22,987
动画师实际上并没有改变边界，因为它走了。

321
00:15:23,056 --> 00:15:26,123
主要是做中心和改造。顺便一提，

322
00:15:26,192 --> 00:15:29,493
如果你通过行为给动画师一个物体

323
00:15:29,562 --> 00:15:32,463
操作它，真的是动画师拥有它。

324
00:15:32,532 --> 00:15:33,397
它拥有一个中心和

325
00:15:33,466 --> 00:15:35,733
转变，因为它会改变他们。

326
00:15:35,801 --> 00:15:38,302
所以如果你想改变一个标准或者转换

327
00:15:38,371 --> 00:15:41,172
你已经给了一个行为的视图，那么你必须

328
00:15:41,240 --> 00:15:43,674
在你的动态动画器中调用这个方法

329
00:15:43,743 --> 00:15:45,710
将项目更新为当前状态。

330
00:15:45,779 --> 00:15:47,945
换句话说，我改变了中心或

331
00:15:48,014 --> 00:15:51,015
Animator先生，请转换。

332
00:15:51,084 --> 00:15:53,684
所以动画师会采取这种状态，移动物体，

333
00:15:53,753 --> 00:15:56,487
改变它的转换，然后再次开始表现。

334
00:15:57,857 --> 00:16:01,192
继续前进，从那里表现。好，如此

335
00:16:01,260 --> 00:16:01,859
让我们来谈谈一些

336
00:16:01,927 --> 00:16:03,828
你可以拥有的行为。我提到了引力。

337
00:16:03,897 --> 00:16:07,598
重力是一件容易的事。默认情况下，重力下降，

338
00:16:07,667 --> 00:16:10,100
意思是朝着home键或者

339
00:16:10,169 --> 00:16:13,804
设备的底部。像iPhone 10一样，它远离

340
00:16:13,873 --> 00:16:17,441
顶部的脸部识别材料。而规模，

341
00:16:17,510 --> 00:16:22,412
我们有时称之为G，但它不是真的G.

342
00:16:22,481 --> 00:16:26,984
1.0的幅度是每秒每秒1000点。

343
00:16:27,053 --> 00:16:28,519
每个人都知道重力是什么，对吧？

344
00:16:28,588 --> 00:16:31,322
这是一个9.8米/秒的加速度。

345
00:16:31,391 --> 00:16:33,724
所以，这是每秒每秒1000点。

346
00:16:33,793 --> 00:16:36,360
现在，令人难以置信的是每秒1000点

347
00:16:36,429 --> 00:16:39,496
秒感觉很像每秒9.8平方米。

348
00:16:39,565 --> 00:16:42,699
换句话说，如果我把一个对象放在屏幕的顶部

349
00:16:42,768 --> 00:16:46,170
并添加到它的行为与重力，它下降

350
00:16:46,238 --> 00:16:48,873
与真实生活物体的速度大致相同。

351
00:16:48,942 --> 00:16:49,973
令人惊讶的是，

352
00:16:50,042 --> 00:16:53,377
那个整数最终就是这样的。但它是。

353
00:16:53,446 --> 00:16:56,213
而且，重力也不一定会下降。你（们）能做到

354
00:16:56,282 --> 00:17:00,384
重力上升。或者在您想要的地方或任何地方。所以

355
00:17:00,452 --> 00:17:04,088
你可以完全控制与重力有关的事情。

356
00:17:04,157 --> 00:17:06,190
依恋行为，非常酷。

357
00:17:06,259 --> 00:17:11,963
把它想成一个铁条bar，

358
00:17:12,031 --> 00:17:15,599
或两个项目之间或项目与之间的bar

359
00:17:15,668 --> 00:17:20,204
一个固定点，好吗？该bar保留这两个项目

360
00:17:20,273 --> 00:17:23,841
即使所有其他行为都起作用。

361
00:17:23,910 --> 00:17:27,911
所以，想象你有两件事与一个分队联系在一起

362
00:17:27,980 --> 00:17:30,748
行为。所以他们表现得好像他们每个人都有联系

363
00:17:30,816 --> 00:17:33,550
其他。他们开始倒下，因为他们都是

364
00:17:33,619 --> 00:17:37,321
靠重力操作。那么让我们假设其中一个碰撞

365
00:17:37,390 --> 00:17:40,191
与某事。那个树皮会成功的，所以

366
00:17:40,259 --> 00:17:42,292
另一个没有碰撞的是会

367
00:17:42,361 --> 00:17:45,129
像钟摆一样摆动，你看到了吗？因为这一个下来，

368
00:17:45,197 --> 00:17:47,631
它相撞，而且这个继续前进。但

369
00:17:47,700 --> 00:17:51,068
bar让他们在一起。同样的事情，如果你附加

370
00:17:51,137 --> 00:17:54,372
它到一个固定的点。然后你开启引力，它会

371
00:17:54,440 --> 00:17:56,640
开始倒下。但是当它到达底部时，

372
00:17:56,709 --> 00:17:59,143
它会像钟摆一样摆动。最终，

373
00:17:59,212 --> 00:18:00,144
重力会拉动它

374
00:18:00,213 --> 00:18:03,413
它直线下降。你明白我在说什么了吗？所以

375
00:18:03,482 --> 00:18:06,350
附件，真棒，很酷的小东西。另一件事

376
00:18:06,419 --> 00:18:09,854
这对他们来说很酷，你可以改变这个长度

377
00:18:09,922 --> 00:18:13,924
bar，而动画的发生。所以它是动画。

378
00:18:13,993 --> 00:18:16,093
事情正在下降，反弹，事情正在发生碰撞

379
00:18:16,162 --> 00:18:18,529
的东西。他们附着，你可以让bar得到

380
00:18:18,597 --> 00:18:20,831
更接近或更远离。你也可以做

381
00:18:20,900 --> 00:18:23,400
bar种类的弹性与一定的阻尼。所以

382
00:18:23,469 --> 00:18:26,036
那东西碰到什么东西，然后它会走到一起，

383
00:18:26,105 --> 00:18:28,539
然后回来让他们的依恋成为正确的

384
00:18:28,608 --> 00:18:30,807
距离。这是非常酷的行为。

385
00:18:30,876 --> 00:18:33,510
然后是碰撞行为。这可能是

386
00:18:33,579 --> 00:18:37,014
最常见的行为。好的，这是对象UIView

387
00:18:37,083 --> 00:18:41,352
彼此反弹或从贝塞尔路径反弹，

388
00:18:41,421 --> 00:18:45,923
基本上，在后台。你刚刚设置

389
00:18:45,992 --> 00:18:48,793
添加你想要的任何修复边界作为贝塞尔路径，

390
00:18:48,861 --> 00:18:52,129
通常，然后添加项目。你可以控制

391
00:18:52,197 --> 00:18:54,765
不管项目是互相反弹还是仅仅反弹

392
00:18:54,834 --> 00:18:57,802
边界作为你建立的贝塞尔路径。所有这些都比较卑鄙

393
00:18:57,870 --> 00:19:00,037
路径在参考视图坐标系中，

394
00:19:00,106 --> 00:19:02,540
顺便一提。他们并没有真正绘制或任何东西。

395
00:19:02,608 --> 00:19:08,278
他们只是概念上的空间界限。

396
00:19:08,347 --> 00:19:11,515
那里有一个非常酷的变种。

397
00:19:11,584 --> 00:19:14,051
从底部的第二个翻译参考

398
00:19:14,120 --> 00:19:16,053
进入边界。如果你设置为true

399
00:19:16,121 --> 00:19:19,156
碰撞行为，然后你的参考意见

400
00:19:19,224 --> 00:19:22,626
外边缘将成为边界，这是常见的因素

401
00:19:22,695 --> 00:19:24,895
你的参考视图中会有东西在弹跳。

402
00:19:24,964 --> 00:19:28,366
他们将主要留在里面。现在，关于碰撞的一件事

403
00:19:28,434 --> 00:19:31,702
许多人认为，如果我把我的参考

404
00:19:31,771 --> 00:19:34,938
边界作为碰撞边界，那么任何对象都不会得到

405
00:19:35,007 --> 00:19:37,941
出。好吧，它永远不会逃脱。但事实并非如此。

406
00:19:38,010 --> 00:19:40,478
因为物品可以，例如，移动得太快以至于

407
00:19:40,546 --> 00:19:43,147
一个动画框架，他们从一边移动

408
00:19:43,215 --> 00:19:45,883
边界到另一边。然后他们只是飞进来

409
00:19:45,952 --> 00:19:48,685
外层空间，他们永远消失了。所以

410
00:19:48,754 --> 00:19:51,655
碰撞界限，他们只检查

411
00:19:51,724 --> 00:19:55,059
在动画的每个帧上碰撞，等等

412
00:19:55,127 --> 00:19:58,295
他们不是一个锁定保证。你保持的东西

413
00:19:58,364 --> 00:20:01,164
如果你在每件事物的周围放置一个碰撞边界。

414
00:20:01,233 --> 00:20:04,268
现在，碰撞边界也有一个代表。其

415
00:20:04,336 --> 00:20:07,004
代表允许你找出碰撞发生的时间。

416
00:20:07,072 --> 00:20:09,673
所以如果你设置了一些碰撞委托，

417
00:20:09,741 --> 00:20:12,876
你会得到像碰撞行为这些方法，开始，

418
00:20:12,945 --> 00:20:15,412
联系一些具有边界的动态项目

419
00:20:15,481 --> 00:20:19,050
带名称的标识符。顺便说一下，注意边界

420
00:20:19,118 --> 00:20:22,052
标识符是NSCopying类型。

421
00:20:22,121 --> 00:20:24,121
这真是奇怪的旧Objective-C的东西。

422
00:20:24,189 --> 00:20:26,723
这仅仅意味着他们要么是NS号，要么是NS号

423
00:20:26,792 --> 00:20:31,695
串。所以你可以用S来把它们变成一个字符串或者

424
00:20:31,764 --> 00:20:34,931
一个double或一个int，因为我们知道NS号和

425
00:20:35,000 --> 00:20:38,002
NS字符串可以像自动一样

426
00:20:38,071 --> 00:20:42,906
斯威夫特在那里的同行。碰撞很酷。

427
00:20:42,975 --> 00:20:46,043
SnapBehavior也很常见。这是

428
00:20:46,111 --> 00:20:48,612
当你使用动态动画系统时，你如何

429
00:20:48,681 --> 00:20:52,349
移动某物。所以你想把东西搬到别的地方。

430
00:20:52,418 --> 00:20:55,019
您正在使用的视图属性动画不在这里

431
00:20:55,087 --> 00:20:58,021
动态动画，所以你说抓住这一点。

432
00:20:58,090 --> 00:21:00,257
比视图属性1好一点，

433
00:21:00,326 --> 00:21:02,926
因为它在那里捕捉时，它不会跳跃

434
00:21:02,995 --> 00:21:05,229
就在那里，甚至可以缓解并放松。

435
00:21:05,297 --> 00:21:07,331
它实际上到达那里，当它在那里时，

436
00:21:07,399 --> 00:21:09,866
想象它在角落里有四个弹簧。所以这样

437
00:21:09,935 --> 00:21:13,137
进来并振动一点。所以感觉更多

438
00:21:13,205 --> 00:21:16,607
自然飞过屏幕并停下来。所以你会的

439
00:21:16,676 --> 00:21:19,777
可能因为你在家庭作业中使用快速行为

440
00:21:19,845 --> 00:21:22,646
必须把匹配的牌扔进丢弃堆。你是

441
00:21:22,714 --> 00:21:24,448
大概会用snapTo把它们扔出去，

442
00:21:24,517 --> 00:21:25,649
因为你会做动态的

443
00:21:25,717 --> 00:21:29,553
动画与他们否则。然后是PushBehavior。

444
00:21:29,622 --> 00:21:31,922
好吧，PushBehavior只是推动一个对象。

445
00:21:31,990 --> 00:21:35,659
它可以不断推动它。或者它可以推动

446
00:21:35,727 --> 00:21:39,864
它曾经，就像打它。这是一个有趣的。

447
00:21:39,932 --> 00:21:43,633
您可以指定推送的角度和大小。

448
00:21:43,702 --> 00:21:46,070
瞬间之一是有趣的，因为想想

449
00:21:46,138 --> 00:21:49,573
关于它。这是添加到动画师的行为，

450
00:21:49,641 --> 00:21:53,176
如果是瞬间的，这种行为只会触发一次。

451
00:21:53,245 --> 00:21:55,479
然后它就永远坐在那里无所事事。

452
00:21:55,547 --> 00:21:58,248
所以这只是一种克罗夫特。所以如果是这样会很好

453
00:21:58,317 --> 00:22:00,985
有一种方法可以添加PushBehavior并说，

454
00:22:01,053 --> 00:22:02,152
你开除后，

455
00:22:02,221 --> 00:22:04,388
请删除你自己，因为你已经完成了你的工作。

456
00:22:04,457 --> 00:22:06,123
我会告诉你如何做到这一点，但它会

457
00:22:07,960 --> 00:22:10,294
要求我教你多一点闭包，

458
00:22:10,362 --> 00:22:15,332
我会稍微做一点。另一个是

459
00:22:15,401 --> 00:22:19,470
一个UIDynamicItemBehavior。这就像一个元行为。所以

460
00:22:19,538 --> 00:22:22,372
这是一种你指定摩擦的行为

461
00:22:22,441 --> 00:22:25,376
和弹性以及是否允许视图旋转

462
00:22:25,445 --> 00:22:26,944
它反弹的东西。

463
00:22:27,012 --> 00:22:29,680
这影响了所有其他行为如何工作，对吗？

464
00:22:29,749 --> 00:22:33,149
如果增加更多的摩擦，那么显然，重力会拉动

465
00:22:33,218 --> 00:22:35,552
的东西。他们动作较慢，因为他们有摩擦，

466
00:22:35,621 --> 00:22:40,457
等等。你也可以问一下UIDynamicItemBehavior

467
00:22:40,526 --> 00:22:44,461
所有的项目。诸如此类，你目前的速度是什么。

468
00:22:44,530 --> 00:22:46,596
你在屏幕上移动的速度有多快，或者

469
00:22:46,665 --> 00:22:49,433
即使你碰巧在旋转，你甚至有多快旋转，

470
00:22:49,502 --> 00:22:50,800
这种情况发生得有多快？

471
00:22:50,869 --> 00:22:54,771
所以UIDynamicItemBehavior，我们几乎总是拥有所有或者

472
00:22:54,840 --> 00:22:56,640
UIDynamicItemBehavior中的项目，

473
00:22:56,709 --> 00:22:59,576
因为我们希望能够设定这些不同的事情

474
00:22:59,645 --> 00:23:03,481
他们。然后是UIDynamicBehavior，

475
00:23:03,549 --> 00:23:06,016
这是所有这些行为的父类，

476
00:23:06,085 --> 00:23:07,384
碰撞行为，重力行为，

477
00:23:07,453 --> 00:23:10,453
所有这些东西。现在，你可以继承这个和

478
00:23:10,522 --> 00:23:12,489
尝试和写你自己的行为，

479
00:23:12,558 --> 00:23:16,159
但写一个重力行为是相当困难的。很多数学

480
00:23:16,228 --> 00:23:18,963
参与那里，试图让它工作。但事实并非如此

481
00:23:19,031 --> 00:23:21,932
为什么使用UIDynamicBehavior的子类？你做什么

482
00:23:22,001 --> 00:23:24,734
与UIDynamicBehavior是你收集其他行为，

483
00:23:24,803 --> 00:23:27,404
像碰撞和重力等所有其他的东西，

484
00:23:27,473 --> 00:23:30,240
融入一种行为。所以你有一个你添加的行为

485
00:23:30,308 --> 00:23:32,876
你的物品到了，它有所有这些孩子的行为

486
00:23:32,945 --> 00:23:34,812
这使得它的表现完全一致。

487
00:23:34,880 --> 00:23:36,613
我们也要做一些演示，以及

488
00:23:36,682 --> 00:23:39,883
你这样做的方式是你调用addChildBehavior

489
00:23:39,952 --> 00:23:43,453
对你自己，如果你是UIDynamicBehavior子类。和

490
00:23:43,522 --> 00:23:48,658
它现在导致这种行为成为你的行为。所以

491
00:23:48,727 --> 00:23:52,162
很简单。 UIDynamicBehavior也有

492
00:23:52,231 --> 00:23:55,232
一个名为动态动画的栏。

493
00:23:55,300 --> 00:23:58,669
那是你现在正在动画的动画师，

494
00:23:58,737 --> 00:24:01,605
如果有的话。好的，你可以看看这个发现。

495
00:24:01,674 --> 00:24:03,940
我目前正在动画？这种行为或

496
00:24:04,009 --> 00:24:07,144
它是不是动画？如果它正在动画，

497
00:24:07,212 --> 00:24:09,012
谁通过？它甚至会向你发送消息。

498
00:24:09,081 --> 00:24:11,982
当你切换到另一个时，将移动到动画师

499
00:24:12,051 --> 00:24:14,251
动画师。通常当你从没有动画的时候开始

500
00:24:14,320 --> 00:24:18,221
被动画或反之亦然，好吗？

501
00:24:18,290 --> 00:24:21,525
现在UIDynamicBehavior有另一个很棒的

502
00:24:21,593 --> 00:24:24,094
当你创建一个子类或者你继承的var

503
00:24:24,163 --> 00:24:26,062
当创建子类时。

504
00:24:26,131 --> 00:24:29,532
这是行动。所以行动就是闭包。毫无争议，

505
00:24:29,601 --> 00:24:33,070
不返回任何参数。这个闭包每执行一次

506
00:24:33,139 --> 00:24:39,076
时间这个UIDynamicBehavior行为。所以就像一个推动行为

507
00:24:39,145 --> 00:24:42,546
这是瞬间的，这会被调用一次。仅Cuz

508
00:24:42,614 --> 00:24:45,615
一旦它对目标起作用。但碰撞行为是

509
00:24:45,684 --> 00:24:48,686
总是对外部重力行为总是起作用。

510
00:24:48,754 --> 00:24:50,921
所以这个东西被召唤了很多。

511
00:24:50,989 --> 00:24:54,124
所以永远不要在那里花费很长时间

512
00:24:54,193 --> 00:24:57,327
执行，因为它会让你的动画慢下来。

513
00:24:57,396 --> 00:24:59,529
因为这些东西都被称为所有的时间，

514
00:24:59,598 --> 00:25:01,932
这些行动在这里闭包。但

515
00:25:02,000 --> 00:25:04,634
他们可能会有用。例如，你可能想要

516
00:25:04,703 --> 00:25:08,304
在这里检查我的看法如何离开建筑物，对吧？

517
00:25:08,373 --> 00:25:10,908
你可以看看这个行为的任何项目

518
00:25:10,976 --> 00:25:14,043
采取行动，并且导致这件事走到外面

519
00:25:14,112 --> 00:25:15,879
参考边界甚至？管他呢，

520
00:25:15,948 --> 00:25:18,581
所以我必须把它放回去，否则可能会摧毁它，或者

521
00:25:18,650 --> 00:25:21,217
类似的东西。再一次，它只需要几个

522
00:25:21,286 --> 00:25:23,753
代码行来检查项目的界限

523
00:25:23,822 --> 00:25:25,890
参考范围，看看是否有任何事情发生。

524
00:25:25,958 --> 00:25:29,526
所以这可以放在你的行动。

525
00:25:29,595 --> 00:25:32,128
现在我们将在一秒钟之内使用这个动作

526
00:25:32,197 --> 00:25:36,366
解决推送行为问题，好吗？最后，

527
00:25:36,435 --> 00:25:39,903
我要谈谈动画师的停滞。真，

528
00:25:39,972 --> 00:25:43,273
大多数时候我们设计这些动画机制，

529
00:25:43,342 --> 00:25:45,442
与所有的重力和碰撞边界和

530
00:25:45,511 --> 00:25:47,577
物理学和所有这些东西，我们以我们的方式设计它

531
00:25:47,646 --> 00:25:51,248
期待它停下来。好的，和

532
00:25:51,316 --> 00:25:53,784
那么推动就会发生，并且会再次活跃起来。

533
00:25:53,852 --> 00:25:56,220
然后它最终停下来。大多数时候，

534
00:25:56,288 --> 00:25:58,254
这不是必需的。你可以不断地做事情

535
00:25:58,323 --> 00:26:01,591
一直在四处走动。但通常你会推，

536
00:26:01,660 --> 00:26:04,995
无论什么时候停止。所以你可以找出它的时间

537
00:26:05,064 --> 00:26:08,364
与UIDynamicAnimator的代表达成停滞

538
00:26:08,433 --> 00:26:11,602
有这两种方法。暂停并恢复。

539
00:26:11,671 --> 00:26:14,103
它会告诉你，我来停滞。

540
00:26:14,172 --> 00:26:15,873
我目前没有移动任何东西

541
00:26:15,941 --> 00:26:18,975
然后发生一些事情它会说我正在恢复，因为我

542
00:26:19,044 --> 00:26:24,747
必须移动的东西。好的，好吗？我们回去吧

543
00:26:24,816 --> 00:26:27,483
谈论推动行为的事情。所以我真的很想

544
00:26:27,552 --> 00:26:29,920
做一些事情。我有这种推动行为，对吧？

545
00:26:29,989 --> 00:26:33,223
我设定它的大小和角度。但我真的很想

546
00:26:33,292 --> 00:26:37,427
推动行为在推动时立即抛弃

547
00:26:37,496 --> 00:26:40,630
因为它是瞬间的。你看到这里，我的东西是

548
00:26:40,699 --> 00:26:43,300
瞬间。推，所以它只会推一次。

549
00:26:43,369 --> 00:26:45,135
然后我希望它被扔掉，所以

550
00:26:45,203 --> 00:26:47,537
它并没有把堆完全无用

551
00:26:47,606 --> 00:26:48,672
行为，好吗？

552
00:26:48,740 --> 00:26:50,440
那么，我可以用这个动作方法来做到这一点，

553
00:26:50,508 --> 00:26:53,109
这里的黄色部分。所以我可以推动

554
00:26:53,178 --> 00:26:57,314
行为动作所有行为都会继承此动作闭包。

555
00:26:57,382 --> 00:27:00,951
在闭包的内部，我可以告诉，询问推送行为

556
00:27:01,019 --> 00:27:05,055
动画师，请删除我。好吧，删除行为。

557
00:27:05,124 --> 00:27:08,592
推动行为本身。所以这很酷，对吧？

558
00:27:08,660 --> 00:27:13,029
它解决了这个问题。好吧，但在幻灯片上是红色的。

559
00:27:13,098 --> 00:27:17,434
这创建了一个内存循环。所以我们要谈谈

560
00:27:17,503 --> 00:27:20,737
关于这个创建的内存循环的一点点。和

561
00:27:20,806 --> 00:27:23,340
这里的底线是推动行为正在指向

562
00:27:23,408 --> 00:27:24,274
闭包。

563
00:27:24,342 --> 00:27:27,010
该闭包指向了推送行为。

564
00:27:27,079 --> 00:27:31,381
所以他们都有一个指向堆中的东西的指针。

565
00:27:31,450 --> 00:27:33,984
所以他们都被留在堆里。好，那是为了

566
00:27:34,053 --> 00:27:36,520
我告诉你我们如何解决这个记忆周期，

567
00:27:36,589 --> 00:27:38,489
我将不得不在这边搁置，然后回去

568
00:27:38,557 --> 00:27:40,224
教你多一点闭包。希望，

569
00:27:40,292 --> 00:27:42,359
你已经在你的家庭作业中阅读过这个。但

570
00:27:42,428 --> 00:27:46,429
开始了。你可以定义。当你关门时

571
00:27:46,498 --> 00:27:49,032
你可以定义一些局部变量。

572
00:27:49,101 --> 00:27:50,400
有趣的小局部变量。

573
00:27:50,468 --> 00:27:52,836
你在这些地方放一个方括号

574
00:27:52,905 --> 00:27:55,805
在你闭包之前，在那里有括号

575
00:27:55,874 --> 00:27:57,974
你可以定义你想要的任何变量。

576
00:27:58,043 --> 00:27:59,943
你可以设置他们有一些初始值。所以

577
00:28:00,012 --> 00:28:03,446
这里我有变量x和y。我可以在里面使用x和y

578
00:28:03,515 --> 00:28:06,616
我的闭包。然后我会在那里设置任何价值。

579
00:28:06,685 --> 00:28:09,286
它似乎不是很有用。

580
00:28:09,355 --> 00:28:11,488
当然，这并不是因为，

581
00:28:11,557 --> 00:28:13,223
我可以使用某个类的某个实例，或者

582
00:28:13,292 --> 00:28:15,125
我可以在我的闭包内打个招呼。

583
00:28:15,193 --> 00:28:17,827
为什么我需要在那里有那些愚蠢的小变数？

584
00:28:17,896 --> 00:28:20,497
那么他们不那么愚蠢的原因是因为他们可以

585
00:28:20,566 --> 00:28:26,170
宣布为弱。这些x和y是不同的变量。

586
00:28:26,238 --> 00:28:29,238
它们只是闭包的局部变量。和

587
00:28:29,307 --> 00:28:32,176
如果你要宣布其中一个weak，那么现在就变成了

588
00:28:32,244 --> 00:28:34,711
首先是可选的。因为我们知道所有的weak

589
00:28:34,780 --> 00:28:37,314
变量，他们不会把东西堆在一堆。和他们

590
00:28:37,383 --> 00:28:40,116
也必须weak，因为如果他们指向的东西

591
00:28:40,185 --> 00:28:42,986
从堆中出来，他们将被设置为零，对不对？

592
00:28:43,055 --> 00:28:45,622
所以我现在可以在里面使用x和y但是

593
00:28:45,691 --> 00:28:49,559
x现在是可选的并且很weak。好吧，你会明白为什么

594
00:28:49,628 --> 00:28:53,430
这很有价值。我甚至可以声明那些

595
00:28:53,499 --> 00:28:57,033
变量是无主的。如果你记得回到事情

596
00:28:57,102 --> 00:28:58,368
当我谈论内存管理时，

597
00:28:58,437 --> 00:29:00,370
无主意味着它不是参考计数。

598
00:29:00,439 --> 00:29:02,238
这就像斯威夫特说的那样，

599
00:29:02,307 --> 00:29:05,275
它在你身上。如果你要访问那个东西，那就更好了

600
00:29:05,344 --> 00:29:08,111
在堆中，因为如果不是，你就会崩溃。那是

601
00:29:08,180 --> 00:29:11,882
基本上是什么无主的手段。这意味着我可以使用x和

602
00:29:11,950 --> 00:29:14,484
在闭包内。这不是可选的，不

603
00:29:14,553 --> 00:29:17,620
必须担心这一点。但如果我在那里使用x和

604
00:29:17,689 --> 00:29:22,091
它不在堆中，它会崩溃我的应用程序。可以，然后呢

605
00:29:22,160 --> 00:29:25,361
为什么做weak和无主的人有价值？那是因为weak

606
00:29:25,430 --> 00:29:28,331
和无主的变量，无论他们是这些小本地人还是

607
00:29:28,400 --> 00:29:31,234
不，不要把其他东西放在堆中。

608
00:29:31,303 --> 00:29:36,006
他们不强。他们虚弱甚至无主。所以

609
00:29:36,074 --> 00:29:37,574
我们可以用它来打破这些记忆周期。

610
00:29:37,642 --> 00:29:39,810
所以这是发生内存循环的另一个例子

611
00:29:39,878 --> 00:29:43,413
每时每刻。这里有一个类，Zerg，这是所谓的。

612
00:29:43,481 --> 00:29:47,784
它有一个叫做foo的var，它的值是一个闭包。

613
00:29:47,852 --> 00:29:51,454
在那个闭包里面，我已经设置了它的值

614
00:29:51,523 --> 00:29:54,891
在Zerg中调用另一个函数的闭包，

615
00:29:54,960 --> 00:29:58,762
这是bar。这是一个记忆周期。这是一个记忆

616
00:29:58,830 --> 00:30:02,633
因为foo，封闭，正在压抑自我。

617
00:30:02,701 --> 00:30:05,301
自我是保持阶级Zerg的例子

618
00:30:05,370 --> 00:30:07,838
记忆中的Zerg类。当然，Zerg还在

619
00:30:07,906 --> 00:30:10,907
内存中的闭包因为它有一个指向它的变量。

620
00:30:10,976 --> 00:30:12,709
所以他们互相指着对方

621
00:30:12,777 --> 00:30:15,545
保持对方的记忆。所以这很糟糕。

622
00:30:15,613 --> 00:30:16,713
你有一个指向另一个，

623
00:30:16,782 --> 00:30:18,481
另一个指向另一个，所以

624
00:30:18,550 --> 00:30:21,217
我们如何打破这个循环？

625
00:30:21,286 --> 00:30:24,854
那么，我们会用这些小的局部变量hoo-has。

626
00:30:24,923 --> 00:30:26,990
所以我会创建一个局部变量。它很弱。

627
00:30:27,058 --> 00:30:30,360
我会把它称为weakSelf。我会说等于自我。

628
00:30:30,429 --> 00:30:34,131
然后里面，我会说weakself，问号，

629
00:30:34,199 --> 00:30:37,200
意思是可选的链接，.bar。所以

630
00:30:37,269 --> 00:30:41,004
现在这个闭包内没有任何东西，没有变量

631
00:30:41,072 --> 00:30:43,640
封闭是保持一个强烈的指向自我。

632
00:30:43,708 --> 00:30:46,276
所以它并没有保持在堆中。你同意吗？

633
00:30:46,345 --> 00:30:49,445
正确的，唯一的东西，甚至在闭包的内部使用

634
00:30:49,514 --> 00:30:52,616
自我弱，但我们知道这很弱。不能保留某些东西

635
00:30:52,684 --> 00:30:54,751
堆。现在，不幸的是，它是可选的，所以

636
00:30:54,820 --> 00:30:58,387
我必须有可选的连锁店，但我打破了这个循环。

637
00:30:58,456 --> 00:31:01,224
所以这就是我们如何使用弱小的本地来打破这些循环

638
00:31:01,292 --> 00:31:04,727
我们闭包的变量。顺便说一句，我们被允许

639
00:31:04,796 --> 00:31:08,031
称之为弱自我，自我。换句话说，它可以拥有

640
00:31:08,100 --> 00:31:11,902
与外部作用域中的变量完全相同的名称。

641
00:31:11,971 --> 00:31:14,170
所以在这张幻灯片上，有两个不同的自我。

642
00:31:14,239 --> 00:31:16,706
有黄色的自我。这是闭包中的局部。

643
00:31:16,775 --> 00:31:17,874
还有绿色的自我。

644
00:31:17,943 --> 00:31:22,078
这是这个课程实例中更全球化的自我。

645
00:31:22,147 --> 00:31:23,246
好的，所以这是两个不同的变量。但

646
00:31:23,315 --> 00:31:25,682
我根本没有在封口内使用绿色的自我。

647
00:31:25,750 --> 00:31:28,284
我只使用黄色的自我。而那个弱者。和

648
00:31:28,353 --> 00:31:31,154
事实上，这是非常普遍的，你甚至不必平等

649
00:31:31,222 --> 00:31:34,223
自。如果你说自己弱，它会自动设置它

650
00:31:34,292 --> 00:31:36,993
等于周围同名的变量

651
00:31:37,062 --> 00:31:41,698
码。好的，这就是我们如何打破这些循环。

652
00:31:41,766 --> 00:31:43,500
现在让我们回到UI推送行为和

653
00:31:43,568 --> 00:31:45,602
看看我们将如何使用无主。好，如此

654
00:31:45,670 --> 00:31:49,306
这是我的推送行为代码。如果我采取同样的事情，

655
00:31:49,374 --> 00:31:52,842
那个行动，并且只是说无主的推动行为，

656
00:31:52,911 --> 00:31:56,013
我打破了这个循环。因为现在pushBehavior是否定的

657
00:31:56,081 --> 00:31:58,648
更长时间由参考会计系统管理

658
00:31:58,717 --> 00:32:01,584
而且，pushBehavior更适合在这里堆放。

659
00:32:01,653 --> 00:32:04,620
好的，如果它在堆里面，我们会崩溃的。但

660
00:32:04,689 --> 00:32:07,123
当然，pushBehavior将会在那里堆起来。

661
00:32:07,192 --> 00:32:10,160
pushBehavior甚至不可能在这里执行。它的

662
00:32:10,228 --> 00:32:13,430
如果不在堆中，则无法执行该操作。所以

663
00:32:13,498 --> 00:32:16,266
我们保证pushBehavior将会在那里。

664
00:32:16,335 --> 00:32:19,970
所以这是一个经典的方式，我们可以打破无主之地

665
00:32:20,039 --> 00:32:22,605
周期。我们也可以在那里做一周

666
00:32:22,674 --> 00:32:25,408
也许检查，看看它是否为零。但这完全没有必要

667
00:32:25,477 --> 00:32:28,845
因为我们知道那永远不会是零。它永远不会

668
00:32:28,913 --> 00:32:35,051
不要在堆中。所以现在我要做一个演示。

669
00:32:35,119 --> 00:32:37,520
我们要拿上周我们玩的纸牌。

670
00:32:37,589 --> 00:32:39,122
而且我会制作很多扑克牌。

671
00:32:39,191 --> 00:32:40,190
我们会把它们运动起来，

672
00:32:40,258 --> 00:32:43,060
并让它们翻转过来，还有各种有趣的东西。

673
00:32:43,128 --> 00:32:44,928
星期五，我不会回到幻灯片。

674
00:32:44,997 --> 00:32:46,663
那么让我告诉你那个星期五，

675
00:32:46,732 --> 00:32:50,333
我们将有一个星期五部分。它在源代码控制上。

676
00:32:50,402 --> 00:32:51,434
所以千万不要错过那个，这是一个很好的例子。

677
00:32:51,503 --> 00:32:54,003
这是我们创建时总是不点击的东西

678
00:32:54,072 --> 00:32:56,973
新项目说，你想管理这个？连

679
00:32:57,041 --> 00:33:00,176
你的代码GitHub和所有的东西是其中的一部分。

680
00:33:00,245 --> 00:33:02,112
实际上，下周我会说这些，但实际上，

681
00:33:02,181 --> 00:33:04,013
我们一定会查看控制器生命周期。

682
00:33:04,082 --> 00:33:06,816
但我可能会在下周做多线程，

683
00:33:06,885 --> 00:33:08,285
这是一个重要的话题。

684
00:33:08,353 --> 00:33:10,753
然后也许一些其他的其他UI的东西，

685
00:33:10,822 --> 00:33:13,190
像滚动视图，文本框，类似的东西。

686
00:33:13,258 --> 00:33:15,325
可能做表视图和集合视图，并拖动和

687
00:33:15,394 --> 00:33:21,697
下降，甚至在那之后的一周。好吧，

688
00:33:21,766 --> 00:33:26,469
所以我告诉你我会告诉你作业动画的东西，

689
00:33:26,538 --> 00:33:31,608
所以让我这样做。我们去这里做吧，它在哪里？

690
00:33:31,676 --> 00:33:35,445
好吧，再说一遍，我只是简单地告诉你。但

691
00:33:35,514 --> 00:33:38,114
我只是想让你知道你会怎么做。

692
00:33:38,183 --> 00:33:41,384
你设置的应用程序，当它出现时，会自动

693
00:33:41,453 --> 00:33:43,620
发牌。你看我是如何处理这些卡片的？

694
00:33:43,689 --> 00:33:44,654
他们飞出去了

695
00:33:44,723 --> 00:33:46,989
他们在到达那里时也会翻动。

696
00:33:47,058 --> 00:33:52,362
当我处理新卡片时，您会发现，它的动画效果非常流畅

697
00:33:52,431 --> 00:33:55,998
小卡片，你看？然后发出新卡，所以

698
00:33:56,067 --> 00:33:59,035
你必须这样做。请注意，我只有钻石。

699
00:33:59,104 --> 00:34:00,737
这是因为我想更快地接近终点。

700
00:34:00,806 --> 00:34:01,938
这是调试的事情。

701
00:34:02,007 --> 00:34:05,775
此外，任何三张牌都在这里。所以我们这样做。

702
00:34:05,844 --> 00:34:07,677
现在看看你有什么结果？

703
00:34:07,746 --> 00:34:11,214
他们混乱不堪，他们只是飞到了那个地方。但

704
00:34:11,283 --> 00:34:13,983
然后他们最终在我的丢弃堆里收集过来。

705
00:34:14,052 --> 00:34:15,552
看，看，再看一遍。

706
00:34:15,621 --> 00:34:17,653
看到他们飞到这个地方？并注意，

707
00:34:17,722 --> 00:34:20,223
它也在处理新的卡片来取代它们。

708
00:34:20,292 --> 00:34:21,991
最终，我会在这里结束。

709
00:34:22,060 --> 00:34:23,193
将不会有任何新的卡。

710
00:34:23,261 --> 00:34:25,795
请注意，我的甲板很好地消失了。那不是

711
00:34:25,864 --> 00:34:28,531
一个必需的任务，但你可能想这样做。和

712
00:34:28,599 --> 00:34:32,501
那么，当然，随着我的人数越来越小，你还在

713
00:34:32,570 --> 00:34:37,540
做混沌动画。我们正在重新整理这些卡片

714
00:34:37,609 --> 00:34:40,243
他们走了。了解我们在做什么？

715
00:34:40,311 --> 00:34:42,511
所以你基本上在那里做三个动画。

716
00:34:42,580 --> 00:34:45,048
一个是你正在处理卡片并翻转它们。

717
00:34:45,116 --> 00:34:48,017
另一个是，当卡片匹配时，你正在爆炸它们。

718
00:34:48,086 --> 00:34:50,286
然后把它们放在丢弃堆中。和

719
00:34:50,355 --> 00:34:53,323
那么每当卡片数量发生变化时，你都很顺利

720
00:34:53,392 --> 00:34:57,360
动画到新号码。你不会跳他们。

721
00:34:57,429 --> 00:35:02,565
就是这样，没关系，就是这样。所以演示

722
00:35:02,634 --> 00:35:07,670
今天，这将有望帮助你，让我们去这里。

723
00:35:07,739 --> 00:35:10,539
好的，所以我们今天要做的演示，

724
00:35:10,608 --> 00:35:13,810
这将有助于你的作业，是拿我们的卡

725
00:35:13,879 --> 00:35:16,880
应用程序并将这些卡片运动起来。现在这很漂亮

726
00:35:16,949 --> 00:35:19,716
与我们上次使用的完全相同的卡片应用程序。

727
00:35:19,785 --> 00:35:21,784
除了差别是我们曾经有一张卡

728
00:35:21,853 --> 00:35:26,522
中间。在这种情况下，我创建了12张卡片。和

729
00:35:26,591 --> 00:35:30,360
我用我的viewDidLoad使它们成为随机卡。我

730
00:35:30,429 --> 00:35:33,997
只是随机通过，创建这些卡片，面朝上，

731
00:35:34,065 --> 00:35:37,267
把等级和套装放在他们身上制作随机卡片。

732
00:35:37,335 --> 00:35:38,635
所以让我们看看这看起来像什么。

733
00:35:46,011 --> 00:35:49,679
好的，我的随机卡。他们什么都不做。

734
00:35:49,747 --> 00:35:50,646
我没有任何手势。

735
00:35:50,715 --> 00:35:53,716
所以我不能点击它们或做任何事情。所以我第一件事

736
00:35:53,785 --> 00:35:56,619
想要做的就是添加一个轻敲手势，将其翻转过来。

737
00:35:56,687 --> 00:35:57,753
我们将开始这个应用程序和

738
00:35:57,822 --> 00:35:59,188
无动画地翻转它们。

739
00:35:59,257 --> 00:36:01,824
然后我们将添加动画让它们翻转，好吗？

740
00:36:01,893 --> 00:36:04,627
所以让我们来做。我也听说有些混乱

741
00:36:04,696 --> 00:36:06,863
办公时间关于手势。

742
00:36:06,931 --> 00:36:10,433
所以这将是审查手势的好机会

743
00:36:10,502 --> 00:36:13,002
再次。所以我要在这里做什么，首先，我会

744
00:36:13,071 --> 00:36:16,072
开始我的卡面朝下，而不是正面朝上。接着

745
00:36:16,141 --> 00:36:18,941
我只是要为他们添加一个手势识别器。

746
00:36:19,010 --> 00:36:21,444
补充一下，让我们把这个代码做大吧

747
00:36:21,513 --> 00:36:24,414
你真的可以看到这里发生了什么，对吧？

748
00:36:24,483 --> 00:36:29,052
所以我要添加GestureRecognizer，oops，

749
00:36:29,120 --> 00:36:32,822
必须将其添加到视图。所以我会添加我的

750
00:36:32,891 --> 00:36:37,994
cardView.addGestureRecognizer，你好。怎么回事，我们走了。

751
00:36:38,063 --> 00:36:40,630
所以我添加了一个手势识别器。手势

752
00:36:40,698 --> 00:36:44,767
识别器我要添加的是UITapGestureRecognizer。和

753
00:36:44,836 --> 00:36:48,104
然后只是回顾一下手势的理由

754
00:36:48,173 --> 00:36:50,072
识别器，就是目标。

755
00:36:50,141 --> 00:36:54,544
这是将要发送此操作的对象

756
00:36:54,612 --> 00:37:00,616
方法发生时。所以我会有的

757
00:37:00,685 --> 00:37:04,019
这是我的目标，视图控制器。但

758
00:37:04,088 --> 00:37:07,690
这可能是一种视图，我也可以把它发送到这个视图。

759
00:37:07,759 --> 00:37:10,926
而这个选择器只是＃selector。

760
00:37:10,995 --> 00:37:15,365
然后在这里，你把方法的名字。

761
00:37:15,434 --> 00:37:19,202
但只有参数的外部名称。

762
00:37:19,271 --> 00:37:22,439
所以，例如，我会做flipCard。而且它只是

763
00:37:22,507 --> 00:37:24,874
会有一个参数，这是轻拍手势。

764
00:37:24,943 --> 00:37:27,043
我会让它没有外部名称，所以

765
00:37:27,112 --> 00:37:31,514
我会去做的。所以这是方法的名称

766
00:37:31,583 --> 00:37:33,650
所有的外部名字和冒号，但是

767
00:37:33,718 --> 00:37:39,522
没有其他的。就这样，每个人都很酷吗？现在，

768
00:37:41,626 --> 00:37:44,326
这只是抱怨因为我没有定义flipCard。

769
00:37:44,395 --> 00:37:47,330
所以现在当我创建flipCard的时候，当然它必须是objc。

770
00:37:47,398 --> 00:37:50,499
好吧，所有这些做这个事情都必须做的事情

771
00:37:50,568 --> 00:37:54,570
是objc。叫它flipCard，没有外部名字。

772
00:37:54,639 --> 00:37:58,842
这将是识别器UITapGestureRecognizer。

773
00:38:02,113 --> 00:38:06,115
识别器，有时它会让我输入所有内容。

774
00:38:06,184 --> 00:38:10,085
看看这里是否摆脱了我们的警告。

775
00:38:10,154 --> 00:38:14,958
好的，这里说什么？我们是什么，objc func，

776
00:38:15,026 --> 00:38:20,062
那个怎么样？它正在这里重建。好的，

777
00:38:20,131 --> 00:38:25,501
好，这是固定的，我们在这里？

778
00:38:25,570 --> 00:38:29,238
我在这里忘记了什么吗？好的，

779
00:38:29,307 --> 00:38:33,342
代码有点慢，跟不上我今天的打字。好的，

780
00:38:33,411 --> 00:38:37,713
所以现在我有这个识别器。现在我想找到

781
00:38:37,782 --> 00:38:41,217
点击哪张卡片，然后翻转。

782
00:38:41,285 --> 00:38:44,154
这是我认为人们喜欢的东西，

783
00:38:44,222 --> 00:38:46,656
我怎么做？当然，这里的答案是，

784
00:38:46,725 --> 00:38:50,326
我要打开Recognizer.state。我们差不多

785
00:38:50,395 --> 00:38:52,962
始终打开状态。这是我们做的第一件事。

786
00:38:53,031 --> 00:38:55,899
这是一个轻拍手势，所以我只关心结束状态。

787
00:38:55,967 --> 00:38:58,968
所有其他州，我只是会打破，对吧？

788
00:38:59,036 --> 00:39:02,572
但是如果我得到一个水龙头，我想要做的是拿到卡

789
00:39:02,640 --> 00:39:04,640
这是挖掘。但我在我的视图控制器中。

790
00:39:04,709 --> 00:39:07,310
现在通常情况下，我可能会把目标视为如此

791
00:39:07,379 --> 00:39:10,113
它会知道它本身就是被挖掘的。

792
00:39:10,182 --> 00:39:11,480
但在这里，我在视图控制器中，所以

793
00:39:11,549 --> 00:39:13,349
我必须找到它。事实证明，

794
00:39:13,418 --> 00:39:17,019
TapGestureRecognizer，它知道它被点击了什么视图。

795
00:39:17,088 --> 00:39:19,922
记住我如何说每一个具体的手势

796
00:39:19,991 --> 00:39:21,791
有关于发生了什么的信息？好，

797
00:39:21,860 --> 00:39:24,060
其中一件事是他们知道他们被挖掘的东西或

798
00:39:24,129 --> 00:39:27,997
随你。所以我可以说，例如，

799
00:39:28,065 --> 00:39:34,203
如果让selectedCardView =识别器的视图。

800
00:39:34,272 --> 00:39:36,272
所以视图是TapGestureRecognizer中的一个变种，

801
00:39:36,340 --> 00:39:38,708
这是被发现的视图。这可能是

802
00:39:38,776 --> 00:39:42,311
你们中的一些人没有从文档中获得。如

803
00:39:42,380 --> 00:39:47,049
一个PlayingCardView。现在为什么我需要它作为PlayingCardView？

804
00:39:47,118 --> 00:39:49,185
因为这当然只是一个UI视图。

805
00:39:49,254 --> 00:39:51,220
TapGestureRecognizer不知道任何关于

806
00:39:51,289 --> 00:39:53,756
PlayingCardView。所以我必须确保它，事实上，

807
00:39:53,825 --> 00:39:55,825
一个PlayingCardView。应该是因为这是唯一的

808
00:39:55,893 --> 00:39:58,595
我添加了任何这些轻拍手势。然后我

809
00:39:58,663 --> 00:40:03,732
可以在这里选择CardView，并且它是FaceUp。

810
00:40:03,801 --> 00:40:09,605
=不是所选卡片视图是FaceUp。所以我只是在翻动

811
00:40:09,674 --> 00:40:14,209
卡在这里，对不对？大家都明白吗？

812
00:40:14,278 --> 00:40:16,746
好的，让我们继续并运行，看看它是否有效。

813
00:40:21,953 --> 00:40:23,620
好吧，所以他们都面朝下，这很好。

814
00:40:23,688 --> 00:40:25,955
看到我在这里改变了他们都是错误的。所以让我们点击，

815
00:40:26,023 --> 00:40:29,826
好吧。翻转它，很好地工作，好吧。

816
00:40:29,895 --> 00:40:33,896
但我们当然希望这是动画。和

817
00:40:33,964 --> 00:40:37,166
我们知道使用该UI视图很容易

818
00:40:37,235 --> 00:40:42,071
转变视图。那么我们如何做到这一点，

819
00:40:42,140 --> 00:40:44,707
我们该如何开始呢？让我们直接走到这里

820
00:40:44,776 --> 00:40:48,644
围绕这一点，并把它放在一个闭包的地方

821
00:40:48,713 --> 00:40:52,482
一个UIview过渡，所以UIView.trasition。

822
00:40:52,550 --> 00:40:53,282
顺便小心，

823
00:40:53,350 --> 00:40:56,519
他们是两个不同的UIView转换。有

824
00:40:56,588 --> 00:40:59,522
就在这里，这是我们想要的，从那里来的。

825
00:40:59,590 --> 00:41:02,491
从到是当你从一个视图转换到

826
00:41:02,560 --> 00:41:05,194
一个完全不同的视图。你将要删除一个

827
00:41:05,263 --> 00:41:07,596
从superview中添加另一个作为子视图。所以

828
00:41:07,665 --> 00:41:08,831
这是一个类似的事情，但是

829
00:41:08,900 --> 00:41:11,267
它就像卡片背面的一个视图一样

830
00:41:11,336 --> 00:41:13,436
卡的正面是一个不同的看法。但

831
00:41:13,504 --> 00:41:15,070
我们在这里以相同的视图过渡，

832
00:41:15,139 --> 00:41:16,872
因为我们可以把它变成正面和

833
00:41:16,941 --> 00:41:20,042
面朝下。在这里，我会继续前进，并将其展开

834
00:41:20,111 --> 00:41:23,446
你可以更清楚地看到这些参数，对。

835
00:41:23,514 --> 00:41:26,382
好吧，参数，似乎有很多

836
00:41:26,450 --> 00:41:29,251
这里的参数，但它们都很简单。

837
00:41:29,320 --> 00:41:32,555
所以我们翻看的视图当然是选择的CardView，

838
00:41:32,624 --> 00:41:37,159
好吧？持续时间，我发现像一个半秒，

839
00:41:37,228 --> 00:41:40,530
或许十分之六秒是一个很好的时间

840
00:41:40,598 --> 00:41:43,399
让它翻转。任何更慢，它感觉很亲切

841
00:41:43,468 --> 00:41:46,001
冰川。任何更快，它就像，发生了什么？

842
00:41:46,070 --> 00:41:47,270
它有点闪烁在你身上，

843
00:41:47,338 --> 00:41:49,838
所以你知道。选项，这里是我们必须说的地方

844
00:41:49,907 --> 00:41:51,941
想要翻转而不是交叉解散或任何东西。

845
00:41:52,009 --> 00:41:55,578
所以我会做转换，翻转，让我们翻转

846
00:41:55,647 --> 00:41:58,914
左边。所以我们要从左侧翻转。这里的

847
00:41:58,983 --> 00:42:01,717
动画的闭包，好的，这是我们要去的地方

848
00:42:01,786 --> 00:42:04,053
做任何事情的原因是看起来完全不同。

849
00:42:04,122 --> 00:42:07,523
所以，在我们的情况下，这是这里的代码，

850
00:42:07,592 --> 00:42:10,626
把它放在这里。在那边不需要那种方式。

851
00:42:10,695 --> 00:42:11,961
但是，然后完成，为

852
00:42:12,029 --> 00:42:14,296
现在我们在完成任务时不会做任何事情。

853
00:42:14,365 --> 00:42:16,933
所以我要完全采取完成的事情

854
00:42:17,001 --> 00:42:20,202
离开那里。我们将把它放在这里，

855
00:42:20,271 --> 00:42:24,974
哎呀，按Ctrl +我只是为了让事情有点整洁。

856
00:42:25,042 --> 00:42:28,177
好的，每个人都明白了吗？所以这是我们的过渡。

857
00:42:28,245 --> 00:42:31,280
有了这个视图，从左侧翻转，我们只是要翻转

858
00:42:31,349 --> 00:42:41,223
卡过来了。试一试吧。好的，我们走吧。呜，

859
00:42:41,292 --> 00:42:44,159
看，看，看看，它是如何有点阴影。

860
00:42:44,228 --> 00:42:47,729
阴影，那种赋予它3D效果的灰色。

861
00:42:47,798 --> 00:42:52,134
它感觉更像是3D翻转。它翻转过来。

862
00:42:52,203 --> 00:42:56,139
好吧，这很容易。这就是过渡动画，

863
00:42:56,207 --> 00:43:01,811
完全无关紧要。让我们不打算让我们的

864
00:43:01,879 --> 00:43:04,613
应用程序进入集中应用程序。

865
00:43:04,682 --> 00:43:07,283
我们在这里做一些UI研究，但是

866
00:43:07,352 --> 00:43:10,119
如果我们想这样做就像集中注意力那么呢？

867
00:43:10,187 --> 00:43:12,855
我们在哪里试图找到两张匹配的卡片？好的，但是

868
00:43:12,923 --> 00:43:14,357
我们会让我们更加努力一点。

869
00:43:14,425 --> 00:43:16,492
我们要做到这一点，当你翻过一张卡时，

870
00:43:16,560 --> 00:43:19,162
所以这张卡翻了出来。如果我翻转另一张牌，

871
00:43:19,230 --> 00:43:21,130
如果它们不匹配，它会这样下去，

872
00:43:21,199 --> 00:43:23,632
翻转，然后立即将它们翻转下来。

873
00:43:23,701 --> 00:43:25,901
嗯，所以你真的要专心。好的，

874
00:43:25,970 --> 00:43:28,504
这真的是集中，因为他们去剪辑，和

875
00:43:28,573 --> 00:43:31,006
然后翻转，不匹配。你看？

876
00:43:31,075 --> 00:43:33,242
所以我们必须真正看到我们在这里做什么。

877
00:43:33,310 --> 00:43:35,744
所以让我们添加那个动画，这只会让卡片变形。

878
00:43:35,813 --> 00:43:38,046
任何时候有两张卡片，我们都会把它们关掉。

879
00:43:38,115 --> 00:43:41,650
所以要做到这一点，我需要一个小的私人变量，告诉我什么

880
00:43:41,719 --> 00:43:45,287
我的faceUpCardViews是。这将是一个数组

881
00:43:45,356 --> 00:43:50,760
PlayingCardViews在这里。我将要计算它。

882
00:43:50,829 --> 00:43:55,931
我们知道如何使用过滤器和所有的东西，所以

883
00:43:56,000 --> 00:44:01,103
我打算让我的牌面成为我的cardViews，

884
00:44:01,172 --> 00:44:04,339
返回我的cardVews过滤和

885
00:44:04,408 --> 00:44:10,445
过滤器是他们正面朝上，对吧？我们也是

886
00:44:10,514 --> 00:44:13,716
确保它们不被隐藏。因为我会成为的

887
00:44:13,785 --> 00:44:16,485
稍后已经匹配的隐藏卡片。

888
00:44:16,554 --> 00:44:20,623
所以我不会忘记我们会让它隐藏起来。

889
00:44:22,526 --> 00:44:26,061
所以现在我们能够找出我们的牌面是什么。

890
00:44:26,130 --> 00:44:30,566
所以现在我要做的是在翻转完成之后，

891
00:44:30,635 --> 00:44:33,269
我要添加一个完成处理程序。

892
00:44:33,338 --> 00:44:35,904
好的，完成，我以前没有，

893
00:44:35,973 --> 00:44:41,377
我正在添加它。这一个已经完成了。它没有

894
00:44:41,445 --> 00:44:45,414
位置，结束，开始，当前。它刚刚结束，

895
00:44:45,483 --> 00:44:48,751
是或否，这个翻转是否完成。因为，它没有

896
00:44:48,820 --> 00:44:51,187
真正有意义的移动你的翻转来回。

897
00:44:51,255 --> 00:44:54,123
这种事情要么发生，要么没有。所以在这里，

898
00:44:54,192 --> 00:44:57,326
我会做另一次过渡。可以，然后呢

899
00:44:57,395 --> 00:45:00,196
其实我只是复制并粘贴为什么不。复制，粘贴和

900
00:45:00,264 --> 00:45:03,766
完成动画完美无缺

901
00:45:03,835 --> 00:45:08,003
其他动画的处理程序。这很好。

902
00:45:08,072 --> 00:45:08,871
那么我要在这里做什么？

903
00:45:08,940 --> 00:45:11,674
在这里，我要翻下所有的牌面

904
00:45:11,742 --> 00:45:14,543
如果有两个。所以让我们继续检查，

905
00:45:14,612 --> 00:45:17,413
如果我的faceUpCardViews.count == 2，那么

906
00:45:17,482 --> 00:45:21,217
我有2张面朝上的牌。然后，我要把他们都翻脸

907
00:45:21,285 --> 00:45:25,154
下来使用另一个过渡。所以让我给你看一个很酷的

908
00:45:25,222 --> 00:45:29,325
如果你有一个数组，则可以采用循环方式。看这个，和

909
00:45:29,393 --> 00:45:32,094
看到这里，它在说什么？我们停下来看看这个。

910
00:45:32,163 --> 00:45:35,497
我在这里得到一个错误，它说闭包中的引用属性

911
00:45:35,566 --> 00:45:40,736
需要明确的自我明确捕捉语义。

912
00:45:40,804 --> 00:45:42,405
好的，这真棒。

913
00:45:42,474 --> 00:45:45,074
斯威夫特如果说，在这里等一下蕾，

914
00:45:45,143 --> 00:45:47,776
你正在访问自己的bar，

915
00:45:47,845 --> 00:45:51,013
这就会抓住你自己。和

916
00:45:51,082 --> 00:45:54,050
我想让你打字，自己，就在那里

917
00:45:54,118 --> 00:45:57,319
你意识到你可能在这里有一个循环，

918
00:45:57,388 --> 00:46:00,923
一个记忆周期。所以，斯威夫特并没有让我们做到这一点。

919
00:46:00,992 --> 00:46:02,457
我真的很感谢Swift这么做。

920
00:46:02,526 --> 00:46:04,493
否则，它可能很容易忘记。

921
00:46:04,562 --> 00:46:08,030
哎呀，这是自我，然后意识到，我有一个记忆周期。

922
00:46:08,099 --> 00:46:10,499
但是我们在这里确实有一个记忆周期吗？没有，

923
00:46:10,568 --> 00:46:15,004
我们不这样做，因为这个闭包并没有捕获自己。

924
00:46:15,073 --> 00:46:19,241
自我并不以任何方式指向这一闭包。

925
00:46:19,310 --> 00:46:21,910
它不是任何变种的一部分。这不是字典的任何部分

926
00:46:21,979 --> 00:46:24,080
或者一个数组或任何自己拥有的数组。

927
00:46:24,148 --> 00:46:26,882
这是我们发布给动画系统的闭包。

928
00:46:26,951 --> 00:46:29,218
所以只有动画系统有一个指向它的指针。所以

929
00:46:29,286 --> 00:46:32,521
这里没有周期。所以我们没有理由去做

930
00:46:32,589 --> 00:46:35,791
这些奇怪的局部变量都很weak或者很weak

931
00:46:35,860 --> 00:46:39,161
任何一点。好吧，如果我有两张面牌，

932
00:46:39,229 --> 00:46:41,697
我要为所有的面卡做一个循环，但是

933
00:46:41,766 --> 00:46:43,232
我打算这样做。

934
00:46:43,300 --> 00:46:48,804
看这个，面对卡片，forEach，做一个闭包。所以我

935
00:46:48,873 --> 00:46:52,641
对这些面朝上的牌中的每一张执行闭包。

936
00:46:52,710 --> 00:46:54,843
所以，这对于循环来说是一种很酷的方式，而且

937
00:46:54,912 --> 00:46:58,414
在那里我会把这个放在这里。当然还有

938
00:46:58,483 --> 00:47:03,618
每个$ 0是每个东西在这个，所以我会去的

939
00:47:03,687 --> 00:47:07,623
用这里的每张卡做翻转过渡。

940
00:47:07,692 --> 00:47:12,127
同样的事情是一样的。这是$ 0是面朝上和

941
00:47:12,196 --> 00:47:18,434
它没有被翻转，这是错误的。我们希望他们面朝下。

942
00:47:18,502 --> 00:47:23,672
你明白了吗？合理？我们到了什么地方？

943
00:47:23,741 --> 00:47:28,444
我们也在这里摆脱这个权利。和

944
00:47:28,513 --> 00:47:33,883
这里发生了什么事？ $ 0正面朝上。

945
00:47:37,654 --> 00:47:42,991
好的，有人看到我在那里做错了吗？看我的

946
00:47:43,060 --> 00:47:47,496
卡在这里，cardView，也许我需要做这个，cardView in。

947
00:47:49,834 --> 00:47:54,803
糟糕，cardView或其他东西

948
00:47:54,872 --> 00:47:59,675
像那样。这解决了它，是的，这很有趣。

949
00:47:59,743 --> 00:48:01,877
所以$ 0，我无法在那里打字。

950
00:48:01,946 --> 00:48:05,747
我不知道为什么它不能推断出这里，如果

951
00:48:05,816 --> 00:48:09,485
我们有两张牌正面朝上，我们将他们两张面朝下翻转。

952
00:48:09,553 --> 00:48:19,361
让我们看看是否有效。好吧，一张牌正面朝上。

953
00:48:19,430 --> 00:48:21,597
顺便说一下，我们实际上可以将此卡背面朝下。

954
00:48:21,665 --> 00:48:25,734
面对，这里我们走，第二张牌。好吧，

955
00:48:25,803 --> 00:48:31,240
我们很好。优秀。现在会发生什么，如果两个

956
00:48:31,308 --> 00:48:34,110
这些牌相匹配吗？这两张牌，他们匹配，

957
00:48:34,178 --> 00:48:35,944
所以它不应该这样做，它不应该拒绝。

958
00:48:36,013 --> 00:48:39,381
它需要给我们一些说呜呼你的动画

959
00:48:39,450 --> 00:48:42,217
匹配两张牌。好吧，让我们来想一想，

960
00:48:42,286 --> 00:48:45,321
一个动画来做到这一点。所以我要做的动画

961
00:48:45,389 --> 00:48:48,524
当卡牌匹配时，我会让卡牌真的很大

962
00:48:48,593 --> 00:48:50,626
强调你有一场比赛，

963
00:48:50,695 --> 00:48:52,227
那么我会让它们变得非常小巧

964
00:48:52,296 --> 00:48:55,164
让它们渐渐消失，消失。

965
00:48:55,233 --> 00:48:58,033
因为当纸牌匹配时，我当然想把它们带走。

966
00:48:58,102 --> 00:48:59,034
所以这就是我们要做的。

967
00:48:59,103 --> 00:49:00,335
现在这是一个两步动画。

968
00:49:00,404 --> 00:49:01,603
第一步是让他们变得更大，并且

969
00:49:01,672 --> 00:49:04,206
那么第二步就是向下动画。和

970
00:49:04,275 --> 00:49:07,142
我们可以使用UIView Property Animator来做到这一点，当然，

971
00:49:07,211 --> 00:49:09,712
由于视图的大小和透明度

972
00:49:09,780 --> 00:49:12,881
是可动态的属性。并让它像两步

973
00:49:12,950 --> 00:49:14,784
那我们将使用完成的东西，

974
00:49:14,852 --> 00:49:16,685
类似于我们如何做到这一点，对。

975
00:49:16,753 --> 00:49:19,255
我们等到第一个完成，然后我们去了

976
00:49:19,323 --> 00:49:22,057
做另一个。好，那我们该怎么做？

977
00:49:22,126 --> 00:49:25,561
那么，我实际上需要另一个私有变量。那是

978
00:49:25,629 --> 00:49:28,497
只是要告诉我，面朝上的牌是否匹配。

979
00:49:28,565 --> 00:49:31,633
所以我会调用给那个faceUpCardViewsMatch，

980
00:49:31,702 --> 00:49:37,773
我想我是这么称呼的。这就是我所说的吗？是，

981
00:49:37,842 --> 00:49:41,777
faceUpCardViewsMatch。这是个傻瓜，我们走了

982
00:49:41,846 --> 00:49:43,912
为了计算这一点，我只想回来，

983
00:49:43,981 --> 00:49:49,518
如果我们的faceupcardviews.count = 2，

984
00:49:49,587 --> 00:49:54,423
和哎呀。这种做法在飞行中。和

985
00:49:54,492 --> 00:50:00,463
面对，我错过了一个A，faceUpCardViews

986
00:50:00,531 --> 00:50:04,933
[0] = .rank面朝上，

987
00:50:05,002 --> 00:50:06,868
你可以看到我们在这里没有模型

988
00:50:06,937 --> 00:50:10,339
我们直接看这些东西。再次，

989
00:50:10,408 --> 00:50:12,975
如果你前进，这不是你如何做到这一点

990
00:50:13,043 --> 00:50:15,777
把它变成一个集中游戏。你会

991
00:50:15,846 --> 00:50:19,047
有一个模型和所有这一切。我真的只是像我说的那样做，

992
00:50:19,116 --> 00:50:24,686
一种UI案例研究仅供参考

993
00:50:24,755 --> 00:50:27,656
它会是什么样子，然后我会回去

994
00:50:27,725 --> 00:50:33,228
做我的实际模型或其他。所以这是

995
00:50:33,297 --> 00:50:36,765
只是告诉我们两张面朝上的牌是否匹配。

996
00:50:36,834 --> 00:50:40,403
所以在我完成第一张卡片翻转之后，

997
00:50:40,471 --> 00:50:45,740
我会说，如果我的自我，当然，面对

998
00:50:45,809 --> 00:50:50,679
卡片观看比赛。然后，在这里我要去做动画。

999
00:50:50,748 --> 00:50:53,281
否则，我会继续检查，看看我们

1000
00:50:53,350 --> 00:50:55,884
有两张不匹配的面牌。然后我们会做这个翻转

1001
00:50:55,953 --> 00:50:57,852
下来的东西。但在这里我们不打算把它们翻倒。

1002
00:50:57,921 --> 00:50:59,387
我们会让他们变大，然后让他们变小。

1003
00:50:59,456 --> 00:51:01,957
所以我们要使用我们的视图视图属性

1004
00:51:02,026 --> 00:51:04,993
动画师在这里，做起来很简单。我们只是会说

1005
00:51:05,062 --> 00:51:10,866
UIViewPropertyAnimator.runnin-gPropertyAnimator。

1006
00:51:10,934 --> 00:51:15,137
再次，我会尽量让这一点更容易看到

1007
00:51:15,205 --> 00:51:20,709
按照自己的方式获得每个参数。好的。

1008
00:51:20,778 --> 00:51:21,877
所以这里是参数。

1009
00:51:21,946 --> 00:51:24,179
属性，动画师也非常简单。

1010
00:51:24,248 --> 00:51:25,814
参数，似乎有很多，并且

1011
00:51:25,882 --> 00:51:28,250
他们非常复杂，但他们确实不是。好的。

1012
00:51:28,319 --> 00:51:29,918
所以在这里我们要把这个事情做大。

1013
00:51:29,987 --> 00:51:31,953
那么我想花多长时间来赚大钱？

1014
00:51:32,022 --> 00:51:36,725
再次不是真的超过一秒钟。也许.6或.7。这些

1015
00:51:36,794 --> 00:51:40,462
是蓝色的数字，我会把它放在一个常量struct中

1016
00:51:40,531 --> 00:51:42,798
然后玩，让我的动画看起来像我

1017
00:51:42,867 --> 00:51:45,400
想。我不会推迟这个动画，

1018
00:51:45,469 --> 00:51:47,235
会马上开始。

1019
00:51:47,304 --> 00:51:52,541
这里真的没有必要的动画选项。只要去

1020
00:51:52,610 --> 00:51:55,577
做动画。所以在这里是闭包和

1021
00:51:55,646 --> 00:51:59,882
只有这里我可以改变的是那些视图属性。

1022
00:51:59,950 --> 00:52:02,718
好的，如果我改变了其他的东西，它会做的，但是

1023
00:52:02,786 --> 00:52:05,721
它不会以任何方式影响动画。所以

1024
00:52:05,789 --> 00:52:07,522
我们想在这里做什么动画？

1025
00:52:07,591 --> 00:52:10,492
那么我们希望所有面朝上的牌都变得非常大。

1026
00:52:10,560 --> 00:52:14,263
我会用这个转换来做到这一点。变换是真的

1027
00:52:14,332 --> 00:52:16,865
容易让事情变大或旋转它们或其他任何东西

1028
00:52:16,934 --> 00:52:23,038
我只想说，我再次面对每张牌的看法，

1029
00:52:23,106 --> 00:52:28,711
对于每一个，哎呀。而在这个'每个'我只是要去

1030
00:52:28,779 --> 00:52:31,346
改变我想改变的属性

1031
00:52:31,415 --> 00:52:36,385
$ 0.transform =，我会得到仿制品

1032
00:52:36,453 --> 00:52:39,688
转换不旋转的身份。和

1033
00:52:39,757 --> 00:52:43,492
我会用三倍的比例来衡量它。所以

1034
00:52:43,560 --> 00:52:48,196
这会使这个视图成为其正常尺寸的三倍。

1035
00:52:48,265 --> 00:52:52,501
现在我们只做这个部分。

1036
00:52:52,569 --> 00:52:56,772
我们将在这里稍微完成一部分。

1037
00:52:58,442 --> 00:53:00,442
所以我只是想确保这个工作。所以这是

1038
00:53:00,511 --> 00:53:04,246
会迫使我们找到一场比赛，看看它是否有效，

1039
00:53:04,314 --> 00:53:10,152
但我相信我们可以做到这一点。好的，

1040
00:53:10,221 --> 00:53:13,122
开始了。我需要一场比赛。

1041
00:53:13,190 --> 00:53:17,726
不，4和9.不，不同的4，不好。有一个9。

1042
00:53:17,794 --> 00:53:20,995
好吧，我要点击这张卡。他们会匹配。

1043
00:53:21,064 --> 00:53:22,831
希望他们会变得非常大。然后他们是

1044
00:53:22,900 --> 00:53:24,833
会因为我们没有完成这个动画而停下来。

1045
00:53:24,901 --> 00:53:30,439
但让我们看看。呃，好吧，它的工作很简单。

1046
00:53:30,508 --> 00:53:32,607
现在我们需要下一步我们想要制作的动画

1047
00:53:32,676 --> 00:53:34,710
它很小，我们将要做它的阿尔法

1048
00:53:34,778 --> 00:53:37,479
变小，同时消失。可以，然后呢，

1049
00:53:37,548 --> 00:53:40,782
我们将用这个完成的事情来做到这一点

1050
00:53:40,851 --> 00:53:45,320
我评论说，把它放回去，并扩大这个东西。

1051
00:53:45,389 --> 00:53:47,690
记住这个位置没有完成，

1052
00:53:47,758 --> 00:53:51,059
但是是点结束，点开始还是位置的位置

1053
00:53:51,128 --> 00:53:54,663
.current。我们并不在乎

1054
00:53:54,731 --> 00:53:57,532
这是因为我们没有动画

1055
00:53:57,601 --> 00:53:59,635
那会在这里相互跳跃。

1056
00:53:59,703 --> 00:54:01,103
所以这不会是一个问题。所以

1057
00:54:01,171 --> 00:54:03,372
这里我们想要做另一个属性动画。

1058
00:54:03,440 --> 00:54:06,474
所以我要在这里复制并粘贴这个东西，

1059
00:54:06,543 --> 00:54:09,445
把它放在这里。好的。我们用这个做什么？

1060
00:54:09,513 --> 00:54:11,846
属性动画？与另一个非常相似。

1061
00:54:11,915 --> 00:54:14,249
但是，而不是转换到3.0，

1062
00:54:14,318 --> 00:54:18,721
我会让它变得非常小。降至0.1。和

1063
00:54:18,789 --> 00:54:25,394
同时我会说alpha等于零。

1064
00:54:25,462 --> 00:54:29,398
完全透明。现在，请记住这是事实

1065
00:54:29,467 --> 00:54:31,166
立即发生。它将把它设置为零，但是

1066
00:54:31,235 --> 00:54:33,802
用户会在.6的过程中看到它。和

1067
00:54:33,870 --> 00:54:36,572
实际上，这个人可能想要更长一些，也许.75或者

1068
00:54:36,640 --> 00:54:40,342
因为记得我从身份变换去了

1069
00:54:40,411 --> 00:54:44,646
到3.0现在我要从3.0通过识别到0.1。

1070
00:54:44,715 --> 00:54:46,681
所以也许我想多给点时间，

1071
00:54:46,750 --> 00:54:48,650
你看我在说什么？去那个额外的距离，如此

1072
00:54:48,719 --> 00:54:51,319
它感觉就像是在大约同一时间出现。

1073
00:54:51,388 --> 00:54:53,989
但是，再次，这些是你随着时间的推移而调整的数字

1074
00:54:54,058 --> 00:54:56,925
因为你在做东西。好，如此

1075
00:54:56,994 --> 00:54:59,060
再次，让我们看看这是否正常。

1076
00:54:59,129 --> 00:55:01,130
我有我们在那里完成的事情

1077
00:55:07,638 --> 00:55:10,372
好的，我们必须再次找到其他比赛。三，

1078
00:55:10,440 --> 00:55:15,043
然后是八，一个王牌。不，那是俱乐部和俱乐部的王牌

1079
00:55:15,112 --> 00:55:17,879
黑桃王牌，看？有俱乐部的王牌。

1080
00:55:17,948 --> 00:55:20,782
这是俱乐部的王牌吗？不，黑桃王牌。俱乐部的王牌。

1081
00:55:20,851 --> 00:55:21,683
好的，准备好了，我们走吧。

1082
00:55:21,752 --> 00:55:24,052
我要点击这个，现在它应该上去了

1083
00:55:24,121 --> 00:55:26,722
然后下降并淡出到alpha零。让我们来看看。

1084
00:55:26,791 --> 00:55:31,693
完美，好吧。它工作得很好。现在，

1085
00:55:31,761 --> 00:55:35,731
一旦这样下去，我们要删除这张卡片，

1086
00:55:35,799 --> 00:55:37,932
因为它不再可以参与比赛。所以

1087
00:55:38,001 --> 00:55:41,136
我们将在这里实现我们的完成处理程序。

1088
00:55:41,204 --> 00:55:42,170
在完成处理程序中，

1089
00:55:42,238 --> 00:55:43,972
我们不会做任何视图属性动画，

1090
00:55:44,041 --> 00:55:45,173
我们只是要做清理。

1091
00:55:45,242 --> 00:55:49,211
例如，我要在这里说所有这些卡片，所以

1092
00:55:49,279 --> 00:55:54,182
我将再次有这个for循环。但不是这样。对于

1093
00:55:54,251 --> 00:55:57,252
所有这些卡片，我想将它们设置为isHidden，

1094
00:55:57,320 --> 00:56:00,789
所以我会隐藏这些卡片。现在，我也要清理

1095
00:56:00,858 --> 00:56:02,591
一点点。因为我真的不喜欢

1096
00:56:02,660 --> 00:56:05,594
这些视图非常小

1097
00:56:05,663 --> 00:56:09,698
变换。好的，透明的，坐在里面

1098
00:56:09,766 --> 00:56:11,866
即使他们隐藏，我的视图层次结构。所以

1099
00:56:11,935 --> 00:56:15,537
我将继续并使α回到1。

1100
00:56:15,606 --> 00:56:18,106
我要继续并进行变革，

1101
00:56:18,175 --> 00:56:20,875
回到身份转换。所以

1102
00:56:20,944 --> 00:56:24,813
它只是一点清理，我只是不喜欢有凌乱，

1103
00:56:26,283 --> 00:56:27,983
奇怪的国家观点躺在周围。

1104
00:56:28,052 --> 00:56:29,417
它们虽然隐藏起来，所以它不会

1105
00:56:29,486 --> 00:56:32,554
伤害任何东西让他们在那里。但是，对我而言，

1106
00:56:32,623 --> 00:56:34,356
这只是一个清洁的事情，有点清理

1107
00:56:34,424 --> 00:56:35,724
在你的动画之后一点点。

1108
00:56:35,792 --> 00:56:38,259
而且因为它隐藏起来，所有这些都不会显示出来。

1109
00:56:38,328 --> 00:56:40,161
我再次让它变得透明的事实

1110
00:56:40,230 --> 00:56:41,963
改变它的转变，没关系。

1111
00:56:42,032 --> 00:56:46,902
因为这个观点现在被隐藏起来了。可以，然后呢

1112
00:56:46,970 --> 00:56:50,505
这很好，我们得到了。接下来我们需要什么

1113
00:56:50,574 --> 00:56:53,875
要做什么，我们想要做的下一个是什么？我们想这样做

1114
00:56:53,944 --> 00:56:56,645
这个游戏有点难度。我有这个游戏，并且

1115
00:56:56,714 --> 00:56:59,448
它实际上比我们其他的集中度要难一些

1116
00:56:59,517 --> 00:57:03,518
游戏是因为我们必须更多关注。

1117
00:57:03,587 --> 00:57:05,453
因为不匹配，所以他们翻转过来

1118
00:57:05,522 --> 00:57:08,489
很快，如果我试图找到一个匹配，在这里，唷，

1119
00:57:08,558 --> 00:57:11,659
有一场比赛很幸运。如果我试图找到一个匹配，

1120
00:57:11,728 --> 00:57:15,597
这很难做到。但我会更加努力的

1121
00:57:15,666 --> 00:57:19,067
让这些卡片动起来。

1122
00:57:19,136 --> 00:57:21,370
这些卡片会不断移动。

1123
00:57:21,438 --> 00:57:24,772
所以我不得不追赶他们把他们翻过来。

1124
00:57:24,841 --> 00:57:27,743
我会用我们的动态动画师来做到这一点。

1125
00:57:29,179 --> 00:57:31,647
Cuz就是动态动画制作者所擅长的。

1126
00:57:31,715 --> 00:57:35,417
有点把它们放在那里，它只是漂浮在附近。

1127
00:57:36,854 --> 00:57:38,986
好，那么，我们该怎么做？

1128
00:57:39,055 --> 00:57:43,958
动态动画师，让我们走到这里。我们要开始了，我们是

1129
00:57:44,027 --> 00:57:47,028
要做3个步骤，对吧？动画师，行为，物品等等

1130
00:57:47,097 --> 00:57:49,764
让我们从动画师开始。我要创建一个lazy var，

1131
00:57:49,833 --> 00:57:53,368
我们将称之为动画师。这将是

1132
00:57:53,437 --> 00:57:57,572
一个UIDynamicAnimator。而对于它的参考视图，我是

1133
00:57:57,641 --> 00:57:59,675
要在这里使用referenceView构造函数。

1134
00:57:59,743 --> 00:58:03,377
我要让自己看，正确的，顶级的视图

1135
00:58:03,446 --> 00:58:05,714
我的视图控制器，我会让它成为我的referenceView。

1136
00:58:05,783 --> 00:58:08,483
再次，如果你正在编写一个像子视图和

1137
00:58:08,552 --> 00:58:10,552
东西，它可能不是最高水平。

1138
00:58:10,620 --> 00:58:12,688
但这是一个演示，我没有任何其他意见。

1139
00:58:12,756 --> 00:58:15,157
所以这就是我必须要做的。好，如此

1140
00:58:15,225 --> 00:58:18,226
那会是我的动画师，太好了。现在我需要行为，

1141
00:58:18,295 --> 00:58:20,528
所以我会在这里创建另一个懒惰的变量。

1142
00:58:20,597 --> 00:58:24,199
我会把它称为我的碰撞行为。

1143
00:58:24,268 --> 00:58:27,769
这将是UICollisionBehavior类型。

1144
00:58:27,838 --> 00:58:31,339
我将用闭包初始化这个。

1145
00:58:31,408 --> 00:58:32,774
我们在演讲中谈到了这个，但是

1146
00:58:32,843 --> 00:58:34,943
我们从来没有真正做到过，我不认为。

1147
00:58:35,012 --> 00:58:37,479
那么如何用闭包初始化它？这很容易，

1148
00:58:37,548 --> 00:58:40,515
我只是创建行为。我创建了一个UICollisionBehavior

1149
00:58:40,584 --> 00:58:43,719
这里。它的初始化没有参数，配置它。

1150
00:58:43,787 --> 00:58:46,554
所以我想对这种碰撞行为做唯一的事情

1151
00:58:46,623 --> 00:58:49,091
是有我的referenceView保持我的卡的边缘

1152
00:58:49,159 --> 00:58:51,559
每张牌都会反弹掉

1153
00:58:51,628 --> 00:58:54,329
其他和边缘。所以，我会这样做

1154
00:58:54,398 --> 00:58:57,766
translateReferenceBoundsIntoB-oundary = true。

1155
00:58:57,835 --> 00:59:02,704
这是一种便宜而快捷的方式来获得碰撞边界。

1156
00:59:02,773 --> 00:59:07,308
然后我会将它添加到我的动画师，addBehavior和

1157
00:59:07,377 --> 00:59:11,913
那么我会从闭包中返回行为。这返回

1158
00:59:11,982 --> 00:59:14,816
它从闭包，它分配给这个变种，和

1159
00:59:14,884 --> 00:59:20,021
这都很lazy。我们看到我们如何在那里使用闭包，

1160
00:59:20,090 --> 00:59:25,160
真的很方便。现在我们有什么在这里？

1161
00:59:25,229 --> 00:59:29,297
AddBehavior，将行为添加到动画师，

1162
00:59:29,366 --> 00:59:32,166
好吧？所以现在我们有这种行为。

1163
00:59:32,235 --> 00:59:35,103
我们需要做第3步，添加项目。

1164
00:59:35,171 --> 00:59:36,905
这是我们创建所有卡片视图的地方。

1165
00:59:36,974 --> 00:59:43,211
我们只是在这里说collisionBehavior.addItem，

1166
00:59:43,280 --> 00:59:47,849
cardView。现在卡片视图即刻得到尊重

1167
00:59:47,918 --> 00:59:50,151
该边界并开始跳入其他卡片。但

1168
00:59:50,220 --> 00:59:53,522
当然，我们并没有移动这张卡片，但它并没有移动，所以我们

1169
00:59:53,590 --> 00:59:57,158
需要这样做。我们会用pushBehavior做到这一点。

1170
00:59:57,227 --> 01:00:00,394
所以我会让push = UIPushBehavior。

1171
01:00:00,463 --> 01:00:03,765
现在，pushBehavior的初始值设定项将采用您的项目

1172
01:00:03,834 --> 01:00:08,069
想push。所以

1173
01:00:08,138 --> 01:00:11,473
所以这只是这个cardView在这里。我可以

1174
01:00:11,541 --> 01:00:13,107
创建一个将所有卡片放在那里的推送行为。

1175
01:00:13,176 --> 01:00:14,809
但是他们都会被推向相同的方向，

1176
01:00:14,878 --> 01:00:16,745
我不想那样。然后模式，

1177
01:00:16,813 --> 01:00:21,216
再次，可以是连续的，或者在我们的情况下是瞬时的。

1178
01:00:21,285 --> 01:00:24,018
我们只是要推动卡片，然后我们就完成了。

1179
01:00:24,087 --> 01:00:25,453
既然它是瞬间的，

1180
01:00:25,522 --> 01:00:27,655
我们要在它之后清理。

1181
01:00:27,724 --> 01:00:30,258
所以让我们给它一个角度，所以我会推动它

1182
01:00:30,327 --> 01:00:33,327
角度，这是0到2 pi之间的随机角度。这是在

1183
01:00:33,396 --> 01:00:36,264
弧度，所以我会说2倍CGFloat.pi和

1184
01:00:36,333 --> 01:00:39,534
这将是随机的。所以我需要使用arch4random。

1185
01:00:39,603 --> 01:00:42,871
我也为CGFloat添加了一些小的arch4random。

1186
01:00:42,939 --> 01:00:45,006
我们将它添加到int中，但您已经知道如何做到这一点，

1187
01:00:45,075 --> 01:00:46,774
但我添加了一个浮动。和

1188
01:00:46,843 --> 01:00:50,278
那么大小，我并不是真的想把它推到0.所以

1189
01:00:50,347 --> 01:00:55,583
我会做至少1.0的重要性，对吧？

1190
01:00:55,652 --> 01:01:00,255
但是，我会添加一些额外的，

1191
01:01:00,324 --> 01:01:04,725
让我们说2.0 arc4random。所以

1192
01:01:04,794 --> 01:01:07,795
我们会有这么大的幅度，这必须是一个CGFloat，

1193
01:01:07,864 --> 01:01:11,166
对？这是一个双重的，所以我们会去CGFloat的所有这一切。

1194
01:01:11,234 --> 01:01:17,973
糟糕，CGFloat（1.0），CGFloat（2.0），

1195
01:01:18,041 --> 01:01:22,043
随机。可能不需要这两种CGFloats。但

1196
01:01:22,112 --> 01:01:25,213
无论如何，所以我们创建一个随机。所以我创建了一个随机

1197
01:01:25,281 --> 01:01:30,752
大小在1和3之间。在那里推动一个随机数量。

1198
01:01:30,821 --> 01:01:36,390
现在我只需要对动画师说。添加这种行为，

1199
01:01:36,459 --> 01:01:38,894
添加这个pushBehavior。一旦我添加到

1200
01:01:38,962 --> 01:01:41,763
动画师，它会推动它的项目，

1201
01:01:41,831 --> 01:01:44,832
这只是一个cardView。现在我们知道了

1202
01:01:44,901 --> 01:01:47,368
这是不好的，因为它现在完成了，它永远不会

1203
01:01:47,437 --> 01:01:50,204
得到清理。所以我会使用push.action，

1204
01:01:50,273 --> 01:01:54,342
好吧，只需按下即可将其从动画制作工具中移除。

1205
01:01:54,411 --> 01:01:57,645
告诉我你的dynamicAnimator，如果你有的话

1206
01:01:57,714 --> 01:02:01,182
从中删除自己。和

1207
01:02:01,251 --> 01:02:04,185
我们知道这导致了一个内存周期，因为这个推动

1208
01:02:04,253 --> 01:02:06,888
这里正在保持闭包在内存。和

1209
01:02:06,957 --> 01:02:09,090
当然，推动的行动正在指向闭包，所以

1210
01:02:09,159 --> 01:02:10,959
他们保持其他的内存。

1211
01:02:11,028 --> 01:02:15,630
所以我们可以通过说unowned.push来摆脱这个问题。

1212
01:02:15,699 --> 01:02:18,733
是的，我可以说weak push，然后有一个可选

1213
01:02:18,802 --> 01:02:21,202
在这里链，甚至可能在这里感叹号。

1214
01:02:21,271 --> 01:02:22,437
但如果我要做感叹号，

1215
01:02:22,505 --> 01:02:23,638
你也可以让它无主，

1216
01:02:23,706 --> 01:02:28,109
因为无论如何你都在解开它。好，如此

1217
01:02:28,178 --> 01:02:29,243
让我们来看看发生了什么。所以

1218
01:02:29,312 --> 01:02:31,879
我们在这里所做的只是我们创造了一个动画师，一个碰撞

1219
01:02:31,948 --> 01:02:34,949
行为和推动行为。让我们看看发生了什么，

1220
01:02:35,018 --> 01:02:41,489
看看它是否只是动画。 Woo-hoo，我们做到了现在，

1221
01:02:41,558 --> 01:02:45,059
虽然我没有完全得到我想要的东西。

1222
01:02:45,128 --> 01:02:47,695
有一件事是看看它多快安定下来。

1223
01:02:47,764 --> 01:02:50,932
这种情况太简单了，太快了。

1224
01:02:51,001 --> 01:02:53,034
这会让玩这个游戏变得很容易。

1225
01:02:53,103 --> 01:02:54,736
我想让这些卡片移动一点。

1226
01:02:54,805 --> 01:02:57,672
另一件事是我不认为我想要他们旋转。

1227
01:02:57,741 --> 01:03:00,375
让它们实际旋转很有趣。

1228
01:03:00,444 --> 01:03:03,011
但是当你翻牌时，例如，

1229
01:03:03,080 --> 01:03:05,213
它不会沿着图形的轴线翻转。

1230
01:03:05,281 --> 01:03:08,283
它沿着视图的轴线翻转。所以看这个翻盖，

1231
01:03:08,351 --> 01:03:11,052
你看它是如何在角落里翻转？

1232
01:03:11,121 --> 01:03:13,488
也许没关系，但我会认定它不是。

1233
01:03:13,557 --> 01:03:16,024
因为我也想告诉你如何做动态项目

1234
01:03:16,093 --> 01:03:19,594
行为。此外，它的原因是减速如此

1235
01:03:19,662 --> 01:03:23,098
很多碰撞中没有足够的弹性。

1236
01:03:23,167 --> 01:03:24,933
我希望这些碰撞能够反弹

1237
01:03:25,002 --> 01:03:28,636
保持精力。所以我们来修复，然后

1238
01:03:28,705 --> 01:03:33,374
我们用另一种行为来做到这一点，就像我们的行为一样

1239
01:03:33,443 --> 01:03:37,579
碰撞行为。这是一个itemBehavior，

1240
01:03:37,647 --> 01:03:42,250
这是一个UIDynamicItemBehaviour。我会这样做的

1241
01:03:42,318 --> 01:03:47,956
也关闭。所以，我们只是在这里创建行为，

1242
01:03:48,024 --> 01:03:52,293
哎呀，让行为= UIDynamicItemBehaviour。

1243
01:03:52,362 --> 01:03:54,696
现在我们将配置这种行为。

1244
01:03:54,764 --> 01:03:58,332
所以我想allowRotation = false。

1245
01:03:58,401 --> 01:04:01,169
我不希望那些东西在旋转。

1246
01:04:01,237 --> 01:04:04,339
我想要弹性，看看有很多，

1247
01:04:04,407 --> 01:04:05,840
您将不得不查看文档以查看

1248
01:04:05,909 --> 01:04:07,675
所有你可以在这里做的不可思议的事情。但

1249
01:04:07,744 --> 01:04:12,080
我想弹性1.0意味着碰撞不会丢失

1250
01:04:12,149 --> 01:04:16,384
能量或获得能量。如果我把它设置为弹性1.1，

1251
01:04:16,453 --> 01:04:17,852
他们会获得一点能量。

1252
01:04:17,921 --> 01:04:20,087
这些事情开始越来越快，越来越快，

1253
01:04:20,156 --> 01:04:23,558
算了吧。但是如果我将它设置为0.9，他们会放慢速度。

1254
01:04:23,626 --> 01:04:26,894
不像现在那样慢，但如此

1255
01:04:26,963 --> 01:04:29,797
1.0是我可以赋予它最大的弹性

1256
01:04:29,866 --> 01:04:33,567
没有遇到加速的情况。而且，我会

1257
01:04:33,636 --> 01:04:36,537
设置，我不确定这个默认值是什么，但是

1258
01:04:36,606 --> 01:04:39,607
我会设置阻力，这是抵制多少

1259
01:04:39,675 --> 01:04:43,044
正在施加的力量。我将把它设置为0，

1260
01:04:43,112 --> 01:04:45,713
我不想任何抵抗。我希望它是免费的

1261
01:04:45,782 --> 01:04:49,918
在这里流过的外太空不能抵抗任何东西。所以

1262
01:04:49,987 --> 01:04:53,688
让我们将其添加到动画师，添加行为，

1263
01:04:56,492 --> 01:05:01,996
并返回行为。好的，现在我们需要做的是什么？

1264
01:05:02,065 --> 01:05:05,367
不，因为如果我们不添加任何项目

1265
01:05:05,435 --> 01:05:08,236
项目的行为，那么它不会做任何事情。

1266
01:05:08,304 --> 01:05:10,738
就像我们将cardView添加到碰撞一样

1267
01:05:10,807 --> 01:05:13,073
行为，我们必须将其添加到项目行为。

1268
01:05:13,142 --> 01:05:17,044
一旦我们这样做，只要我们添加这个东西，

1269
01:05:17,113 --> 01:05:20,648
它会让所有这些设置允许旋转

1270
01:05:20,716 --> 01:05:23,317
和所有这些业务。那么让我们看看这是否会成为现实

1271
01:05:23,386 --> 01:05:31,759
更好。好吧，它确实让它变得更好。

1272
01:05:31,828 --> 01:05:35,263
好吧，它仍然在放缓，我想要一点点

1273
01:05:35,332 --> 01:05:37,298
因为我想要这个人拥有

1274
01:05:37,367 --> 01:05:40,201
他们离开的机会。他们的速度太快了，

1275
01:05:40,269 --> 01:05:41,836
你只是在追赶他们和

1276
01:05:41,904 --> 01:05:44,238
那么你永远不会记得其他人去了哪里。所以

1277
01:05:44,307 --> 01:05:45,973
我确实希望它稍微放慢一点。

1278
01:05:46,042 --> 01:05:48,642
也许不是所有的方式来这里，我可以玩这个。

1279
01:05:48,711 --> 01:05:51,145
其实有一种如何保持的想法

1280
01:05:51,214 --> 01:05:54,582
随着比赛的进行，运动中的事物仍然会给人

1281
01:05:54,650 --> 01:05:58,786
让它减速的一个机会。但在我们这样做之前，

1282
01:05:58,855 --> 01:06:01,722
我想谈一谈创作

1283
01:06:01,791 --> 01:06:05,994
一个UIDynamicBehavior子类，我们在其中组合其他类。

1284
01:06:06,062 --> 01:06:08,429
因为看，我们在这里有三种不同的行为。

1285
01:06:08,497 --> 01:06:10,031
我们有碰撞行为，

1286
01:06:10,099 --> 01:06:12,767
我们得到了项目行为，我们得到了推动行为。和

1287
01:06:12,835 --> 01:06:15,636
我们必须完成三个不同的代码

1288
01:06:15,705 --> 01:06:18,739
那在我们的视图控制器中。如果我们有的话，会更好

1289
01:06:18,808 --> 01:06:22,676
另一种行为称为卡行为。它拥有一切

1290
01:06:22,745 --> 01:06:25,246
那些作为它的一部分。然后我们只需添加卡片即可

1291
01:06:25,315 --> 01:06:27,481
行为，然后我们会得到碰撞和物品

1292
01:06:27,550 --> 01:06:30,718
自动推动。所以这就是我们要做的。

1293
01:06:30,786 --> 01:06:33,688
我们来到这里File> New> File。

1294
01:06:33,757 --> 01:06:35,523
我要创建一个Cocoa Touch类，

1295
01:06:35,592 --> 01:06:37,992
作为可可触摸类的UIDynamicBehavior。

1296
01:06:38,061 --> 01:06:39,994
这里是UIDynamicBehavior的子类。

1297
01:06:40,063 --> 01:06:44,365
我将称之为CardBehavior。我会把它

1298
01:06:44,434 --> 01:06:48,302
所有其余的文件都在那里，不要忘记。

1299
01:06:48,371 --> 01:06:52,139
在这里，CardBehavior是UIDynamicBehavior的一个子类。

1300
01:06:52,208 --> 01:06:55,175
而我要做的就是去这里抓住这一切

1301
01:06:55,244 --> 01:06:59,848
东西，把它拿出来放在这里。可以，然后呢

1302
01:06:59,916 --> 01:07:01,448
我只是把那些行为放在那里，

1303
01:07:01,517 --> 01:07:04,519
甚至推动。我也会推掉这里，

1304
01:07:04,588 --> 01:07:05,420
把它放在这里。

1305
01:07:05,488 --> 01:07:07,154
我将推出一个小功能，

1306
01:07:07,223 --> 01:07:11,960
一个叫做push的私人func，它推动一个物品。这个可以

1307
01:07:12,028 --> 01:07:15,296
所有在UIDynamicItem上工作，我有UIViews，但

1308
01:07:15,365 --> 01:07:17,732
我的代码中没有特定于UIView的内容，

1309
01:07:17,801 --> 01:07:21,068
这只是动态的动态项目。所以

1310
01:07:21,137 --> 01:07:24,572
我们会把所有推送的东西放在那里。现在我们会有

1311
01:07:24,641 --> 01:07:26,374
以解决这些小的复制和粘贴问题。

1312
01:07:26,442 --> 01:07:29,277
但这基本上就是你如何创造你的

1313
01:07:29,346 --> 01:07:34,148
通过这些做自己的动态行为。但是这些必须是

1314
01:07:34,216 --> 01:07:38,953
添加为孩子，我们将它们添加为init中的子类。

1315
01:07:39,021 --> 01:07:43,625
所以99.9％的时间，当你创建一个动态行为时，

1316
01:07:43,693 --> 01:07:47,127
你会重写init而没有参数。

1317
01:07:47,196 --> 01:07:49,898
你会打电话给super.init，然后你会添加你的

1318
01:07:49,966 --> 01:07:53,067
子类。所以我有我的碰撞行为，

1319
01:07:53,135 --> 01:07:58,139
我会补充，我有我的物品行为，我会补充。

1320
01:07:58,208 --> 01:08:00,241
现在，我无法在这里添加我的推送行为，

1321
01:08:00,309 --> 01:08:03,811
因为推动行为，我需要知道这个项目。所以

1322
01:08:03,880 --> 01:08:08,182
我还不能完全做到这一点。所以显然我不需要

1323
01:08:08,251 --> 01:08:10,384
在这里将它们添加到动画制作者，

1324
01:08:10,453 --> 01:08:13,187
因为有人会把我添加到动画师和

1325
01:08:13,256 --> 01:08:14,788
这就是这些东西的意义

1326
01:08:14,857 --> 01:08:17,291
所有人都被放入动画师。这里同样的事情。所以

1327
01:08:17,360 --> 01:08:20,894
我将如何处理这种推动事实？好，

1328
01:08:20,963 --> 01:08:25,700
我也会添加一个func添加项目，添加一个项目，

1329
01:08:25,768 --> 01:08:28,636
一个UIDynamicItem。当我添加它时，

1330
01:08:28,705 --> 01:08:31,506
我会把它加到我所有的孩子身上。所以

1331
01:08:31,575 --> 01:08:35,676
我将把它添加到collisionBehavior.addItem中，

1332
01:08:35,745 --> 01:08:42,283
我将把它添加到我的itemBehavior中，并且

1333
01:08:42,352 --> 01:08:44,952
我要推，所以我也要推这个物品，

1334
01:08:45,021 --> 01:08:48,322
这基本上是将它添加到推送行为。

1335
01:08:48,391 --> 01:08:51,259
所以让我们来解决这个问题，这需要项目不CardView

1336
01:08:51,328 --> 01:08:52,894
在这里你看到了这个视图，对吧？

1337
01:08:54,364 --> 01:08:57,398
这里的推动行动，请注意我们正在移除

1338
01:08:57,467 --> 01:09:00,033
直接来自动态动画的行为。

1339
01:09:00,102 --> 01:09:03,904
其实我想在这里做的是让它成为一个孩子，所以

1340
01:09:03,973 --> 01:09:10,878
我会添加一个推动孩子的行为。和

1341
01:09:10,947 --> 01:09:13,914
那么当我删除，而不是直接删除行为

1342
01:09:13,983 --> 01:09:18,953
从动画师那里，我要去除我的孩子行为。

1343
01:09:21,958 --> 01:09:24,692
看，现在这里发生了一件小事，

1344
01:09:24,761 --> 01:09:27,528
一旦它在这里编译就会抱怨。

1345
01:09:27,597 --> 01:09:31,332
在封闭中隐含地使用'自我'，使用'自我'。事实上，

1346
01:09:31,401 --> 01:09:36,270
如果我可以输入自我，我会这样做

1347
01:09:36,339 --> 01:09:38,505
这是现在捕捉自我，

1348
01:09:38,574 --> 01:09:42,943
这是动态行为。嗨，好吧，我们不想这样做

1349
01:09:43,012 --> 01:09:45,512
那是因为动态行为绝对有

1350
01:09:45,581 --> 01:09:48,215
一个指向这个闭包的指针，因为它有一个指针

1351
01:09:48,284 --> 01:09:51,886
它是一种推动行为的自己的孩子行为。

1352
01:09:51,955 --> 01:09:53,221
推动行为指向它。

1353
01:09:53,289 --> 01:09:56,190
所以我会说，弱，我会摆脱这一点

1354
01:09:56,258 --> 01:10:01,328
自。好吧，呃，打破了那件事。我仍然需要无主人

1355
01:10:01,397 --> 01:10:04,999
推，因为我也在那里传球。现在我不知道

1356
01:10:05,068 --> 01:10:07,968
想在那里做无主的自我，因为只是为了一些

1357
01:10:08,037 --> 01:10:10,738
原因整个行为从堆中移除，

1358
01:10:10,807 --> 01:10:12,573
我不想在这里崩溃。

1359
01:10:12,642 --> 01:10:14,508
所以我只会做一个弱点以保证安全。

1360
01:10:14,577 --> 01:10:17,078
我不知道这种推动的事实

1361
01:10:17,147 --> 01:10:19,046
必须在堆，因为我不会在这里。

1362
01:10:19,115 --> 01:10:24,618
这不一定是真实的。所以我们在那里推动，

1363
01:10:24,687 --> 01:10:27,621
现在我们已经收集了我们所有的代码，

1364
01:10:27,690 --> 01:10:29,557
实际上我会再添加一件东西，

1365
01:10:29,625 --> 01:10:31,926
因为我们没有看到这是方便的init。

1366
01:10:31,995 --> 01:10:34,495
好吧，我要在这里添加一个便捷初始值设定项，

1367
01:10:34,564 --> 01:10:37,832
让我指定我想要加入的动画师。

1368
01:10:37,901 --> 01:10:39,299
我只是想展示它的样子

1369
01:10:39,368 --> 01:10:42,737
创建一个便利的初始化。而你所做的一切

1370
01:10:42,805 --> 01:10:46,073
创建一个便利的init是你可以只有一个self.init

1371
01:10:46,142 --> 01:10:49,076
对自己，然后你可以做你想做的事情。

1372
01:10:49,145 --> 01:10:52,112
在这种情况下，我只是想告诉动画师

1373
01:10:52,181 --> 01:10:56,851
添加行为我自己。看看这就像是一种方便

1374
01:10:56,920 --> 01:10:58,886
我能够创建其中的一个和

1375
01:10:58,955 --> 01:11:02,390
有它自动添加。所以让我们使用这种便利

1376
01:11:02,458 --> 01:11:06,827
发起者，初始化器在我们的视图控制器中返回，

1377
01:11:06,896 --> 01:11:10,164
其实我们可以回去。这里是，

1378
01:11:10,233 --> 01:11:13,700
而不是将每个项目都添加到碰撞和

1379
01:11:13,769 --> 01:11:16,437
项目，我们只是将它添加到一个cardBehavior中，

1380
01:11:16,506 --> 01:11:20,240
我们将不得不创建。所以我会有cardBehavior，

1381
01:11:20,309 --> 01:11:23,343
将项目添加到cardView，然后我将创建一个var

1382
01:11:23,412 --> 01:11:26,079
在这里，一个lazy var。它可能甚至不需要lazy，

1383
01:11:26,148 --> 01:11:29,684
是的，它可能会。 Lazy var，我会调用

1384
01:11:29,752 --> 01:11:33,754
cardBehavior，这只是一个卡牌行为。和

1385
01:11:33,823 --> 01:11:37,224
我会用我很好的方便初始化器来说

1386
01:11:37,293 --> 01:11:41,795
在我的动画师。好的，真的

1387
01:11:41,864 --> 01:11:45,165
在我们的视图控制器中清理了我们的代码。事实上，

1388
01:11:45,234 --> 01:11:48,803
所有必须做的只有两行代码

1389
01:11:48,872 --> 01:11:51,339
与我们的动态动画在这件事上。

1390
01:11:51,407 --> 01:11:54,442
我们已将这一切转移到了那件好事上。让我们确保我们

1391
01:11:54,511 --> 01:12:00,882
这样做并没有破坏任何东西。我们没有。好的，

1392
01:12:00,950 --> 01:12:04,151
它仍然在工作。我们仍然可以将卡片翻转过来。

1393
01:12:04,219 --> 01:12:07,921
那些是在那里进行的单独的动画。现在，

1394
01:12:07,990 --> 01:12:10,224
我想在这里做一些其他的事情。

1395
01:12:10,293 --> 01:12:14,662
一个是，当你选择一张卡时，我希望它停止。

1396
01:12:14,731 --> 01:12:18,298
我希望它停止动画。你选了一张卡

1397
01:12:18,367 --> 01:12:21,302
你可以喘口气，看看你的卡。

1398
01:12:21,371 --> 01:12:24,438
然后，如果您将卡翻转过来或与之匹配，

1399
01:12:24,507 --> 01:12:27,375
或者如果不匹配，它会被翻转，

1400
01:12:27,444 --> 01:12:29,944
那么我会推动它。因为看到如何

1401
01:12:30,013 --> 01:12:33,747
一切都停止了，所以现在，选择卡片，我们将开始

1402
01:12:33,816 --> 01:12:35,883
推动他们一点，让他们再次去。所以，

1403
01:12:35,952 --> 01:12:37,751
是的，你可以等待整个事情放慢速度

1404
01:12:37,820 --> 01:12:40,354
停下来，然后你可以选择一张卡。但是一旦你选择它们，

1405
01:12:40,423 --> 01:12:42,056
他们会再次四处走动

1406
01:12:42,125 --> 01:12:44,257
再次洗牌，对你很难。所以

1407
01:12:44,326 --> 01:12:44,925
这看起来很不错

1408
01:12:44,994 --> 01:12:48,295
在不断的动作和动作之间让我感到妥协

1409
01:12:48,364 --> 01:12:50,565
所有人都完全像这样坐着。所以

1410
01:12:50,633 --> 01:12:53,367
我该怎么做？那现在超级容易

1411
01:12:53,435 --> 01:12:56,237
因为我有这种行为。如果我删除

1412
01:12:56,305 --> 01:12:59,006
一个来自该行为的项目，它会自动完成

1413
01:12:59,074 --> 01:13:01,242
停止动画。因为没有什么会表现的。

1414
01:13:01,311 --> 01:13:04,178
将不会有任何行为操作。可以，然后呢

1415
01:13:04,247 --> 01:13:05,112
我怎么做？好，

1416
01:13:05,180 --> 01:13:07,648
我只是想在我的翻盖卡上就这样做。

1417
01:13:07,717 --> 01:13:11,419
只要我碰到一个会翻转卡片的卡片，

1418
01:13:11,487 --> 01:13:14,622
我只是想说cardBehavior，而不是。

1419
01:13:14,690 --> 01:13:17,624
以小写字母C表示的CardBehavior，

1420
01:13:17,693 --> 01:13:22,797
cardBehavior删除此选定的卡。好的，

1421
01:13:22,865 --> 01:13:25,532
但我想把它重新添加到行为中。

1422
01:13:25,601 --> 01:13:30,003
我何时想将其添加回行为？无论何时，

1423
01:13:30,072 --> 01:13:33,374
我没有添加删除项目，让我们确保我们这样做，

1424
01:13:33,443 --> 01:13:38,312
抱歉。我们的行为在哪里？对，对不起，

1425
01:13:38,380 --> 01:13:41,582
我们有添加项目，我们也需要删除项目，好吧。和

1426
01:13:41,650 --> 01:13:44,585
removeItem是完全一样的东西，除了

1427
01:13:44,654 --> 01:13:49,690
我们正在从所有行为中去除事物。

1428
01:13:49,759 --> 01:13:53,460
删除，对不起，忘了。去掉，

1429
01:13:53,529 --> 01:13:54,661
而且，我们不必删除推送

1430
01:13:54,730 --> 01:13:57,064
因为我们会尽快自动删除推送

1431
01:13:57,132 --> 01:14:00,868
发生，对吧？这就是我们要去除推送的地方。所以

1432
01:14:00,937 --> 01:14:03,737
因为我们删除了整个推送行为，我们不需要

1433
01:14:03,806 --> 01:14:06,907
从中删除项目。所以有removeItem，

1434
01:14:06,976 --> 01:14:12,012
对于那个很抱歉。好的，清楚，好吧，让我们回到我们的

1435
01:14:12,081 --> 01:14:14,982
这里的东西。所以现在我们可以做一个removeItem，但我们想放

1436
01:14:15,051 --> 01:14:17,118
他们回来了，我们什么时候想把他们放回去？

1437
01:14:17,186 --> 01:14:19,286
好吧，如果你只是把卡片翻过来，我们想放

1438
01:14:19,355 --> 01:14:22,122
它回来了，或者如果两张牌被翻转下来

1439
01:14:22,191 --> 01:14:24,658
你自动因为你有一个不匹配，那么我们

1440
01:14:24,727 --> 01:14:27,294
也想那样做。所以，让我们把这个，我们只是

1441
01:14:27,362 --> 01:14:30,263
要把这些东西放回去。所以，

1442
01:14:30,332 --> 01:14:33,968
这里的人在哪里？让我们看看我能否找到它们。

1443
01:14:34,036 --> 01:14:37,672
好吧，这是两张牌不匹配的地方

1444
01:14:37,740 --> 01:14:40,240
我们正在自动翻转它在这里，所以

1445
01:14:40,309 --> 01:14:43,410
我只是想拥有这张牌的行为，

1446
01:14:43,479 --> 01:14:48,049
添加项目，卡片视图。好的，让我们把它放回去。

1447
01:14:48,117 --> 01:14:51,118
它自动翻转脸，并且

1448
01:14:51,187 --> 01:14:55,088
那么这就是其他的，哎呀，当然还有我自己。

1449
01:14:55,157 --> 01:14:57,958
这是否会导致内存周期？没有，因为这些

1450
01:14:58,027 --> 01:15:01,361
动画系统闭包。我们没事，好吗？

1451
01:15:01,430 --> 01:15:04,331
所以在这里，这是在没有两张牌的情况下。

1452
01:15:04,399 --> 01:15:07,701
只有一张牌。如果你翻过卡面

1453
01:15:07,770 --> 01:15:13,941
向下，如果选择了CardView，

1454
01:15:14,009 --> 01:15:17,645
它面朝下，所以不要面朝上。所以

1455
01:15:17,713 --> 01:15:21,782
你拿起卡片，它正面朝上，然后你再次选择它，

1456
01:15:21,851 --> 01:15:24,551
它面朝下，然后在这里我需要有CardBehavior

1457
01:15:24,620 --> 01:15:28,188
就在那里，因为我不在闭包添加项目中，

1458
01:15:28,257 --> 01:15:30,257
把cardView放回去。

1459
01:15:30,326 --> 01:15:32,693
现在情况是什么卡匹配？

1460
01:15:32,761 --> 01:15:35,262
不需要把它们放回去，因为它们会消失，对吧？

1461
01:15:35,331 --> 01:15:36,731
我们删除隐藏的区域，

1462
01:15:36,799 --> 01:15:39,466
所以没有理由让他们回来，对吧？和

1463
01:15:39,535 --> 01:15:43,704
它不是cardVew，它是选择CardView。可以，然后呢

1464
01:15:43,773 --> 01:15:49,510
让我们看看这是否有效。糟糕cardBehavior，这是正确的

1465
01:15:49,578 --> 01:15:52,579
在完成处理程序中。这是闭包的，

1466
01:15:52,648 --> 01:15:56,784
它在这个初始翻转的完成处理程序中。

1467
01:15:56,853 --> 01:15:59,386
所以这是因为......每次你必须，

1468
01:15:59,455 --> 01:16:01,922
任何时候它对你说这些，你就把自己放在那里

1469
01:16:01,990 --> 01:16:05,225
你想去，嗯，这是否会导致内存周期？

1470
01:16:05,294 --> 01:16:06,494
不，它不在这里，我们没事。

1471
01:16:06,562 --> 01:16:12,866
这只是一个完成处理程序的闭包，我们很好。好的，

1472
01:16:12,935 --> 01:16:15,536
所以现在当我点击一个，如果我能得到一个，那就是。

1473
01:16:15,605 --> 01:16:18,171
它停下来，看，它没有被反弹到或

1474
01:16:18,240 --> 01:16:20,641
以任何方式移动。现在如果我选择另一个，

1475
01:16:20,710 --> 01:16:24,344
他们不匹配。现在，他们都得到了推动。因为每一个

1476
01:16:24,413 --> 01:16:28,683
当我添加一个项目回到我的cardBehavior时，它会得到一个推动

1477
01:16:28,751 --> 01:16:31,084
这是一种很酷的，有点不错的小功能。

1478
01:16:31,153 --> 01:16:33,654
这里同样的事情，他们不匹配他们被推。

1479
01:16:33,722 --> 01:16:36,156
好吧，这些不匹配，他们得到推动和

1480
01:16:36,225 --> 01:16:38,759
希望如果我们找到两个匹配的地方，

1481
01:16:38,828 --> 01:16:41,462
有人帮助我，他们怎么知道自己在哪里。

1482
01:16:41,530 --> 01:16:44,865
无论如何，我们走了，我们必须匹配，好吧。所以

1483
01:16:44,934 --> 01:16:46,567
这有点不错，它玩起来挺好的。但

1484
01:16:46,636 --> 01:16:49,770
我仍然不喜欢这件事。

1485
01:16:49,838 --> 01:16:52,173
一个是，我真的不喜欢这样的事情

1486
01:16:52,241 --> 01:16:55,476
许多。如果事情停止，我不介意，但我真的宁愿

1487
01:16:55,545 --> 01:16:58,378
他们会走向中间。所以，我有一点

1488
01:16:58,447 --> 01:17:03,317
解决这个问题，这是在我的cardBehavior在这里。

1489
01:17:03,385 --> 01:17:06,720
当我推，而不是以一个随机的角度推动，

1490
01:17:06,789 --> 01:17:09,957
相反，我要推动，而我们没有时间

1491
01:17:10,025 --> 01:17:13,594
我把它全部输入。我要推向中心。

1492
01:17:13,663 --> 01:17:17,164
所以根据卡片在参考范围内的位置，

1493
01:17:17,233 --> 01:17:18,999
参考视图边界，

1494
01:17:19,067 --> 01:17:22,803
我要推向中心。所以这是一个过程

1495
01:17:22,871 --> 01:17:25,906
当你做动画类型的动画调整。

1496
01:17:25,975 --> 01:17:27,875
看到什么是有道理的，什么是没有道理的。

1497
01:17:27,944 --> 01:17:30,845
所以这是一个很好的调整，以推动中心。

1498
01:17:30,913 --> 01:17:35,949
另一种我们可以调整动画的方式

1499
01:17:36,018 --> 01:17:39,252
这是为了让他们放慢脚步。因为当他们这样去的时候

1500
01:17:39,321 --> 01:17:41,821
有时他们很快就没有工作

1501
01:17:41,890 --> 01:17:44,858
我们无法确定。所以我们回去放慢一些

1502
01:17:44,927 --> 01:17:48,361
我们的动画，看看他们在做什么。所以，例如

1503
01:17:48,430 --> 01:17:52,799
让我们加载我们的匹配卡片的动画。所以何时

1504
01:17:52,868 --> 01:17:55,903
记得我们正在扩展它

1505
01:17:55,972 --> 01:17:59,173
最多三次，我们将其缩小。我们出去了

1506
01:17:59,242 --> 01:18:01,608
α为零。所以，不要这样做，你知道，

1507
01:18:01,677 --> 01:18:03,944
大约半秒钟，四分之三秒，

1508
01:18:04,012 --> 01:18:06,546
让我们慢下来总共需要六秒钟，

1509
01:18:06,615 --> 01:18:07,614
三秒钟。

1510
01:18:07,683 --> 01:18:12,352
对于动画的每个部分，看看我们的应用程序是

1511
01:18:12,421 --> 01:18:16,357
很好地工作，所以我们会发现任何问题。

1512
01:18:18,627 --> 01:18:21,262
好吧，这将需要我找到一场比赛。让我们看看我们得到了

1513
01:18:21,330 --> 01:18:26,333
在这里我们可以找到卡，直到我们可以找到，我想，

1514
01:18:26,402 --> 01:18:31,138
不，不好，我们走了。所以它会很慢，但是

1515
01:18:31,206 --> 01:18:33,173
看看如果我点击其他卡片会发生什么。

1516
01:18:33,242 --> 01:18:34,140
他们仍然能够匹配，

1517
01:18:34,209 --> 01:18:36,476
实际上我可以选择两个以上和

1518
01:18:36,545 --> 01:18:40,581
然后他们消失。好吧，为什么这些消失？

1519
01:18:40,650 --> 01:18:43,784
那是因为这第二个动画来了

1520
01:18:43,853 --> 01:18:45,719
沿着他们的阿尔法归零，

1521
01:18:45,787 --> 01:18:49,155
在漫长的动画过程中，他们会一路拾起它们

1522
01:18:49,224 --> 01:18:52,326
发生。所以我们真的需要更小心

1523
01:18:52,395 --> 01:18:55,028
特别是这部动画的下半部分，

1524
01:18:55,097 --> 01:18:57,898
我们只在涉及的卡片上工作

1525
01:18:57,967 --> 01:19:01,635
比赛。我们有几种方法可以做到这一点，

1526
01:19:01,704 --> 01:19:05,138
例如在这里我们正在决定我们

1527
01:19:05,207 --> 01:19:08,909
想要做这个动画或不，我们可以确保

1528
01:19:08,978 --> 01:19:12,813
faceUpcardViews计数总是小于2.因为如果

1529
01:19:12,881 --> 01:19:16,951
我们已经有两张配套卡正在扩张，

1530
01:19:17,019 --> 01:19:21,021
长大，那么我们显然无法再匹配。

1531
01:19:21,090 --> 01:19:23,190
所以这将是一种工作，除了

1532
01:19:23,259 --> 01:19:25,625
你可以想象，如果我有一场比赛和

1533
01:19:25,694 --> 01:19:28,395
卡正在扩大，它可能真的想要

1534
01:19:28,464 --> 01:19:32,666
开始在我的下一对工作。所以为了工作，

1535
01:19:32,734 --> 01:19:35,469
我们真的想要这两张匹配的卡片不是真的

1536
01:19:35,538 --> 01:19:39,139
算作面向上的卡。我们可以在这里做到这一点。

1537
01:19:39,207 --> 01:19:42,476
这是我们决定什么是面朝上卡的地方。目前

1538
01:19:42,544 --> 01:19:46,713
这是一张面朝上的卡片，显然没有隐藏起来。

1539
01:19:46,782 --> 01:19:49,449
我们可以在这里稍微加强一点，因为我们

1540
01:19:49,518 --> 01:19:52,786
知道这些正在扩展的卡片要么扩大规模

1541
01:19:52,855 --> 01:19:57,891
到他们的变换3.0，或他们的阿尔法不是1，对不对？

1542
01:19:57,960 --> 01:20:01,395
实际上是0，所以我们可以把这些放在这里。所以

1543
01:20:01,464 --> 01:20:06,266
让我们说一张面朝上的卡也必须有一个转换

1544
01:20:06,335 --> 01:20:11,505
不等于由3.0,3.0缩放的身份转换。

1545
01:20:11,574 --> 01:20:15,742
顺便说一下，你可以看到terror和

1546
01:20:15,811 --> 01:20:19,612
蓝色数字的danger ，因为如果我要改变

1547
01:20:19,681 --> 01:20:22,782
这个数字，忘记在这里改变同样的事情，

1548
01:20:22,851 --> 01:20:25,185
那么这是行不通的。我的动画将会失效

1549
01:20:25,254 --> 01:20:28,088
与我认为是面朝上的卡同步。所以这是

1550
01:20:28,157 --> 01:20:31,158
我们希望创建一个结构体，一个私有结构体和

1551
01:20:31,227 --> 01:20:35,829
使用静态来使它们成为常量。所以我们也想

1552
01:20:35,898 --> 01:20:39,333
确保我们的alpha在这里等于一个，

1553
01:20:39,401 --> 01:20:41,935
换句话说，我们只会考虑卡面朝上

1554
01:20:42,003 --> 01:20:46,006
如果它完全可见。我们需要的最后一件事

1555
01:20:46,074 --> 01:20:50,210
在这里也做，虽然是当我们进入我们的动画，

1556
01:20:50,279 --> 01:20:53,647
注意我们寻找哪些牌面朝上。

1557
01:20:53,716 --> 01:20:57,551
通过调用这张self.face up卡的意见，好吗？

1558
01:20:57,620 --> 01:21:01,221
这就是这件事。这是动态的

1559
01:21:01,290 --> 01:21:04,091
总是计算正面朝上的牌，所以

1560
01:21:04,159 --> 01:21:06,560
如果我们有一个动画在这里，它开始和

1561
01:21:06,629 --> 01:21:09,696
正在进行，然后它试图做它的第二部分，它看起来

1562
01:21:09,764 --> 01:21:12,866
再次面对掉卡。事实上，我们只是想要

1563
01:21:12,935 --> 01:21:16,870
这整个动画适用于原来的两张卡片

1564
01:21:16,938 --> 01:21:20,874
被选中。所以我们可以通过拥有来捕捉它

1565
01:21:20,943 --> 01:21:24,277
一个小的局部变量。在这里，我打算称它为卡片

1566
01:21:24,346 --> 01:21:29,049
使当时的卡片面貌相同

1567
01:21:29,117 --> 01:21:31,552
我们开始动画。好吧，所以我们有点捕捉

1568
01:21:31,620 --> 01:21:34,254
他们在这里。然后通过并使用它。

1569
01:21:34,323 --> 01:21:38,324
所以无论我们在哪里重新查找这些面朝上的卡片

1570
01:21:38,393 --> 01:21:40,127
我们想要使用卡片进行动画制作。所以

1571
01:21:40,196 --> 01:21:44,131
让我们在这里，这一个，这一个，这个，我只是

1572
01:21:44,200 --> 01:21:48,168
在这里搜索并替换所有这些卡进行动画处理。

1573
01:21:48,237 --> 01:21:52,773
所以让我们尝试所有这些，看看它是否成功

1574
01:21:52,841 --> 01:21:57,577
我们不错的获奖动画没有那个

1575
01:21:57,646 --> 01:22:01,681
同样的问题。所以，我必须再次找到我们的比赛，

1576
01:22:01,750 --> 01:22:03,851
哎哟，让我们看看。我们走了，有一场比赛。

1577
01:22:03,919 --> 01:22:06,653
现在我要点击其他卡片并且能够匹配

1578
01:22:06,722 --> 01:22:11,158
他们。而那漫长的动画仍在继续。所以

1579
01:22:11,227 --> 01:22:14,027
这是更好的用户界面。当然，我们不会有

1580
01:22:14,096 --> 01:22:17,698
我们的配对动画需要这么长时间，但通过这样做

1581
01:22:17,766 --> 01:22:20,334
很长时间以来，我们能够找到这个问题。所以让我们来说

1582
01:22:20,403 --> 01:22:25,472
回到原来的样子。我认为我们喜欢.6和

1583
01:22:25,541 --> 01:22:28,475
0.75。让我们再拍一个动画并放慢速度，

1584
01:22:28,543 --> 01:22:30,877
那么卡片不匹配的动画怎么样？

1585
01:22:30,946 --> 01:22:32,679
我们将他们翻转过来？好的，

1586
01:22:32,748 --> 01:22:34,948
这是它翻转过来的动画

1587
01:22:35,017 --> 01:22:37,651
那么这里是翻转两个不匹配的地方

1588
01:22:37,719 --> 01:22:39,520
卡片结束。所以让我们放慢这两点。

1589
01:22:39,588 --> 01:22:43,023
这样下来，放慢这一点。

1590
01:22:46,695 --> 01:22:48,394
这是匹配的动画。

1591
01:22:48,463 --> 01:22:52,599
我想要那里的原始翻转动画。好，如此

1592
01:22:52,668 --> 01:22:54,868
我们点击，好吧我们原来的翻转动画。

1593
01:22:54,937 --> 01:22:57,370
好吧，它真的很慢，没有什么问题。

1594
01:22:57,439 --> 01:23:00,574
让我们尝试另一个变慢的方法。和

1595
01:23:00,642 --> 01:23:02,676
他们都是，好吧。这一切看起来没问题。

1596
01:23:02,745 --> 01:23:05,411
让我们尝试点击更快一点。这个怎么样和

1597
01:23:05,480 --> 01:23:08,581
这个？好吧，他们都放慢了。

1598
01:23:08,650 --> 01:23:11,852
哇，发生了什么事？好吧，那十人发生了什么事，

1599
01:23:11,920 --> 01:23:15,221
那第二张牌？它有点，它没有翻转。

1600
01:23:15,290 --> 01:23:16,990
它有点跳跃，然后飞过来。

1601
01:23:17,059 --> 01:23:18,726
让我们再试一次，看看这里发生了什么。

1602
01:23:18,794 --> 01:23:20,928
让我们试试这一个，这个我们去，

1603
01:23:20,996 --> 01:23:23,796
哇。好的，这里显然有些问题。所以

1604
01:23:23,865 --> 01:23:28,301
这里发生了什么事情使得这张卡变得如此古怪？

1605
01:23:28,370 --> 01:23:31,972
那么，这里发生的是原始卡片

1606
01:23:32,041 --> 01:23:36,309
我们翻了起来，第二张牌都在试图翻转

1607
01:23:36,378 --> 01:23:40,614
两张牌面朝下。好吧，那么这两个转换，

1608
01:23:40,682 --> 01:23:44,083
这两个修改通过转换，

1609
01:23:44,152 --> 01:23:47,320
他们都试图同时在卡上操作。

1610
01:23:47,389 --> 01:23:49,823
当你在转型和转型过程中有一些东西的时候

1611
01:23:49,892 --> 01:23:51,258
另一个变化出现了，

1612
01:23:51,327 --> 01:23:54,561
它基本上搞乱了整个转换。现在，

1613
01:23:54,630 --> 01:23:57,397
这也是一个简单的解决方案，让我们永远

1614
01:23:57,466 --> 01:23:59,933
让所选的最新卡片

1615
01:24:00,001 --> 01:24:03,003
控制动画。这样他们永远不会干涉

1616
01:24:03,072 --> 01:24:05,205
彼此之间，因为当第二个出现时

1617
01:24:05,273 --> 01:24:08,341
选择它可以做动画。所以让我们通过

1618
01:24:08,410 --> 01:24:11,811
只是在这里创造一个小变化，跟踪我们的情况

1619
01:24:11,880 --> 01:24:15,882
最后选择的卡片视图，这将是一个扑克牌视图

1620
01:24:15,951 --> 01:24:19,686
课程。它会从零开始，这很好，因为我们

1621
01:24:19,755 --> 01:24:24,658
当我们开始时没有最后选择的卡片视图。和

1622
01:24:24,726 --> 01:24:27,294
所以每次我们经过并选择一张卡时，

1623
01:24:27,363 --> 01:24:29,529
好的，在这里，这是我们选择卡的地方。

1624
01:24:29,597 --> 01:24:32,932
我们只记得我们的lastChosenCardView =

1625
01:24:33,001 --> 01:24:37,203
chosenCardView。然后当我们到这里来

1626
01:24:37,272 --> 01:24:40,841
他们的动画闭包在这里，我们只会这样做

1627
01:24:40,909 --> 01:24:45,612
如果选择的CardView等于最后选择的卡

1628
01:24:49,551 --> 01:24:54,554
视图。所以，

1629
01:24:54,623 --> 01:24:56,990
这样，这个动画就在这里只能发生，

1630
01:24:57,059 --> 01:24:58,826
只能由最​​后一张牌来控制。

1631
01:24:58,894 --> 01:25:01,161
他们不会互相干扰。所以

1632
01:25:01,230 --> 01:25:04,998
我们需要一个自己的权利，让我们试试这个。

1633
01:25:10,539 --> 01:25:13,940
好的，这是这个，它开始动画，

1634
01:25:14,009 --> 01:25:16,643
开始这一个，它的工作。

1635
01:25:16,711 --> 01:25:18,911
好吧，它让第一个完成其动画和

1636
01:25:18,980 --> 01:25:21,814
那么它没有这样做，没有做翻转和等待

1637
01:25:21,883 --> 01:25:26,353
第二个做到这一点。好吧，这些

1638
01:25:26,422 --> 01:25:29,556
当你调整你的动画时是那种东西，

1639
01:25:29,625 --> 01:25:32,059
减缓它们会帮助你找到这些

1640
01:25:32,127 --> 01:25:34,094
重叠的东西。你可能会想好，

1641
01:25:34,163 --> 01:25:34,961
这些卡片正在翻转

1642
01:25:35,030 --> 01:25:37,430
快速，用户永远无法做到这一点，但

1643
01:25:37,499 --> 01:25:40,701
他们绝对可以。用户倾向于点击，点击，点击，

1644
01:25:40,769 --> 01:25:43,403
点击，点击。糟糕，他们很快点击试试

1645
01:25:43,471 --> 01:25:46,473
让事情发生，所以你想为此做好准备。所以

1646
01:25:46,541 --> 01:25:49,242
我会把这些放回原处。

1647
01:25:49,311 --> 01:25:54,080
我有什么，我不知道，0.5还是

1648
01:25:54,149 --> 01:25:59,653
0.6的东西，类似的东西。

1649
01:26:02,925 --> 01:26:06,025
好吧，在这里，我们有这个人和那个人。

1650
01:26:06,094 --> 01:26:08,495
让我们看看我们是否能在某处找到一场比赛。

1651
01:26:09,865 --> 01:26:14,334
这个。不，在这场比赛中很难找到比赛。

1652
01:26:14,403 --> 01:26:15,368
这是一场相当困难的比赛。

1653
01:26:15,437 --> 01:26:20,440
我发现我并不是很擅长。有

1654
01:26:20,509 --> 01:26:23,210
那个杰克，我认为那里有一个。是的，有一场比赛。

1655
01:26:23,279 --> 01:26:27,681
没有感动。国王在这里？在那里，

1656
01:26:27,750 --> 01:26:31,351
那是俱乐部之王，或黑桃之王。好吧，

1657
01:26:31,420 --> 01:26:35,955
无论如何，我们走了，还有一场比赛。好的，

1658
01:26:36,024 --> 01:26:39,092
我相信这是我有时间向你展示的。我想我已经

1659
01:26:39,161 --> 01:26:41,762
通过大部分我想告诉你的东西，所以你的

1660
01:26:41,830 --> 01:26:44,998
家庭作业只是为了激发你的设定。在非常预先定义

1661
01:26:45,067 --> 01:26:50,404
方法。所以你会使用这三个完全相同的机制。

1662
01:26:50,472 --> 01:26:52,271
转场，视图属性和

1663
01:26:52,340 --> 01:26:55,075
动态动画师。好吧？

1664
01:26:55,143 --> 01:26:57,543
我会在下周见到你。 >>为

1665
01:26:57,612 --> 01:27:07,019
更多，请访问stanford.edu。

