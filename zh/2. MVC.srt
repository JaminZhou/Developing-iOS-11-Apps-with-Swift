1
00:00:00,401 --> 00:00:04,636
[MUSIC]

2
00:00:04,705 --> 00:00:10,375
斯坦福大学。欢迎来到斯坦福CS193P，

3
00:00:10,444 --> 00:00:15,013
为iOS开发应用程序这是第二讲，

4
00:00:15,081 --> 00:00:19,451
所以今天，我要花上第一个15或者

5
00:00:19,520 --> 00:00:22,053
20分钟来谈论Model-View-Controller ，

6
00:00:22,122 --> 00:00:25,790
这个设计范例，我告诉你我们总是要做的

7
00:00:25,859 --> 00:00:29,595
当我们开发的iOS。 >>然后，我们会申请

8
00:00:29,663 --> 00:00:32,964
模型 - 视图 - 控制器到我们的浓度(Concentration)应用程序，所以

9
00:00:33,033 --> 00:00:35,734
你会首先看到这个概念，

10
00:00:35,802 --> 00:00:38,903
那么我们就可以看到它的行动。好吧，

11
00:00:38,972 --> 00:00:42,841
模型 - 视图 - 控制器，它是什么？这本质上是一种方式

12
00:00:42,909 --> 00:00:46,444
我们将把系统中的所有对象分成

13
00:00:46,513 --> 00:00:52,250
三个阵营。这个蓝色阵营的一个阵营就是示范阵营。

14
00:00:52,319 --> 00:00:56,521
这是一个独立于UI的对象集合

15
00:00:56,589 --> 00:01:00,959
你的应用程序是什么？所以对于我们的浓度游戏来说，

16
00:01:01,027 --> 00:01:03,996
我们的应用程序，知道如何发挥浓度的一部分。

17
00:01:04,064 --> 00:01:06,164
它知道如何匹配卡片，把它们拿走，

18
00:01:06,233 --> 00:01:09,033
它知道什么时候翻牌，它知道所有的东西。

19
00:01:09,102 --> 00:01:11,803
这是关于浓度的所有知识

20
00:01:11,872 --> 00:01:15,807
游戏，但没有关于它如何出现在屏幕上。那

21
00:01:15,876 --> 00:01:19,311
是控制员阵营所有责任的一部分。

22
00:01:19,379 --> 00:01:21,747
所以控制器阵营是如何

23
00:01:23,083 --> 00:01:25,984
你的浓度游戏出现在屏幕上。

24
00:01:26,053 --> 00:01:28,587
所以Model就是你的应用程序和

25
00:01:28,655 --> 00:01:31,923
控制器是如何显示在屏幕上。

26
00:01:31,992 --> 00:01:35,994
View阵营是你的控制者的仆从。

27
00:01:36,063 --> 00:01:41,333
这些是非常通用的UI元素，比如UI按钮，

28
00:01:41,402 --> 00:01:45,104
UI视图控制器甚至UI标签。

29
00:01:45,172 --> 00:01:48,173
所有这些通用的东西，UI的东西，

30
00:01:48,241 --> 00:01:52,644
控制器必须与模型进行通信

31
00:01:52,712 --> 00:01:58,149
让你的游戏，无论你的应用程序进入用户界面。

32
00:01:58,218 --> 00:02:02,086
所以视图是控制器的通用部分。所以

33
00:02:02,155 --> 00:02:06,524
这三个阵营。现在，MVC真的是一切

34
00:02:06,593 --> 00:02:09,294
管理这些阵营之间的沟通，对吧？

35
00:02:09,363 --> 00:02:10,628
你把这些物体放在这些营地里，

36
00:02:10,697 --> 00:02:13,598
他们谈话时必须遵守某些规定

37
00:02:13,667 --> 00:02:16,501
对彼此。所以，我在这里画了路标。

38
00:02:16,570 --> 00:02:19,871
你看到那些近似的小路标

39
00:02:19,940 --> 00:02:22,908
各种之间允许什么样的沟通

40
00:02:22,977 --> 00:02:25,943
营。我们来仔细看看。所以

41
00:02:26,012 --> 00:02:28,079
控制员，与模型谈话，

42
00:02:28,148 --> 00:02:31,716
那是完全破碎的白线。

43
00:02:31,785 --> 00:02:35,254
你可以在任何时候越过，大绿箭头。

44
00:02:35,322 --> 00:02:38,022
控制器可以与模型交谈。

45
00:02:38,091 --> 00:02:41,393
它必须能够，因为它是控制器的工作

46
00:02:41,462 --> 00:02:45,563
提出这个东西是给用户的，所以它必须是

47
00:02:45,632 --> 00:02:48,433
能够访问模型。这是一个古老的绿色箭头，

48
00:02:48,502 --> 00:02:51,803
这是控制器与模型交谈。

49
00:02:51,871 --> 00:02:57,609
几乎与模型的无限沟通

50
00:02:57,678 --> 00:03:00,913
公开可用的功能。那这个呢

51
00:03:00,981 --> 00:03:03,815
方向？那么，同样在这里，它的仆从，

52
00:03:03,883 --> 00:03:06,584
控制器必须能够控制它的仆从，所以

53
00:03:06,653 --> 00:03:09,554
这也是一个非常宽敞的绿色箭头，

54
00:03:09,623 --> 00:03:11,689
你已经看到了一个绿色箭头

55
00:03:11,758 --> 00:03:14,225
控制器到我们的集中视图。

56
00:03:14,294 --> 00:03:17,162
这被称为出口(outlet)。我们有一个outlet

57
00:03:17,230 --> 00:03:19,964
计数标签，当然，我们可以谈谈倒计数

58
00:03:20,033 --> 00:03:23,067
标签，并说出我们想要的任何东西，让它说出我们的

59
00:03:23,136 --> 00:03:26,037
想要在UI中。这是财务主任的特权。

60
00:03:26,106 --> 00:03:28,673
所以你可以看到控制器可以和每个人交谈

61
00:03:28,742 --> 00:03:31,977
几乎所有的一次。那么其他一些呢？

62
00:03:32,046 --> 00:03:34,612
沟通？怎么样模型说话

63
00:03:34,681 --> 00:03:39,250
直接到视图？好的，那几乎是不可能的。

64
00:03:39,319 --> 00:03:41,153
为什么这是不可能的？两个原因。

65
00:03:41,221 --> 00:03:44,989
其中一个，模型是UI独立的，只有视图

66
00:03:45,058 --> 00:03:47,793
有UI的东西，所以绝对没有办法的用户界面

67
00:03:47,861 --> 00:03:51,496
独立的事情可以谈论这样的UI依赖的东西

68
00:03:51,564 --> 00:03:54,866
像视图。另一个原因是这些查看的东西

69
00:03:54,935 --> 00:03:58,603
是通用对象，如按钮或滑块。怎么可能

70
00:03:58,672 --> 00:04:01,939
一个按钮有什么想法集中游戏是关于什么？

71
00:04:02,008 --> 00:04:04,075
没门。没有办法知道这是通用的。

72
00:04:04,144 --> 00:04:06,578
所以如果这些之间没有任何交流的话

73
00:04:06,646 --> 00:04:09,113
两个，我不想看到你有任何交流

74
00:04:09,182 --> 00:04:11,516
在你的家庭作业或任何的这些营地之间。

75
00:04:11,585 --> 00:04:13,318
这就是为什么这是一个双黄线。

76
00:04:13,387 --> 00:04:16,755
没有交叉。好的，那很简单。关于什么

77
00:04:16,823 --> 00:04:20,158
该视图回话控制器？这可能是

78
00:04:20,226 --> 00:04:25,029
这里最有趣的沟通途径。

79
00:04:25,098 --> 00:04:28,099
视图可以与其控制器交谈，当然，

80
00:04:28,168 --> 00:04:31,602
它有点类似于当按钮被点击或者什么的时候，

81
00:04:31,671 --> 00:04:33,204
但是当它通信时，

82
00:04:33,273 --> 00:04:36,608
这种沟通必须是盲目的和结构化的。它

83
00:04:36,676 --> 00:04:40,145
必须是盲目的，因为这些是通用的视图对象。

84
00:04:40,213 --> 00:04:43,014
用户界面按钮不知道任何关于浓度

85
00:04:43,082 --> 00:04:46,050
游戏控制器，所以当它与控制器通话时，

86
00:04:46,119 --> 00:04:48,252
它并不真的知道这是一个集中游戏

87
00:04:48,321 --> 00:04:50,488
控制器，它的结构

88
00:04:50,557 --> 00:04:52,857
既然我们要进行这个沟通

89
00:04:52,926 --> 00:04:56,294
一个通用的对象必须先思考如何

90
00:04:56,363 --> 00:05:00,232
它可能想与这个Controller对象进行通信。

91
00:05:00,300 --> 00:05:03,067
所以，你已经知道一个结构化的，盲目的方式

92
00:05:03,136 --> 00:05:06,471
你的观点进行交流，这是目标行动。

93
00:05:06,540 --> 00:05:09,607
当我们按Ctrl拖动并创建方法touchCard时。

94
00:05:09,676 --> 00:05:12,344
这是目标行动。而所有的控制器必须做的是

95
00:05:12,412 --> 00:05:16,081
有点挂在自己的目标。这就是说，它创造

96
00:05:16,150 --> 00:05:19,518
像触摸卡片的方法。然后用户界面按钮和

97
00:05:19,586 --> 00:05:21,453
其他的事情，他们可以得到这个动作，而且

98
00:05:21,521 --> 00:05:22,887
每次按下按钮，

99
00:05:22,956 --> 00:05:25,723
他们只是叫目标(target)。这是一个非常，

100
00:05:25,792 --> 00:05:30,162
非常简单的一种盲人结构沟通。但

101
00:05:30,230 --> 00:05:33,165
有时你需要更复杂的沟通，

102
00:05:33,233 --> 00:05:35,867
就像你有一个更复杂的通用视图

103
00:05:35,936 --> 00:05:39,103
项目像，让我们说一个滚动视图。滚动视图是

104
00:05:39,172 --> 00:05:42,407
在一些图像或类似的东西上滚动，以及

105
00:05:42,476 --> 00:05:44,409
它可能需要告诉控制器，

106
00:05:44,477 --> 00:05:48,513
我滚动到最后。我可以在这里滚动吗？

107
00:05:48,582 --> 00:05:50,415
我可以垂直滚动还是水平滚动？

108
00:05:50,483 --> 00:05:53,084
它有点想和Controller交谈

109
00:05:53,152 --> 00:05:57,255
努力工作。我们用这样的方式来做到这一点

110
00:05:57,324 --> 00:06:00,992
滚动视图定义为其一部分的预定义方法

111
00:06:01,061 --> 00:06:06,130
所谓的代表。所以它的代表只是一个变种

112
00:06:06,199 --> 00:06:11,036
滚动查看，并且这个var将会有一些对象在里面。

113
00:06:11,104 --> 00:06:13,872
而我们所知道的这个对象就是它的反应

114
00:06:13,941 --> 00:06:16,441
一定数量的消息。大部分这些消息

115
00:06:16,510 --> 00:06:18,710
开始的话会，应该，或做的。

116
00:06:18,778 --> 00:06:21,979
比如，我会滚动到这里，我应该在这里滚动吗？一世

117
00:06:22,048 --> 00:06:26,585
没有向下滚动到这里。这些都是经典的委托方法。

118
00:06:26,653 --> 00:06:29,687
而控制器使用称为协议的机制，

119
00:06:29,756 --> 00:06:31,455
我们将在下周谈论，

120
00:06:31,524 --> 00:06:33,458
能够告诉滚动视图，

121
00:06:33,527 --> 00:06:36,528
我是你的委托，所有的滚动视图将知道

122
00:06:36,596 --> 00:06:38,562
是它实现了这些意志，应该和做的。

123
00:06:38,631 --> 00:06:40,966
它对此一无所知。它不知道它的类，

124
00:06:41,034 --> 00:06:43,568
不知道这是与浓度游戏有关

125
00:06:43,637 --> 00:06:46,170
显然，它一无所知。它只是知道这一点

126
00:06:46,239 --> 00:06:48,506
控制器将执行。所以

127
00:06:48,575 --> 00:06:52,043
我们将在开始使用的两周内看到代表团

128
00:06:52,111 --> 00:06:56,214
更复杂的UI对象。现在，另一件重要的事情

129
00:06:56,283 --> 00:06:58,717
要记住在MVC模型中是这样的视图，

130
00:06:58,785 --> 00:07:00,085
这些通用的东西，

131
00:07:00,153 --> 00:07:03,388
不能拥有他们正在显示的数据。换一种说法，

132
00:07:03,456 --> 00:07:06,157
他们不会有他们显示的数据

133
00:07:06,225 --> 00:07:09,460
他们的实例变量的一部分。那为什么呢？

134
00:07:09,529 --> 00:07:13,064
那么，想象一下，视图显示你的整个iPod音乐

135
00:07:13,133 --> 00:07:17,268
图书馆。假设你有5万首歌

136
00:07:17,337 --> 00:07:20,471
没有办法，那绝对没有意义

137
00:07:20,540 --> 00:07:23,475
列表视图或其他东西，一些通用视图列出

138
00:07:23,543 --> 00:07:27,345
把所有这些东西都放在里面所以

139
00:07:27,413 --> 00:07:30,648
相反，它使用这种相同的协议机制

140
00:07:30,717 --> 00:07:32,984
有另一套特殊的信息，

141
00:07:33,052 --> 00:07:36,353
他们是像数据的消息，给我的数据，或

142
00:07:36,422 --> 00:07:39,891
那里有多少物品？控制器实现了这一点

143
00:07:39,960 --> 00:07:43,628
所以我们可以与模型交谈，并获取视图的数据。

144
00:07:43,697 --> 00:07:47,832
所以，例如，表格视图，这是一个大的滚动列表

145
00:07:47,901 --> 00:07:51,269
通用视图项目，这是在iOS中。

146
00:07:51,338 --> 00:07:53,671
当你在所有的iPad音乐上滚动时，

147
00:07:53,740 --> 00:07:56,441
它只是要求它正在显示的那些。对，

148
00:07:56,510 --> 00:07:58,576
有五万。它只是滚动到

149
00:07:58,645 --> 00:08:00,978
一次显示10个。所以这只是问

150
00:08:01,047 --> 00:08:02,446
管理员给我下十个，

151
00:08:02,515 --> 00:08:03,848
给我这里的十个，和

152
00:08:03,917 --> 00:08:05,549
控制器转向模型，

153
00:08:05,618 --> 00:08:08,586
这可能是一个不错的快速SQL数据库什么的，和

154
00:08:08,655 --> 00:08:11,489
抓取数据，并将其传递给视图。好的，和

155
00:08:11,558 --> 00:08:14,259
这使用相同的机制再次在表中查看

156
00:08:14,327 --> 00:08:16,894
不知道任何关于这是一个iPod

157
00:08:16,963 --> 00:08:20,364
音乐应用程序，它只是知道它是数据提供者，而且

158
00:08:20,433 --> 00:08:24,202
我们把这种委托称为数据源。好，那么

159
00:08:24,271 --> 00:08:26,637
你也会看到这个数据源和委托，

160
00:08:26,706 --> 00:08:29,207
非常相似，它只是一种不同的方法，

161
00:08:29,276 --> 00:08:32,076
而这些方法当然依赖于那种

162
00:08:32,145 --> 00:08:36,114
的UI元素，他们不是一个预设列表，取决于什么

163
00:08:36,182 --> 00:08:39,917
继续在该UI元素。这就是那种

164
00:08:39,986 --> 00:08:42,920
通信视图可以和控制器有关，

165
00:08:42,989 --> 00:08:46,625
它是结构化的，它是一种预定义的东西。

166
00:08:46,693 --> 00:08:49,894
因为所有这些沟通都在这里进行

167
00:08:49,962 --> 00:08:53,164
我们说MVC中的控制器的工作是

168
00:08:53,232 --> 00:08:56,500
解释和格式化模型信息

169
00:08:56,569 --> 00:08:59,203
风景。这是它的主要目的。

170
00:08:59,272 --> 00:09:01,239
它也有另一种方式，

171
00:09:01,307 --> 00:09:04,742
它将解释模型视图中的用户交互。

172
00:09:04,811 --> 00:09:06,344
这是来回翻译。

173
00:09:06,413 --> 00:09:11,382
这是所有交流的中心。

174
00:09:11,451 --> 00:09:14,585
模型呢？模型可以跟其控制器交谈吗？

175
00:09:14,654 --> 00:09:19,623
显然不是直接的。因为模型是UI

176
00:09:19,692 --> 00:09:23,094
独立和控制器从根本上取决于UI，

177
00:09:23,162 --> 00:09:25,830
所以不能直接做。但有一个机制

178
00:09:25,899 --> 00:09:29,167
例如，如果某些数据发生变化，则以模型进行通信

179
00:09:29,235 --> 00:09:32,036
它希望任何有兴趣的用户界面

180
00:09:32,105 --> 00:09:36,007
更新。而这样做的方式是与我的模型

181
00:09:36,076 --> 00:09:39,277
呼叫广播电台模式，以及模式

182
00:09:39,346 --> 00:09:42,113
开始在某个已知的广播电台上播出。

183
00:09:42,182 --> 00:09:46,117
而那里的控制器，它只是调整和

184
00:09:46,185 --> 00:09:49,186
当它听到模型收音机上的某些东西的改变

185
00:09:49,255 --> 00:09:51,689
那么它会使用它的大绿箭头，

186
00:09:51,758 --> 00:09:54,025
去谈谈模型，并获得变化的日期，或

187
00:09:54,093 --> 00:09:57,161
随你。所以这是一个电台模式。在iOS中

188
00:09:57,230 --> 00:10:01,399
它被称为通知，或KVO，关键值观察，和

189
00:10:01,468 --> 00:10:05,103
我们也会在几周内讨论这些问题。所以有

190
00:10:05,172 --> 00:10:08,405
哇，从模型到广播的一种方式

191
00:10:08,474 --> 00:10:13,544
正在改变。现在有人问可不可以收看

192
00:10:13,613 --> 00:10:16,748
到一个电台？一个视图只能真正调入

193
00:10:16,816 --> 00:10:19,918
一个控制器或电台像另一个UI的事情，因为

194
00:10:19,986 --> 00:10:23,187
一个视图是用户界面的基础，但即使这是非常罕见的。

195
00:10:23,256 --> 00:10:24,722
通常广播电台是非常重要的

196
00:10:24,791 --> 00:10:27,892
这个模型来沟通你的事情正在发生

197
00:10:27,961 --> 00:10:35,099
数据或其他。这个MVC是MVC的集合

198
00:10:35,168 --> 00:10:39,437
一般只用来控制iPhone上的一个屏幕，或者

199
00:10:39,506 --> 00:10:42,941
在iPad上。也许它可以控制一些小的地方，

200
00:10:43,009 --> 00:10:46,344
就像在iPad上，也许一个MVC控制一个空间，

201
00:10:46,413 --> 00:10:49,046
另一个MVC控制着另一个地方，而且

202
00:10:49,115 --> 00:10:52,050
可能有第三个MVC控制另一个空间，但是

203
00:10:52,118 --> 00:10:55,453
你永远不会有一个以上的屏幕，在iPhone中，

204
00:10:55,521 --> 00:10:59,557
由单个MVC控制。所以MVC就是这样

205
00:10:59,625 --> 00:11:03,394
一组UI。通常一个屏幕，一个iPhone屏幕

206
00:11:03,463 --> 00:11:07,731
大小值得的东西。所以大多数应用程序都有很多屏幕。

207
00:11:07,800 --> 00:11:10,735
你有你的设置，你有所有不同的功能

208
00:11:10,804 --> 00:11:13,405
你的应用程序，吨和大量的屏幕正在进行。所以

209
00:11:13,473 --> 00:11:16,641
我们如何从多个MVC构建应用程序？

210
00:11:18,311 --> 00:11:22,913
多个MVC应用程序看起来像这样。我有一堆MVC

211
00:11:22,982 --> 00:11:25,082
直立。所有这些紫色的东西

212
00:11:25,151 --> 00:11:29,120
是所有的控制器，当一个MVC想要互动

213
00:11:29,189 --> 00:11:33,124
与另一个MVC就在这里，你看到这里，

214
00:11:33,192 --> 00:11:36,961
它总是把那些其他的MVC视为其一部分。所以

215
00:11:37,030 --> 00:11:41,866
这三个MVC是这个MVC的一部分。

216
00:11:43,402 --> 00:11:46,804
所以必须以一种盲目而有条理的方式与他们交谈。

217
00:11:46,873 --> 00:11:51,108
这些类似于通用的可重用组件的行为，

218
00:11:51,177 --> 00:11:54,278
我们将看到我们如何运作

219
00:11:54,347 --> 00:11:58,950
从星期一开始谈论多个MVC应用程序。

220
00:11:59,018 --> 00:12:02,019
现在我们要在这里做的主要事情不是建立我们的

221
00:12:02,088 --> 00:12:05,222
像这样的多个MVC应用程序，只有绿色

222
00:12:05,291 --> 00:12:08,993
箭头可以四处，而我们不想要这个的原因，

223
00:12:09,061 --> 00:12:12,463
这是不可能的调试和发现是怎么回事

224
00:12:12,532 --> 00:12:15,733
在我们的应用程序里面，因为如果UI中的东西发生变化

225
00:12:15,802 --> 00:12:18,536
我们不知道哪个控制器正在做，或者

226
00:12:18,604 --> 00:12:22,473
什么模型给了数据。我们完全失去了。所以通过

227
00:12:22,542 --> 00:12:25,543
将他们分组到这些不错的MVC上，每个屏幕在手机上

228
00:12:25,612 --> 00:12:29,013
是非常好的包容和可以理解的，可调试的，

229
00:12:29,081 --> 00:12:34,051
管理。每个人都得到了这一切？所以我们

230
00:12:34,120 --> 00:12:38,956
不要这样做这不是这样做的。

231
00:12:39,025 --> 00:12:40,725
好吧，我要做的演示。

232
00:12:40,794 --> 00:12:42,260
我们将要做我们的集中游戏。

233
00:12:42,328 --> 00:12:43,761
我只是要创建模型和

234
00:12:43,830 --> 00:12:45,396
我们会把模型挂上去。

235
00:12:45,464 --> 00:12:47,331
一路上我们将​​学习所有这些其他的东西。

236
00:12:47,400 --> 00:12:50,635
再次，这是一个幻灯片，你看演示后，看看

237
00:12:50,704 --> 00:12:52,336
确定你学习这些东西。

238
00:12:52,405 --> 00:12:54,238
我不会回到幻灯片。所以再一次，

239
00:12:54,307 --> 00:12:57,909
怎么回事，不要忘了周五11:30分，

240
00:12:57,977 --> 00:13:00,911
星期五，关于Xcode和调试，然后在下周

241
00:13:00,980 --> 00:13:04,014
我们将讨论Swift和其他一些iOS的东西

242
00:13:04,083 --> 00:13:06,750
我们要用浓度应用程序来完成

243
00:13:06,819 --> 00:13:08,453
有点像我们的演示地。

244
00:13:08,521 --> 00:13:10,454
我会告诉你，谈谈你的事情，一些幻灯片，

245
00:13:10,523 --> 00:13:11,722
然后我们去浓度。

246
00:13:11,791 --> 00:13:16,827
我会告诉你它实际上看起来如何。好的，我们来了，

247
00:13:16,896 --> 00:13:21,265
回到我们星期一结束的时候。我们有

248
00:13:21,333 --> 00:13:24,301
我们的视图控制器。我们已经准备好了

249
00:13:24,370 --> 00:13:29,339
的MVC。就在这里，在这个故事板上，那是我们的V，

250
00:13:29,408 --> 00:13:33,644
我们的视图，就在这里，这是我们的控制器。好的，

251
00:13:33,713 --> 00:13:35,879
所以这是我们的控制者，这是我们的看法。

252
00:13:35,948 --> 00:13:40,084
所以我们需要M，所以我们现在就去做M吧。所以

253
00:13:40,153 --> 00:13:44,689
我们如何创建一个新的类或Xcode中的任何东西。

254
00:13:44,757 --> 00:13:48,893
我们去文件>新>文件。这就是你如何创建一个新的

255
00:13:48,961 --> 00:13:51,596
Swift文件，或者其他什么，当你这样做的时候，就会发生

256
00:13:51,664 --> 00:13:55,232
为您提供许多不同种类的iOS文件，

257
00:13:55,301 --> 00:13:57,869
但真的这是最有趣的两个。

258
00:13:57,938 --> 00:14:00,405
这是如果你想创建一个子类

259
00:14:00,473 --> 00:14:03,674
一个iOS类的Coco Touch类，就像其子类一样

260
00:14:03,743 --> 00:14:06,077
另一个视图控制器或类似的东西。

261
00:14:06,145 --> 00:14:09,313
但是在这里我们正在谈论模型，非UI，所以

262
00:14:09,382 --> 00:14:14,051
我们将选择一个空白的，完全空白的Swift文件。

263
00:14:14,120 --> 00:14:18,789
这是问名称，我们总是命名我们的文件

264
00:14:18,858 --> 00:14:21,959
正在Swift中创建。我们把它命名为最多

265
00:14:22,028 --> 00:14:25,797
重要的课程将在该文件中。现在我要去

266
00:14:25,865 --> 00:14:28,866
调用给我的模型，我的主模型类，浓度，

267
00:14:28,935 --> 00:14:31,536
因为它是实现游戏的东西

268
00:14:31,604 --> 00:14:34,939
浓度，所以它值得浓度的名称，所以

269
00:14:35,007 --> 00:14:38,275
这就是我要称之为的。顺便说一句，我不会

270
00:14:38,344 --> 00:14:41,512
把它，你看到这个组，这是最顶层的项目，

271
00:14:41,581 --> 00:14:44,382
你真的想把它放在一个层次的文件夹下。

272
00:14:44,451 --> 00:14:46,717
这是你的视图控制器所在的文件夹

273
00:14:46,786 --> 00:14:48,653
一个比在顶层更好的地方。

274
00:14:48,722 --> 00:14:50,254
如果你把它放在顶层，它会起作用的

275
00:14:50,323 --> 00:14:53,324
把它放在这里看起来更好。好吧

276
00:14:53,392 --> 00:14:56,393
我要创建这个Swift文件，它为我们创建。

277
00:14:56,462 --> 00:14:59,229
在这里完整的屏幕。注意，它说的是

278
00:14:59,298 --> 00:15:04,001
进口基金会。不导入UI工具包。这不是一个UI文件。

279
00:15:04,070 --> 00:15:06,503
这是一个独立于UI的模型。

280
00:15:06,572 --> 00:15:07,871
所以我要在这里上课。

281
00:15:07,940 --> 00:15:17,014
我将把它称为浓度。浓度。

282
00:15:17,083 --> 00:15:21,052
好的，在我的类里，当我建立一个新的类，

283
00:15:21,120 --> 00:15:24,855
我总是想考虑一下它的公共API是什么。

284
00:15:24,924 --> 00:15:28,126
有多少人知道短语API是什么意思？

285
00:15:28,194 --> 00:15:30,895
好吧，几乎没有人，好吧。所以，API代表

286
00:15:30,964 --> 00:15:34,098
应用程序编程接口。这只是一个列表

287
00:15:34,166 --> 00:15:37,668
该类中的所有方法和实例变量

288
00:15:37,736 --> 00:15:41,239
公共API是所有的实例变量和方法

289
00:15:41,307 --> 00:15:44,975
你打算让其他班级打电话。所以就是

290
00:15:45,044 --> 00:15:47,912
基本上你如何使用这个课程，下个星期我们会

291
00:15:47,981 --> 00:15:50,648
谈谈你是如何将事物私有的

292
00:15:50,717 --> 00:15:53,918
公众，但今天我们不会为此担心，但是

293
00:15:53,986 --> 00:15:56,420
我将基本上设计我的公共API。

294
00:15:56,489 --> 00:16:01,159
现在，为什么当我设计我的变量和funcs的时候呢

295
00:16:01,227 --> 00:16:04,461
蝙蝠在这里，而原因是因为做到了我有

296
00:16:04,530 --> 00:16:07,965
以获得这件事情是什么的基本要素

297
00:16:08,034 --> 00:16:09,633
人们将如何使用它。和

298
00:16:09,702 --> 00:16:12,703
当我进入我的设计时，这让我清楚地思考。所以

299
00:16:12,772 --> 00:16:13,738
我建议这样做

300
00:16:13,806 --> 00:16:17,741
任何你设计的课程。所以一个集中游戏。

301
00:16:17,810 --> 00:16:20,845
请记住，我们在这里呢？它的要点是什么？

302
00:16:20,914 --> 00:16:25,049
那么一个重要的是它有一些卡。那张牌，

303
00:16:25,117 --> 00:16:28,986
这些卡是卡片或其他东西的数组，

304
00:16:29,055 --> 00:16:34,024
不太清楚什么是某种数组卡。所以，

305
00:16:34,093 --> 00:16:36,093
这是集中游戏的基本部分

306
00:16:36,162 --> 00:16:40,564
当然。那么，你可以在浓度游戏中做什么？

307
00:16:40,633 --> 00:16:43,834
你被允许作为一个用户做的唯一的事情是

308
00:16:43,902 --> 00:16:46,337
翻转卡片，对，选择卡片。这就是你

309
00:16:46,405 --> 00:16:48,706
可以真的选择卡片。所有的匹配和

310
00:16:48,775 --> 00:16:51,041
所有这些东西都是内部实现的

311
00:16:51,110 --> 00:16:54,178
浓度游戏。从用户的角度来看，

312
00:16:54,246 --> 00:16:56,780
你只是在触摸它。所以我需要一些func

313
00:16:56,849 --> 00:17:00,050
让我选择一张卡。好的，和

314
00:17:00,119 --> 00:17:03,421
这个论点可以是一张卡片，也可以是一张卡片

315
00:17:03,489 --> 00:17:06,557
这个东西是我们要在一秒钟内定义的，但是

316
00:17:06,626 --> 00:17:09,627
我实际上会让它更灵活一些，

317
00:17:09,696 --> 00:17:13,231
我要把它作为这个数组的索引。所以，当你

318
00:17:13,299 --> 00:17:15,766
选择一张卡片，我会让你选择索引

319
00:17:15,834 --> 00:17:18,336
这只是为了更加灵活的不同

320
00:17:18,405 --> 00:17:20,437
各种可能想要这样做的用户界面。

321
00:17:20,506 --> 00:17:23,240
他们可能是基于索引的。这真的不是那么大

322
00:17:23,309 --> 00:17:25,809
一个交易因为你总是可以在这里查找索引

323
00:17:25,878 --> 00:17:26,711
所有的时间数组。

324
00:17:26,779 --> 00:17:30,648
但是对一个数组和下标稍微简单一些

325
00:17:30,717 --> 00:17:32,183
找到的东西，而不是去相反的方向，

326
00:17:32,251 --> 00:17:36,787
像我们上次做的那样做索引。所以就是这样。

327
00:17:36,855 --> 00:17:40,157
这就是全部，这是整个公共API

328
00:17:40,226 --> 00:17:42,659
我的集中游戏。不能更简单。

329
00:17:42,728 --> 00:17:45,763
现在唯一的一件事是我们必须定义Mr.Card。所以

330
00:17:45,832 --> 00:17:51,302
我们要去file> new>文件并创建另一个Swift文件。

331
00:17:51,371 --> 00:17:54,205
这一个我要调用卡片。好的，

332
00:17:54,273 --> 00:17:56,340
把它放在和其他地方一样的地方。

333
00:17:58,111 --> 00:18:00,577
好吧，这不是一个UI的事情。

334
00:18:00,646 --> 00:18:03,181
这是我的模型的一部分。所以我在模型中有两件事。

335
00:18:03,249 --> 00:18:05,749
在这张卡上的浓度游戏。真是的

336
00:18:05,818 --> 00:18:10,154
这里有趣的是我要使卡成为一个结构。

337
00:18:11,824 --> 00:18:16,894
不是类。现在有什么区别

338
00:18:16,963 --> 00:18:20,564
结构体和类之间？让我们继续

339
00:18:20,633 --> 00:18:22,999
同时把注意力集中在这里。

340
00:18:23,068 --> 00:18:28,872
可以在这里使用我的手动的东西我们在左边有卡

341
00:18:28,941 --> 00:18:32,543
结构体在右边。一个是类，一个是结构。现在

342
00:18:32,612 --> 00:18:35,379
在像C这样的其他语言中，一个结构体就是有点儿了

343
00:18:35,447 --> 00:18:39,016
这个小东西包含了一点数据。

344
00:18:39,084 --> 00:18:41,552
这没什么大不了的，但在Swift中，

345
00:18:41,621 --> 00:18:44,322
结构和类几乎完全一样。

346
00:18:44,390 --> 00:18:48,291
他们有方法，他们有bars，非常非常相似。所以

347
00:18:48,360 --> 00:18:49,860
两者有什么区别？

348
00:18:49,929 --> 00:18:52,529
有两个主要的区别。有一些小事

349
00:18:52,598 --> 00:18:54,231
当我们走到这里时，我们会遇到的差异，但是

350
00:18:54,300 --> 00:18:56,400
结构和类之间有两个主要的区别。

351
00:18:56,469 --> 00:18:59,770
了解这一点非常重要。

352
00:18:59,839 --> 00:19:02,606
第一，结构，没有继承。

353
00:19:02,675 --> 00:19:05,042
所以你在结构体中没有继承关系，使得结构体

354
00:19:05,111 --> 00:19:07,211
简单一点。因为如果你有继承，你有

355
00:19:07,280 --> 00:19:09,212
有点担心所有你继承的东西

356
00:19:09,281 --> 00:19:11,848
这可能意味着什么。该结构没有继承

357
00:19:11,917 --> 00:19:15,453
所以比上课简单一点。第二，和

358
00:19:15,521 --> 00:19:19,956
最重要的区别是结构是有价值的

359
00:19:20,025 --> 00:19:24,061
类型和类是引用类型。

360
00:19:24,129 --> 00:19:27,097
那是什么意思？值类型，

361
00:19:27,166 --> 00:19:30,267
当你把它作为参数传递时，把它放在一个数组中，

362
00:19:30,336 --> 00:19:33,938
即使将其分配给另一个变量，它也会被复制。

363
00:19:35,441 --> 00:19:38,042
这是非常重要的理解。它被复制。

364
00:19:38,111 --> 00:19:40,210
为什么这么重要，你明白这一点？

365
00:19:40,279 --> 00:19:42,179
你为什么不避免结构体？

366
00:19:42,248 --> 00:19:44,114
因为你不能避免在iOS中的结构体。

367
00:19:44,183 --> 00:19:48,218
数组是结构体，整数是结构体，字符串是结构体，

368
00:19:48,287 --> 00:19:50,921
字典是结构体，这些都是结构体。

369
00:19:50,990 --> 00:19:52,490
当你在代码中传递它们时，

370
00:19:52,558 --> 00:19:54,625
他们不断复制。

371
00:19:54,694 --> 00:19:56,560
现在你可能有点儿，等一下，

372
00:19:56,629 --> 00:20:00,097
这将是非常低效的。不，因为Swift

373
00:20:00,165 --> 00:20:03,133
当它传递这些东西的时候是超级聪明的。

374
00:20:03,202 --> 00:20:05,735
它不会复制所有东西的所有部分

375
00:20:05,804 --> 00:20:08,872
当你通过它的数组。它以某种方式传递给它

376
00:20:08,941 --> 00:20:11,609
只有在有人的时候才能制作副本，实际副本

377
00:20:11,677 --> 00:20:15,413
修改它。这就是所谓的copy-on-write语义，和

378
00:20:15,481 --> 00:20:17,982
这就是Swift实现这些值类型的方式。

379
00:20:18,050 --> 00:20:21,685
所以结构是价值类型。类是引用类型。

380
00:20:21,754 --> 00:20:22,886
什么是参考类型？

381
00:20:22,955 --> 00:20:25,156
这就是你习惯于其他语言。

382
00:20:25,224 --> 00:20:28,325
这东西住在堆里。你有指向它。什么时候

383
00:20:28,393 --> 00:20:31,028
你把它传递出去，你没有把事情传递出去。

384
00:20:31,097 --> 00:20:32,329
你只是通过指针。

385
00:20:32,398 --> 00:20:35,299
所以你可能有一大堆的代码

386
00:20:35,368 --> 00:20:38,001
有指向同一个对象的指针。所以

387
00:20:38,070 --> 00:20:39,503
你看到那里的区别？

388
00:20:39,572 --> 00:20:42,373
所以，结构会采取一些习惯，因为

389
00:20:42,442 --> 00:20:43,908
你不习惯当你通过的东西，

390
00:20:43,977 --> 00:20:46,377
它做一个副本。但你会看到

391
00:20:46,445 --> 00:20:49,613
它提供了一个真正的语义，你真的可以

392
00:20:49,682 --> 00:20:52,249
使用你的优势。我们甚至会在这里看到

393
00:20:52,318 --> 00:20:55,586
在我们的例子中以小的方式，但你一定会开始

394
00:20:55,655 --> 00:20:57,721
当你开始使用数组和字典的时候看到它，

395
00:20:57,790 --> 00:21:02,226
这样的东西。好的，结构体，卡在这里

396
00:21:02,294 --> 00:21:03,894
一张卡片需要什么？

397
00:21:03,962 --> 00:21:06,530
同样的事情，让我们来思考它的要领。

398
00:21:06,599 --> 00:21:10,100
当然，一张牌可以是正面朝上，也可以不是正面朝上

399
00:21:10,169 --> 00:21:12,669
它可能总是开始面向下，让我们说。

400
00:21:12,738 --> 00:21:17,808
一张卡可以匹配或不匹配，大概是从头开始的

401
00:21:17,876 --> 00:21:21,545
无法比拟的。你知道一张卡也需要一个独特的身份。

402
00:21:21,614 --> 00:21:23,581
因为我们正在玩匹配的游戏，如果我们不能

403
00:21:23,649 --> 00:21:26,083
告诉卡的身份，我们不能匹配它

404
00:21:26,151 --> 00:21:29,286
另一张牌。所以我们需要某种标识符或

405
00:21:29,355 --> 00:21:31,321
东西，这可能是任何类型的。

406
00:21:31,390 --> 00:21:32,990
这可能是一个字符串或其他。我会做的

407
00:21:33,059 --> 00:21:36,993
一个Int，因为它很容易做出一个独特的Int。

408
00:21:37,062 --> 00:21:38,662
所以我们绝对需要这个现在，

409
00:21:38,731 --> 00:21:40,097
有些人可能会想，哦，

410
00:21:40,166 --> 00:21:44,134
好吧，一张卡也需要它的表情符号。

411
00:21:44,203 --> 00:21:47,838
像南瓜或鬼。而且非常重要的是，

412
00:21:47,907 --> 00:21:53,343
不，不。这张卡与用户界面无关。

413
00:21:53,412 --> 00:21:56,714
所以没有办法可以有emojis或jpeg图像或

414
00:21:56,782 --> 00:21:59,617
类似的东西，这就是你如何显示卡。

415
00:21:59,685 --> 00:22:02,886
这就是游戏卡的行为方式，游戏的运作方式。所以

416
00:22:02,955 --> 00:22:05,722
在这个模型里，你永远不会有一个表情符号。我们

417
00:22:05,791 --> 00:22:09,226
在这里的模型不是UI。非常重要的理解。

418
00:22:10,862 --> 00:22:15,966
好吧，现在我们已经基本上掌握了所有的API和

419
00:22:16,035 --> 00:22:18,636
我们的模型在这里让我们摆脱一些这些错误。你看

420
00:22:18,704 --> 00:22:21,371
我们还有这个错误类集中没有

421
00:22:21,440 --> 00:22:23,740
初始化器，这是我们习惯的一个非常常见的错误。

422
00:22:23,809 --> 00:22:27,144
那是因为这个var从来没有被初始化，所以

423
00:22:27,213 --> 00:22:30,514
我们如何创建一系列卡片，好吗？

424
00:22:30,582 --> 00:22:33,483
所以现在你正在学习如何创建一个实例

425
00:22:33,552 --> 00:22:35,919
一个结构或一个类的。完全一样。

426
00:22:35,988 --> 00:22:39,456
而我们这样做的方式就是说要相等

427
00:22:39,525 --> 00:22:41,759
左括号，右括号。

428
00:22:41,827 --> 00:22:45,229
所以这只是一个类型。它可以是int或者string。

429
00:22:45,297 --> 00:22:47,865
这恰好是一系列的卡片。而我只是放在

430
00:22:47,933 --> 00:22:50,133
打开括号，在括号后加上括号。和

431
00:22:50,202 --> 00:22:53,904
其实我可以在这里提出各种各样的参数。和

432
00:22:53,973 --> 00:22:56,674
这些对应于我告诉你的整数

433
00:22:56,742 --> 00:22:59,410
关于。还记得上次，我说班上可以有

434
00:22:59,478 --> 00:23:01,578
一个初始化器，它是一个特殊的方法，

435
00:23:01,647 --> 00:23:03,446
它可以有任何你想要的参数。

436
00:23:03,515 --> 00:23:08,084
你可以有多个在其中。数组有一个与它

437
00:23:08,153 --> 00:23:11,855
没有参数，它是做什么，它创建一个空的数组。

438
00:23:11,924 --> 00:23:14,324
所以这个数组是存在的，但是里面没有卡片。

439
00:23:14,393 --> 00:23:17,427
没有什么。还有其他的，你可以去看看

440
00:23:17,496 --> 00:23:19,863
在文档中，用于数组的其他入口。

441
00:23:19,931 --> 00:23:23,434
它有一个它，例如，让我们为你预留容量

442
00:23:23,502 --> 00:23:25,435
如果你是一个性能的原因一定的数额

443
00:23:25,504 --> 00:23:27,871
相当肯定你知道有多大数组。

444
00:23:27,940 --> 00:23:30,173
你可以从另外一个数组创建一个数组

445
00:23:30,242 --> 00:23:32,409
它会复制来自其他数组的项目，

446
00:23:32,478 --> 00:23:35,645
所以还有其他的，但是最常见的是它

447
00:23:35,714 --> 00:23:38,382
这是一个你什么都不做的地方

448
00:23:38,450 --> 00:23:42,719
顺便说一句，我们正在使用这种更容易

449
00:23:42,788 --> 00:23:46,456
理解语法，但我们几乎肯定会使用

450
00:23:46,525 --> 00:23:51,861
这个语法。数组卡。所以我上次给你看了

451
00:23:51,930 --> 00:23:55,032
所以我有一个空的卡阵列在这里工作。

452
00:23:55,101 --> 00:23:58,001
我没有警告。所以，现在是时候了

453
00:23:58,070 --> 00:24:02,406
回到我们的控制器，并尝试开始使用这个模型。所以

454
00:24:02,474 --> 00:24:04,474
MVC正在回到我们的控制之下。所以

455
00:24:04,543 --> 00:24:08,345
我要回到这里我要去我的ViewController。

456
00:24:08,413 --> 00:24:10,280
让我们同时在这里集中注意力。所以

457
00:24:10,281 --> 00:24:12,148
其实，我们走吧，

458
00:24:12,218 --> 00:24:13,250
我们有浓度，

459
00:24:13,318 --> 00:24:16,220
我会让它变小，它就是我们的ViewController，

460
00:24:16,288 --> 00:24:20,557
那么我将如何在这个控制器中使用我的模型？好，

461
00:24:20,625 --> 00:24:23,927
我想要做的第一件事就是制作那个大绿箭头，

462
00:24:23,996 --> 00:24:26,697
从我的控制器指向我的绿色箭头

463
00:24:26,766 --> 00:24:29,700
模型。我将通过创建一个var来做到这一点

464
00:24:29,768 --> 00:24:32,969
在我的控制器中，并把它叫做游戏。这将是

465
00:24:33,038 --> 00:24:37,841
浓度类型。有我的大绿箭头。我能发送

466
00:24:37,910 --> 00:24:41,779
任何我想要游戏的消息，就像我可以得到的。

467
00:24:41,847 --> 00:24:45,182
我可以选择一张卡片我准备好了。

468
00:24:45,250 --> 00:24:48,051
现在，看看我得到的错误，我们最喜欢的错误，

469
00:24:48,120 --> 00:24:50,553
类ViewController没有初始化器，因为这个

470
00:24:50,622 --> 00:24:54,158
没有初始化。我们如何初始化？

471
00:24:54,226 --> 00:24:56,893
让我们看看，我们想要做一些类似于我们的事情

472
00:24:56,962 --> 00:24:59,563
在这里做了这个阵列。我们来试试吧，我们来做吧

473
00:24:59,632 --> 00:25:04,200
集中，这可能不会奏效，对吧？

474
00:25:04,269 --> 00:25:06,703
因为我们没有创建一个没有参数的init

475
00:25:06,772 --> 00:25:09,906
浓度。但它确实工作！

476
00:25:09,975 --> 00:25:14,878
这怎么可能工作？这里的答案是类，

477
00:25:14,947 --> 00:25:19,683
浓度是一个类，得到一个免费的初始化没有

478
00:25:19,751 --> 00:25:23,253
只要所有的变数都被初始化了。

479
00:25:23,322 --> 00:25:26,122
这只有一个变种，它已经初始化，所以

480
00:25:26,191 --> 00:25:30,694
集中获得了一个免费的初始化。我们正在初始化。

481
00:25:30,763 --> 00:25:33,797
我们并不需要这种类型。记住为什么？

482
00:25:33,865 --> 00:25:36,600
键入推理，显然Swift可以从中找出答案

483
00:25:36,668 --> 00:25:39,202
游戏是类型集中的代码行，我们不

484
00:25:39,271 --> 00:25:42,739
需要把它放在那里。但是，这很有趣，很好，我们

485
00:25:42,808 --> 00:25:46,142
得到了这个免费的初始化，但实际上，这是不好的。

486
00:25:46,211 --> 00:25:49,245
这不够好。因为当我们创造一个集中

487
00:25:49,314 --> 00:25:52,182
游戏，我们得想想有多少卡。因为

488
00:25:52,251 --> 00:25:54,685
浓度游戏必须加载这个数组

489
00:25:54,753 --> 00:25:56,820
在这里所有的卡片，它会使用，

490
00:25:56,888 --> 00:25:59,556
我们不能假定一个集中游戏只有12个

491
00:25:59,625 --> 00:26:02,559
像我们在板上的牌。或者只有四张牌

492
00:26:02,628 --> 00:26:07,231
就像我们目前的用户界面一样。我们实际上需要创造我们的

493
00:26:07,299 --> 00:26:11,034
自己初始化所以，我们再来，再做更多的空间

494
00:26:11,103 --> 00:26:15,238
这里。并添加一个init到我们的Concentration类。

495
00:26:15,307 --> 00:26:18,374
在里面。现在再次，我们有任何我们想要的参数。

496
00:26:18,443 --> 00:26:20,944
而我们需要创造我们的游戏是我们需要知道的

497
00:26:21,013 --> 00:26:25,182
卡的数量。这将是一个诠释。

498
00:26:27,186 --> 00:26:29,119
所以这是人们想要的初始化器

499
00:26:29,187 --> 00:26:31,321
必须用来创建一个集中游戏。

500
00:26:31,390 --> 00:26:35,792
因为我们需要这个。那么我们如何实现这个init？

501
00:26:35,861 --> 00:26:39,996
我们需要创建这么多对卡片

502
00:26:40,065 --> 00:26:44,901
把他们放在这里让我们尝试创建一张卡。

503
00:26:44,970 --> 00:26:48,538
让卡=，也许我们会幸运的

504
00:26:48,607 --> 00:26:51,675
我们只能说卡片。我们得到了，这工作

505
00:26:51,743 --> 00:26:56,212
浓度。没有工作。为什么没有这个工作？

506
00:26:56,281 --> 00:27:00,083
因为如果你在这里看我们的卡。

507
00:27:00,152 --> 00:27:04,888
让我们把卡先生带到这里。卡片，

508
00:27:04,956 --> 00:27:10,227
它有什么必须在那里初始化。

509
00:27:10,296 --> 00:27:15,198
卡是一个结构。现在，结构得到一个免费的初始化程序

510
00:27:15,267 --> 00:27:17,367
同样，但不同于一个类。

511
00:27:17,436 --> 00:27:19,803
所以这是结构和类之间的另一个区别。

512
00:27:19,871 --> 00:27:23,807
结构，他们得到的自由初始化，初始化所有

513
00:27:23,876 --> 00:27:26,376
他们的变数，即使他们已经预先初始化，

514
00:27:26,445 --> 00:27:28,712
像isFaceUp和isMatched。看这个，好吧，

515
00:27:28,780 --> 00:27:31,548
我要打卡。左括号，

516
00:27:31,617 --> 00:27:34,884
我要让Xcode显示我的初始化，和

517
00:27:34,953 --> 00:27:38,955
你可以看到它只是初始化每一个。

518
00:27:39,024 --> 00:27:42,192
所以我可以做isFaceUp false，isMatched false，

519
00:27:42,261 --> 00:27:45,796
标识符，我想我会补一些

520
00:27:45,864 --> 00:27:48,165
这个东西的标识符来做到这一点。

521
00:27:48,233 --> 00:27:51,034
所以我可以初始化一个这样的卡，因为我得到一个免费的

522
00:27:51,103 --> 00:27:54,504
初始化。类从来没有得到这种免费的初始化。

523
00:27:54,573 --> 00:27:56,173
他们没有得到免费的初始化工具，

524
00:27:56,241 --> 00:27:58,508
你可以初始化所有的变量。

525
00:27:58,576 --> 00:28:02,279
这纯粹是一个结构的事情。但这是假的，因为

526
00:28:02,348 --> 00:28:05,181
这些都是假的，所以为什么当我初始化时，

527
00:28:05,250 --> 00:28:08,018
我不得不再次说他们是假的吗？如果我想摆脱

528
00:28:08,087 --> 00:28:10,587
那些，为了摆脱这些，我必须补充

529
00:28:10,656 --> 00:28:13,523
这是一个初始化器。所以我会有一个初始化程序

530
00:28:13,592 --> 00:28:17,995
只需要标识符，这是一个Int。

531
00:28:18,063 --> 00:28:22,366
然后我想在这里设置这个标识符等于

532
00:28:22,434 --> 00:28:28,071
这个标识符就在这里。我们已经

533
00:28:28,140 --> 00:28:31,208
遇到了一些问题，试图做到这一点。

534
00:28:31,276 --> 00:28:34,177
其中一个肯定是不对的。标识符等于

535
00:28:34,246 --> 00:28:38,548
标识？那真是太奇怪了有一件事还注意到

536
00:28:38,617 --> 00:28:42,319
在我的两个人中，我没有做一个外部的名字

537
00:28:42,387 --> 00:28:44,020
一个内部的名字。你注意到了吗？

538
00:28:44,089 --> 00:28:46,389
我只做了一个，这意味着外部名称和

539
00:28:46,458 --> 00:28:49,226
内部名称是一样的。所以我可以做一件事来解决

540
00:28:49,295 --> 00:28:52,529
那就是让内部的名字与我不一样。

541
00:28:52,598 --> 00:28:54,865
然后我可以说标识符=我。

542
00:28:54,933 --> 00:28:57,534
你看？这是外部的名字，

543
00:28:57,603 --> 00:29:00,103
我在这里调用这个init时使用它。

544
00:29:00,172 --> 00:29:03,407
这是我在里面使用的内部名称。

545
00:29:03,475 --> 00:29:06,543
现在它知道这个标识符意味着一个。但

546
00:29:06,612 --> 00:29:08,545
你知道吗？这有点粗俗首先，

547
00:29:08,613 --> 00:29:12,916
我讨厌像我这样的变量名。我是一个不好的变量名称。

548
00:29:12,984 --> 00:29:15,518
我只是不想在这里。但我真的不能想

549
00:29:15,587 --> 00:29:19,089
另一个在这里比标识符更好。

550
00:29:19,157 --> 00:29:20,957
那就是，标识符在那里是个好名字。所以

551
00:29:21,026 --> 00:29:23,560
我真的希望它是相同的内部名称和

552
00:29:23,628 --> 00:29:28,431
外部名称。现在，inits是一种方法

553
00:29:28,500 --> 00:29:33,336
通常具有相同的内部名称和外部名称。最

554
00:29:33,405 --> 00:29:36,873
功能不，但往往。他们不必，

555
00:29:36,942 --> 00:29:41,144
但他们倾向于。所以，现在我回头说这个，但是

556
00:29:41,213 --> 00:29:43,613
这不是，我不能真正区分这两个，

557
00:29:43,682 --> 00:29:46,183
那么我怎么能区分这两个呢？

558
00:29:46,251 --> 00:29:51,220
这是参数。这是我自己的标识符。

559
00:29:51,289 --> 00:29:58,028
那么，我可以说，自我。所以，自我意味着我的标识符。

560
00:29:58,096 --> 00:30:01,965
这张卡的标识符。所以现在知道我们要这个，

561
00:30:02,034 --> 00:30:06,169
所以这一个是这个。这太酷了。

562
00:30:06,237 --> 00:30:11,040
我们摆脱了这种情况。好，那么

563
00:30:11,109 --> 00:30:12,709
让我们再回到这里。

564
00:30:12,777 --> 00:30:15,979
我们可以制作一张卡片，效果很好，效果很好。

565
00:30:16,048 --> 00:30:19,316
但是我们必须指定卡的标识符。所以

566
00:30:19,384 --> 00:30:21,551
这个标识符实际上并不重要，

567
00:30:21,620 --> 00:30:24,621
只要它是独一无二的。所以我要创建一个for循环。所以

568
00:30:24,690 --> 00:30:26,723
注意，这里是你如何在Swift中创建一个for循环。

569
00:30:26,792 --> 00:30:30,159
这与其他语言有些不同。它开始了

570
00:30:30,228 --> 00:30:34,197
一样。对于标识符，这只是一些变量。但

571
00:30:34,266 --> 00:30:38,902
你不要说等于零，小于20，我加上加号，

572
00:30:38,971 --> 00:30:42,506
我们不这样做。相反，我们使用这个词，

573
00:30:42,574 --> 00:30:46,576
然后这个在这里可以是Swift中的任何东西

574
00:30:46,645 --> 00:30:50,880
一个序列。 Swift中的一个序列意味着任何你所在的地方

575
00:30:50,949 --> 00:30:53,249
可以从某个地方开始，去下一个，去下一个，

576
00:30:53,318 --> 00:30:55,151
去下一个，这就是一个for循环。

577
00:30:55,220 --> 00:30:56,686
它从某处开始，然后到下一个

578
00:30:56,755 --> 00:30:58,288
去下一个，去下一个。所以

579
00:30:58,356 --> 00:31:01,558
Swift中有哪些序列的例子？

580
00:31:01,627 --> 00:31:04,995
阵列？好吧，显然是阵列，你可以从第一个开始

581
00:31:05,064 --> 00:31:06,596
元素，并转到下一个，转到下一个，

582
00:31:06,665 --> 00:31:07,764
直到你走到尽头。

583
00:31:07,833 --> 00:31:11,801
字符串，一个字符串是一个序列。第一个字，

584
00:31:11,870 --> 00:31:13,302
去下一个字符，去下一个字符，

585
00:31:13,371 --> 00:31:17,440
下一个字符。我要在这里使用的是一个真正的

586
00:31:17,509 --> 00:31:20,276
很酷的序列叫做可数范围。所以

587
00:31:20,345 --> 00:31:22,812
可数范围是一个范围，换句话说，它有一个开始

588
00:31:22,881 --> 00:31:25,115
并结束，这是可数的。换一种说法，

589
00:31:25,184 --> 00:31:28,118
它知道如何计算，并进入下一个空间。

590
00:31:28,186 --> 00:31:31,054
Swift中有特殊的语法，因为它是如此

591
00:31:31,123 --> 00:31:33,089
共同想要做一个可数范围。和

592
00:31:33,158 --> 00:31:38,294
它是这样的。可数范围的开始，

593
00:31:38,363 --> 00:31:41,998
.. <，这意味着从0到和

594
00:31:42,067 --> 00:31:46,236
不包括双卡的数量。

595
00:31:48,673 --> 00:31:52,609
所以这是一个正在经历的循环，

596
00:31:52,677 --> 00:31:55,511
为什么不切割？我没有选择它，

597
00:31:55,580 --> 00:31:59,215
我猜？切，我们去，贴。这将会通过

598
00:31:59,284 --> 00:32:02,552
卡的数量。现在还有另外一种

599
00:32:02,621 --> 00:32:07,324
可数范围的创造者在这里，这是..点，

600
00:32:07,392 --> 00:32:11,594
这意味着零到这里，包括这一个。

601
00:32:11,663 --> 00:32:14,197
所以，在这里，如果我想用那个，我会说一个点，

602
00:32:14,265 --> 00:32:18,100
点，因为我只想要这许多卡。所以，这使得

603
00:32:18,169 --> 00:32:22,305
一个可数范围。事实上，如果你看这个东西的类型，

604
00:32:22,373 --> 00:32:26,476
这将是可数范围。好的，现在我正在经历

605
00:32:26,544 --> 00:32:29,479
并在这里创建一张卡，但我需要另一张卡。

606
00:32:29,548 --> 00:32:33,983
所以我可以说匹配卡=相同的东西，对吧？

607
00:32:34,052 --> 00:32:37,754
创建另一张具有相同标识符的卡。说得通，

608
00:32:37,822 --> 00:32:40,323
对？现在我有两张符合我可以添加到的卡

609
00:32:40,392 --> 00:32:41,691
我的一堆卡在这里。

610
00:32:41,760 --> 00:32:42,992
我总是需要两张相匹配的牌，

611
00:32:43,061 --> 00:32:46,196
但你知道什么是惊人的，我实际上甚至不需要

612
00:32:46,265 --> 00:32:50,934
在这里做这个。我可以这样做，

613
00:32:53,071 --> 00:32:56,906
因为当你分配一个结构，哪个卡是

614
00:32:56,975 --> 00:33:02,111
一个结构，到另一个变量，它复制它。所以

615
00:33:02,180 --> 00:33:05,748
matchingCard是卡的副本。只要分配它，

616
00:33:05,817 --> 00:33:10,353
它使它成为一个副本。现在我有一张卡片和一个副本。所以

617
00:33:10,422 --> 00:33:12,455
我可以说cards.append，

618
00:33:12,524 --> 00:33:17,293
这就是你如何添加一些数组，添加卡，

619
00:33:17,362 --> 00:33:22,265
然后card.append匹配卡，匹配卡。

620
00:33:22,333 --> 00:33:25,168
所以现在我已经将这两个匹配卡添加到我的数组中。

621
00:33:25,237 --> 00:33:27,837
而且我要去做那几张牌

622
00:33:27,906 --> 00:33:30,073
倍。我有我的卡，

623
00:33:30,141 --> 00:33:33,977
但是我甚至不需要这张配对卡。

624
00:33:34,045 --> 00:33:37,747
我可以摆脱这一点，而只是说追加（卡）。

625
00:33:37,816 --> 00:33:41,851
因为把东西放在一个阵列里或者把它们取出来

626
00:33:41,919 --> 00:33:46,590
复制卡片。实际上有三张牌涉及

627
00:33:46,658 --> 00:33:49,625
这里。这一个我创建的，放在这里的拷贝，

628
00:33:49,694 --> 00:33:53,363
和另一个不同的副本放在这里。所以

629
00:33:53,431 --> 00:33:56,132
明白当你通过这些结构时，

630
00:33:56,200 --> 00:33:57,901
你正在复制它们。

631
00:33:57,969 --> 00:34:01,338
现在，当我们把这些卡中的一张面朝上的时候，

632
00:34:01,407 --> 00:34:03,373
该副本将实际上是一个真正的副本和

633
00:34:03,442 --> 00:34:06,542
只有他们中的一个，所以它不是一个指向同一张牌的指针

634
00:34:06,611 --> 00:34:09,779
记忆，它实际上是两个不同的卡。顺便一提，

635
00:34:09,847 --> 00:34:12,748
另一个很酷的方式，我们可以做这个不同的语法是我可以

636
00:34:12,817 --> 00:34:16,886
说卡片，这是一个卡片数组，

637
00:34:16,955 --> 00:34:21,591
+ =另一张卡片，用这两张卡片。

638
00:34:23,562 --> 00:34:26,763
加上等于数组。你可以一起添加数组

639
00:34:26,831 --> 00:34:29,499
这个，把这张卡放在这个数组里

640
00:34:29,567 --> 00:34:33,069
这个数组中的这张卡复制它。然后我们把它放进去

641
00:34:33,138 --> 00:34:36,305
那里，实际上这个数组也被复制

642
00:34:36,374 --> 00:34:41,310
cuz数组是一个结构。好的，所以我们得到了，

643
00:34:41,379 --> 00:34:44,681
这一切都很顺利。唯一我不是真的

644
00:34:44,750 --> 00:34:47,717
就像这样，这对我来说真的不太合适

645
00:34:47,786 --> 00:34:50,654
集中游戏必须选择标识符

646
00:34:50,722 --> 00:34:53,456
牌，因为浓度游戏没有

647
00:34:53,525 --> 00:34:55,191
关心标识符是什么。

648
00:34:55,260 --> 00:34:58,761
所有它关心的是它们是独一无二的。所以真的，

649
00:34:58,830 --> 00:35:01,998
我不想这样做。我想从这里得到这个，而且

650
00:35:02,067 --> 00:35:06,636
让卡片找出自己的唯一标识符。有

651
00:35:06,704 --> 00:35:09,739
没有理由的卡可以只喜欢挑十亿和七。

652
00:35:09,807 --> 00:35:12,141
这就是它，只要这是独一无二的

653
00:35:12,210 --> 00:35:14,978
它从来没有给出另外一个十亿和七个卡，

654
00:35:15,046 --> 00:35:17,380
那么它应该是独一无二的。我就是做这个的。

655
00:35:17,448 --> 00:35:21,150
我想这个init不必采取这个标识符。但

656
00:35:21,219 --> 00:35:24,721
如果这个init在这里不带标识符，那么我们

657
00:35:24,790 --> 00:35:28,691
要弄清楚如何在这里创建一个唯一的标识符。所以

658
00:35:28,760 --> 00:35:31,227
我们该怎么做？那么，我要教你

659
00:35:31,296 --> 00:35:34,163
另一个很酷的Swift的东西，这是我要创建

660
00:35:34,232 --> 00:35:39,436
一种特殊的方法。这是一个静态的方法。

661
00:35:39,504 --> 00:35:43,907
这是一个相同的语法func，但它有静态之前，和

662
00:35:43,975 --> 00:35:48,745
它将得到一个唯一的标识符。它会回来

663
00:35:48,813 --> 00:35:52,015
一个int将是唯一的。每次我调用的时候

664
00:35:52,084 --> 00:35:54,517
它会返回给我另一个独特的标识符。

665
00:35:54,586 --> 00:35:56,853
这只是会返回一些独特的标识符。

666
00:35:56,921 --> 00:35:59,989
我们将不得不使其工作。现在，什么是静态的

667
00:36:00,058 --> 00:36:03,526
功能全部关于？静态函数是一个函数，

668
00:36:03,595 --> 00:36:06,329
即使它在卡类，你不能发送它

669
00:36:06,397 --> 00:36:11,000
一张卡。一张卡不理解这个消息。

670
00:36:11,069 --> 00:36:14,938
什么理解这个消息是类型卡。

671
00:36:16,174 --> 00:36:18,908
你把它发送到类型本身。

672
00:36:18,977 --> 00:36:21,811
所以你可以把它看成是一种全局的函数，

673
00:36:21,880 --> 00:36:24,747
一个效用函数或者只是绑定的东西

674
00:36:24,816 --> 00:36:28,952
方式。是否有意义？你不要把它发送到一张卡。

675
00:36:29,020 --> 00:36:31,154
你不能要求一张卡片的唯一标识符。

676
00:36:31,222 --> 00:36:34,891
你问卡的类型。所以，这就是静态的意思。

677
00:36:34,960 --> 00:36:38,361
所以在这里当我想调用这个函数，

678
00:36:38,430 --> 00:36:43,066
我把它发送到类型card.getUniqueIdentifier。

679
00:36:43,134 --> 00:36:46,802
这是从卡的类型。现在我怎么会

680
00:36:46,871 --> 00:36:49,272
实现这个获得唯一标识符？好，

681
00:36:49,340 --> 00:36:53,310
我将有一个静态变量，因为你也可以拥有这些变量。

682
00:36:53,378 --> 00:36:56,179
所以这是一个与类型一起存储的变量，

683
00:36:56,248 --> 00:36:59,549
不与每个单独的卡。这些都得分了

684
00:36:59,618 --> 00:37:01,517
每个单独的卡，这是与类型存储。

685
00:37:01,586 --> 00:37:05,088
而且我会调用这个我的标识符工厂，

686
00:37:05,157 --> 00:37:09,158
我刚刚开始= 0。然后在这里，

687
00:37:09,227 --> 00:37:13,730
我要说的是Card.identifierFactory + = 1到

688
00:37:13,798 --> 00:37:17,266
使其成为一个新的唯一标识符。然后我会

689
00:37:17,335 --> 00:37:21,337
返回Card.identifierFactory。所以现在我回来了一个独特的，

690
00:37:21,406 --> 00:37:23,740
每次你打电话的时候，都会有一个独特的int，

691
00:37:23,808 --> 00:37:25,975
因为它从零开始，每次都会产生一个唯一的int。

692
00:37:26,044 --> 00:37:30,746
现在，有趣的是我真的没有看到卡

693
00:37:30,815 --> 00:37:34,917
点，因为我在一个静态的方法，所以我可以访问我的

694
00:37:34,986 --> 00:37:41,524
没有卡的静态变量。所以这有点酷。

695
00:37:41,593 --> 00:37:45,295
所以我只想借这个小小的弯路来告诉你如何

696
00:37:45,363 --> 00:37:48,865
你可以做这些很好的实用方法或其他什么，

697
00:37:48,934 --> 00:37:51,601
一种类型的效用变量。所以现在让我们回到

698
00:37:51,670 --> 00:37:54,437
我们的注意力集中在这里，因为它有一个警告，让我们来

699
00:37:54,506 --> 00:37:57,040
看看这个警告是什么。它说不可改变的价值

700
00:37:57,108 --> 00:38:00,710
标识符，这，从来没有使用过。

701
00:38:00,778 --> 00:38:04,747
它说，考虑更换与underbar或删除它。

702
00:38:04,816 --> 00:38:07,583
那么，我们不能删除它，因为它是控制

703
00:38:07,652 --> 00:38:11,287
我们for循环的变量。但是我们可以用它来代替它

704
00:38:11,355 --> 00:38:15,424
下划线。 Swift中的underbar意味着忽略这个或者

705
00:38:15,493 --> 00:38:17,827
我真的不在乎这是什么因为我不会用它。

706
00:38:17,896 --> 00:38:19,729
我们之前已经用过这个，你还记得吗？

707
00:38:19,798 --> 00:38:22,866
在我们的ViewController中，touchCard，

708
00:38:22,934 --> 00:38:26,135
它的外部名称是underbar。这意味着没有

709
00:38:26,203 --> 00:38:28,738
当你打电话给这个外部名字，因为记住

710
00:38:28,807 --> 00:38:30,873
touchCard的一种Objective-C的东西。

711
00:38:30,942 --> 00:38:33,376
这个目标行动，所以它没有外部名称和

712
00:38:33,444 --> 00:38:34,310
所以我们只是说，嘿，

713
00:38:34,379 --> 00:38:37,179
我不想要一个外部的名字。类似的东西在这里

714
00:38:37,248 --> 00:38:40,015
集中，我们正在做一个循环，我们仍然想要做

715
00:38:40,084 --> 00:38:42,752
这个，这个很多次。但我们不在乎什么是标识符

716
00:38:42,821 --> 00:38:47,657
因为我们不再在这里使用它了。了解？好的，

717
00:38:47,726 --> 00:38:51,193
在初始化时我们需要做的最后一件事情是，

718
00:38:51,262 --> 00:38:54,997
这是剩下要做的，就是洗牌。因为如果我们

719
00:38:55,066 --> 00:38:58,334
不要洗牌，然后总是进来

720
00:38:58,403 --> 00:39:01,136
相同的顺序。这将是非常容易的

721
00:39:01,205 --> 00:39:03,473
玩游戏。我要离开你的功课。

722
00:39:03,541 --> 00:39:06,676
你的工作将会在那里洗牌。它会

723
00:39:06,744 --> 00:39:09,879
要求你再次理解这个值类型的数组，

724
00:39:09,947 --> 00:39:12,515
或价值类型等，这是一个相当不错的练习

725
00:39:12,584 --> 00:39:13,582
那样做，所以我会离开的

726
00:39:13,651 --> 00:39:18,687
您。我们已经解决了整个初始化问题。所以

727
00:39:18,756 --> 00:39:22,659
现在我们可以在这里回到我们的视图控制器。和

728
00:39:22,728 --> 00:39:27,063
找到它。在那里。和浓度

729
00:39:27,132 --> 00:39:31,066
在这里需要指定卡对的数量。

730
00:39:31,135 --> 00:39:36,739
numberOfPairsOfCards，我们在这里放什么号码？

731
00:39:36,807 --> 00:39:38,874
对，我想我们可以把四个。

732
00:39:38,943 --> 00:39:41,577
我们知道我们在用户界面中有四张牌。

733
00:39:41,646 --> 00:39:43,312
但是如果我想添加更多的按钮呢？

734
00:39:43,381 --> 00:39:45,715
现在我要回到这里，改变这四个？

735
00:39:47,419 --> 00:39:50,286
我们为什么不计算卡片按钮的数量，

736
00:39:50,354 --> 00:39:53,456
记得？卡片按钮，所有那些按钮在那里，

737
00:39:53,524 --> 00:39:57,026
cardButtons.count。这就是有多少卡，和

738
00:39:57,095 --> 00:39:58,961
我们只是分成两份好，有道理？

739
00:39:59,030 --> 00:40:00,730
让我们来看看这个好一点。

740
00:40:02,500 --> 00:40:04,701
我只是要把卡片按钮除以二。所以

741
00:40:04,769 --> 00:40:08,237
如果我有四个卡片按钮，显然是两对。

742
00:40:08,306 --> 00:40:09,505
其实我应该小心一点。

743
00:40:09,574 --> 00:40:11,707
如果我有一个奇数的卡，

744
00:40:11,776 --> 00:40:15,878
我可能想要围了起来。所以，如果我有三张牌，我需要

745
00:40:15,947 --> 00:40:17,480
两双，所以我有四个总卡。

746
00:40:17,549 --> 00:40:19,882
我永远不能匹配第三张牌，但是

747
00:40:19,951 --> 00:40:23,252
至少游戏会有足够的。现在，这是正确的

748
00:40:23,321 --> 00:40:27,089
要做的事情，但我在这里得到了一个非常严重的错误。好的，

749
00:40:27,158 --> 00:40:29,993
让我们来看看它。它说，不能使用Instance成员

750
00:40:30,061 --> 00:40:33,830
卡按钮，在这里，属性初始值设定项。

751
00:40:33,898 --> 00:40:35,999
哦，是啊，看，var游戏，这是一个属性和

752
00:40:36,067 --> 00:40:38,667
我正在初始化它，这是一个属性初始值设定项。

753
00:40:38,736 --> 00:40:42,805
它说属性初始化器在自己可用之前运行。

754
00:40:42,873 --> 00:40:45,275
哦，记得我告诉过你，在Swift你必须这样做

755
00:40:45,343 --> 00:40:48,043
完全初始化一些东西，然后才能使用

756
00:40:48,112 --> 00:40:50,880
任何东西，你可以访问任何酒吧之前，

757
00:40:50,949 --> 00:40:52,949
调用它的任何功能，任何东西。

758
00:40:53,018 --> 00:40:55,784
那么显然我们还没有完全初始化

759
00:40:55,853 --> 00:40:59,154
因为我们正在初始化游戏的过程。和

760
00:40:59,223 --> 00:41:01,023
游戏就是这样初始化的

761
00:41:01,092 --> 00:41:03,893
我们在这里得到了一个22。我们怎么做到这一点，

762
00:41:03,962 --> 00:41:06,228
哪一个取决于另一个？一个变量取决于哪里

763
00:41:06,297 --> 00:41:09,565
另外一个。有几种方法可以解决这个问题。

764
00:41:09,634 --> 00:41:12,101
但是我会告诉你的

765
00:41:12,170 --> 00:41:16,705
这是一个很酷的懒惰的。如果你做一个lazy，

766
00:41:16,774 --> 00:41:21,143
这意味着它不会实际初始化，直到有人抓住

767
00:41:21,212 --> 00:41:24,881
它。直到有人试图使用它。只要有人尝试

768
00:41:24,950 --> 00:41:27,049
使用游戏，然后它将初始化它。

769
00:41:27,118 --> 00:41:31,087
现在根据定义，因为那个同样的catch 22，没有

770
00:41:31,155 --> 00:41:34,924
可以尝试使用游戏，直到完全初始化。

771
00:41:34,993 --> 00:41:39,062
所以我们赢了，它完美的作品。和lazy算一样，

772
00:41:39,130 --> 00:41:43,700
这个var初始化。计数正在进行的游戏

773
00:41:43,768 --> 00:41:46,268
这样，真棒。有一个限制

774
00:41:46,337 --> 00:41:48,437
lazy虽然，这不是很好。

775
00:41:48,506 --> 00:41:52,909
也就是说，它不能有一个didSet。如果你试试

776
00:41:52,977 --> 00:41:55,678
添加一个didSet，就像我们在这里用flipCount所做的那样，

777
00:41:55,747 --> 00:41:58,847
记得吗？是的，你会在这里得到一个错误

778
00:41:58,916 --> 00:42:02,284
这是冲突宣言等等等等等，但基本上是什么

779
00:42:02,353 --> 00:42:05,587
这里说的是你不能使用属性观察员

780
00:42:05,656 --> 00:42:07,957
一个lazy的变种所以如果你需要在那里使用属性观察员，

781
00:42:08,026 --> 00:42:09,692
你需要找出每一次游戏的变化，

782
00:42:09,761 --> 00:42:11,260
你将不得不做一个不同的方式。

783
00:42:11,328 --> 00:42:12,829
顺便说一下，你还有什么其他的方法可以做到呢？

784
00:42:12,897 --> 00:42:14,062
那么，你会去的

785
00:42:14,131 --> 00:42:17,199
下周学习有一些方法被调用

786
00:42:17,268 --> 00:42:20,936
所有这些outlet都被解雇了。系统会调用

787
00:42:21,005 --> 00:42:23,305
一个方法，在那里你可以初始化你的游戏。

788
00:42:23,374 --> 00:42:25,708
也许在同一时间，你把它作为一个可选或

789
00:42:25,776 --> 00:42:28,978
甚至可能是一个隐含的解包可选。

790
00:42:29,046 --> 00:42:30,813
给你一点提示。但是你不会需要这个

791
00:42:30,882 --> 00:42:32,515
你的功课虽然。你将能够做到这一点

792
00:42:32,583 --> 00:42:36,485
你的家庭作业。好吧，这很好。现在我们有这个游戏，

793
00:42:36,554 --> 00:42:39,355
大绿色的箭头。我们的管理员正在和我们谈话

794
00:42:39,423 --> 00:42:41,724
模型。接下来我们需要做什么？

795
00:42:41,793 --> 00:42:44,526
我们再回头看看我们的浓度API，看看

796
00:42:44,595 --> 00:42:47,496
我们需要做什么似乎有两件事，

797
00:42:47,565 --> 00:42:51,067
我们已经使用了这部分的API。我们得到了这两个，所以

798
00:42:51,135 --> 00:42:53,902
让我们来做这个，选择卡片。我们必须告诉

799
00:42:53,971 --> 00:42:56,539
当我们的卡被选中时的集中模型。

800
00:42:56,607 --> 00:42:59,508
而且我们知道什么时候在我们的控制器中。

801
00:42:59,577 --> 00:43:02,878
在这里触摸卡。每当一个按钮调用触摸

802
00:43:02,947 --> 00:43:04,613
卡，我们知道一张卡被触摸。

803
00:43:04,682 --> 00:43:07,417
而不是做所有这些翻转卡与表情符号的选择

804
00:43:07,485 --> 00:43:09,985
事情就在这里，我只是要告诉我的游戏嘿，

805
00:43:10,054 --> 00:43:15,591
选择这张卡。好的？

806
00:43:15,659 --> 00:43:18,594
所以不是自己处理，而是让模型

807
00:43:18,663 --> 00:43:21,230
处理它。所以，这是一个搞清楚。

808
00:43:21,299 --> 00:43:24,199
但是这里有一些有趣的东西需要注意，

809
00:43:24,268 --> 00:43:26,869
是当我告诉模型选择这张卡，

810
00:43:26,938 --> 00:43:29,905
它可能会改变游戏可能会改变。而事实上，我希望它

811
00:43:29,974 --> 00:43:31,841
确实会改变它应该做的匹配和

812
00:43:31,909 --> 00:43:34,877
各种各样的东西。所以它会改变。所以现在，

813
00:43:34,946 --> 00:43:39,415
我们必须从模型中更新我们的视图，好吗？

814
00:43:39,483 --> 00:43:41,683
我们的视图现在与模型有点不同步，

815
00:43:41,752 --> 00:43:43,085
因为当我们选择这张卡时

816
00:43:43,154 --> 00:43:45,087
这可能会导致游戏改变。

817
00:43:45,156 --> 00:43:48,057
所以我们需要一个像updateViewFromModel或者方法

818
00:43:48,126 --> 00:43:51,594
类似的东西。某种功能在这里，

819
00:43:51,663 --> 00:43:55,430
func updateViewFromModel。那该怎么办？

820
00:43:55,499 --> 00:43:58,534
这里将使用这个API的其他部分。

821
00:43:58,603 --> 00:44:00,803
这是要看所有的牌和

822
00:44:00,871 --> 00:44:03,772
确保我们所有的卡片按钮匹配，对不对？

823
00:44:03,841 --> 00:44:06,208
无论他们是否面对面，是否匹配，

824
00:44:06,277 --> 00:44:08,010
所有这些业务。我们看比赛，

825
00:44:08,079 --> 00:44:11,046
找出来，并确保我们的卡不匹配。好吧，

826
00:44:11,115 --> 00:44:12,948
那么我们如何实现这个updateViewFromModel呢？

827
00:44:13,017 --> 00:44:15,618
那么我想通过所有的卡片按钮和

828
00:44:15,687 --> 00:44:19,355
看看游戏并适当地设置它。所以我可以做

829
00:44:19,424 --> 00:44:24,893
另一个循环，我说我的cardButtons按钮，

830
00:44:24,962 --> 00:44:28,330
好的？只要通过，现在每个按钮将是如果我们

831
00:44:28,399 --> 00:44:31,834
看看这将是一个用户界面按钮的类型。看到？

832
00:44:31,903 --> 00:44:34,603
因为这是一系列的按钮。这不是很酷吗？

833
00:44:34,672 --> 00:44:37,306
好吧？但我实际上不会那样做。

834
00:44:37,375 --> 00:44:40,843
我会做点别的，因为我需要查看这个

835
00:44:40,911 --> 00:44:45,147
按钮的索引在这张卡片的东西，所以我要去做我的

836
00:44:45,215 --> 00:44:50,018
按索引循环。在我可以做的卡片按钮数组中

837
00:44:50,087 --> 00:44:54,757
用0点小于cardButtons.count，好吧。

838
00:44:54,825 --> 00:44:57,860
大家都明白这个柜台的范围，但是

839
00:44:57,929 --> 00:45:00,830
我不会那么做，要么我会告诉你另一个

840
00:45:00,899 --> 00:45:05,501
方式，cardButtons.indications，好吧。 cardButton.indicies

841
00:45:05,570 --> 00:45:09,839
索引是一个数组中的方法。好的，那个退步了

842
00:45:09,907 --> 00:45:13,509
你是数组中所有索引的可数范围。

843
00:45:13,578 --> 00:45:16,946
事实上，如果我选择点击指数，看看它的类型，

844
00:45:17,014 --> 00:45:20,916
int的可数范围好的？所以，

845
00:45:20,985 --> 00:45:23,986
这是通过所有指标的一种很酷的方式。

846
00:45:24,055 --> 00:45:26,088
而现在我有指数，

847
00:45:26,156 --> 00:45:29,858
我可以说让按钮等于我们的cardButtons在该指数。

848
00:45:29,927 --> 00:45:34,764
让卡片等于游戏卡片

849
00:45:34,832 --> 00:45:38,567
在那个指数。所以这真棒。我有按钮。

850
00:45:38,636 --> 00:45:41,270
我有这张卡。我只需要让他们匹配起来。

851
00:45:41,338 --> 00:45:44,039
所以我要说，如果卡面朝上，

852
00:45:44,108 --> 00:45:47,009
那么我会做我的脸，这是什么，

853
00:45:47,077 --> 00:45:50,512
就是这个那里有白色的背景。

854
00:45:50,581 --> 00:45:54,450
所以让我们来做。否则，如果它面临下来，

855
00:45:54,519 --> 00:45:57,820
我想在这里的橙色背景的东西，那里。

856
00:45:57,889 --> 00:45:59,554
而现在我甚至不需要翻转卡，

857
00:45:59,623 --> 00:46:03,525
让我们摆脱翻转卡。每个人，

858
00:46:03,594 --> 00:46:05,661
看看我做了什么？我刚刚做到了

859
00:46:05,730 --> 00:46:09,164
该按钮与卡匹配。还有一件事，

860
00:46:09,233 --> 00:46:12,634
顺便说一下，卡可以匹配。他们有匹配。

861
00:46:12,703 --> 00:46:16,005
请记住，当我们把它放在卡片上时，是匹配的。所以

862
00:46:16,074 --> 00:46:19,875
我需要处理这个。而我会这样做的方式，

863
00:46:19,944 --> 00:46:25,648
是我会做匹配，卡，所以

864
00:46:25,716 --> 00:46:28,917
我可以看到他们如果卡匹配，

865
00:46:28,986 --> 00:46:31,988
我只是把它做成背景而把它从UI中拿出来

866
00:46:32,056 --> 00:46:34,690
当它匹配时，而不是橙色

867
00:46:34,758 --> 00:46:37,259
面朝下。如果它匹配，仍然面对，我不想要

868
00:46:37,327 --> 00:46:39,495
很明显，我希望人们看到你得到一场比赛。

869
00:46:39,564 --> 00:46:42,298
但一旦它在比赛中倒退，我不想要它

870
00:46:42,366 --> 00:46:46,602
以显示。所以我要这样做的方式是通过这样做，

871
00:46:46,671 --> 00:46:51,707
card.isMatched。匹配。问号。

872
00:46:51,775 --> 00:46:56,412
无论是这个东西还是这个。每个人都知道这一点

873
00:46:56,481 --> 00:46:59,614
问号冒号？我们有C和其他语言的

874
00:46:59,683 --> 00:47:02,518
好。所以在这里，而不是橙色，我希望它是明确的。

875
00:47:02,586 --> 00:47:04,553
你怎么清楚？那么如果你去任何颜色

876
00:47:04,622 --> 00:47:08,023
选择器，如果你看它的底部说不透明。那是

877
00:47:08,092 --> 00:47:11,827
颜色是多么透明。所以这完全是不透明的

878
00:47:11,896 --> 00:47:16,898
透明。换句话说，清楚。所以如果这些牌相匹配，

879
00:47:16,967 --> 00:47:19,902
我要说清楚。现在，这里还有一个错误。

880
00:47:19,971 --> 00:47:23,339
这是表情符号现在，这个表情符号曾经是我们的东西

881
00:47:23,407 --> 00:47:26,375
抓住了这个表情符号的选择基础上的索引和

882
00:47:26,444 --> 00:47:30,746
所有这一切。我会推迟在这里执行，

883
00:47:30,814 --> 00:47:34,950
它正在调用卡的功能表情符号。和

884
00:47:35,019 --> 00:47:38,387
这是一个我要在这里做的功能。

885
00:47:38,455 --> 00:47:40,589
让我们来看看这个

886
00:47:40,658 --> 00:47:44,359
你可以看到它，是一个类型卡卡func表情符号

887
00:47:44,428 --> 00:47:48,263
会返回一个表情符号，我会回来的问号

888
00:47:48,332 --> 00:47:51,167
现在。我们刚回来问号，

889
00:47:51,235 --> 00:47:55,304
我们将在这里处理这些表情符号的选择。

890
00:47:55,373 --> 00:47:58,140
我们要把这些表情符号的选择，最终，

891
00:47:58,208 --> 00:48:02,110
我们将选择其中一种表情符号。随机，

892
00:48:02,179 --> 00:48:04,847
并把它放在卡上，其实我还有一些

893
00:48:04,916 --> 00:48:07,817
表情符号在这里，多一点万圣节emojis。

894
00:48:07,885 --> 00:48:10,719
所以我们要在这里挑选其中的一个emojis，

895
00:48:10,788 --> 00:48:11,687
并把它放在卡上，但为了

896
00:48:11,755 --> 00:48:13,655
现在，我只是要做问号。因为我真的

897
00:48:13,724 --> 00:48:15,924
想回到我的用户界面，并确保我没有破碎

898
00:48:15,993 --> 00:48:21,197
所有这些MVC阴谋。我们回去吧

899
00:48:21,265 --> 00:48:25,835
到我们的模型，并选择一张卡时做一些事情。所以

900
00:48:25,903 --> 00:48:28,437
所有我会做的，最终我们必须使它匹配。但

901
00:48:28,506 --> 00:48:30,906
我现在要做的就是让模特翻牌。

902
00:48:30,975 --> 00:48:34,209
所以现在模型就会翻转卡片

903
00:48:34,278 --> 00:48:37,346
这里我们在我们的模型中的选择卡。所以

904
00:48:37,415 --> 00:48:43,385
我会说，如果这个指数的牌面朝上

905
00:48:43,454 --> 00:48:48,624
那么我要把该卡设置在该索引处

906
00:48:48,693 --> 00:48:56,065
是isFaceUp = false，否则，我将要做到这一点。

907
00:48:59,137 --> 00:49:02,538
没错，所以我只是要把卡翻过来，每个人

908
00:49:02,607 --> 00:49:06,942
相信我，翻转卡吗？是的，只要

909
00:49:07,011 --> 00:49:09,378
如果面朝上，面朝下，面朝下，

910
00:49:09,446 --> 00:49:12,914
正视，所以就是这样。所以现在当我们运行我们的应用程序

911
00:49:12,983 --> 00:49:15,450
没有表情符号，一切都会成为问号，但是

912
00:49:15,519 --> 00:49:18,954
该卡应翻转。这是我们的全部

913
00:49:19,023 --> 00:49:23,091
用户界面，这是我们的控制器，就是这样。

914
00:49:23,160 --> 00:49:26,696
这里是我们的模型在这里，再加上我们有卡，

915
00:49:26,764 --> 00:49:28,698
这跟踪了isMatched和

916
00:49:28,766 --> 00:49:30,632
做这个标识符。那么让我们来看看

917
00:49:30,701 --> 00:49:33,302
让我们来运行这个，确保我们没有破坏任何东西。

918
00:49:33,370 --> 00:49:36,071
当你制作MVC并把它分开时总是很好的，

919
00:49:36,140 --> 00:49:38,640
试着让你的模型做一些简单的事情。

920
00:49:38,709 --> 00:49:42,178
就这样你可以确保你的MVC实际上工作。

921
00:49:42,246 --> 00:49:46,148
在这里我们去，果然，这似乎是翻转这些

922
00:49:46,216 --> 00:49:50,785
卡片结束。好的，很好，所以我们需要，

923
00:49:50,854 --> 00:49:55,257
我们还有两件事情要做。一，在这些卡上得到表情符号，

924
00:49:55,326 --> 00:49:59,662
两个，让它真正匹配，使之成为一个真正的游戏。

925
00:49:59,730 --> 00:50:02,831
有一件事是控制器的东西，表情符号，

926
00:50:02,900 --> 00:50:06,768
另一件事是模型。所以我们去我们的控制器

927
00:50:06,837 --> 00:50:10,772
在这里，做这个表情符号的事情。现在在教你和

928
00:50:10,841 --> 00:50:12,574
向你展示这个表情符号的东西，我会告诉你和

929
00:50:12,643 --> 00:50:15,644
教你如何使用字典。一本字典，

930
00:50:15,713 --> 00:50:17,012
云，这是非常重要的，

931
00:50:17,081 --> 00:50:19,147
大家都知道字典是什么吗？

932
00:50:19,216 --> 00:50:21,883
就像一个哈希表，它只是一个数据结构，你可以

933
00:50:21,952 --> 00:50:25,053
看点什么，并为某件事情获得价值。

934
00:50:25,122 --> 00:50:26,554
所以我们要用字典

935
00:50:26,623 --> 00:50:30,592
我们的字典看起来像这样，我会把它称为表情符号，

936
00:50:30,661 --> 00:50:33,828
它的类型将成为一个字典。

937
00:50:33,897 --> 00:50:36,965
现在，字典也是一个类似数组的泛型，但是

938
00:50:37,034 --> 00:50:40,035
你指定的键，我要去的类型

939
00:50:40,103 --> 00:50:43,672
有一个int，因为这将是一个卡的标识符，和

940
00:50:43,741 --> 00:50:48,477
该值是一个字符串，一个表情符号。

941
00:50:48,545 --> 00:50:51,213
所以这个表情符号字典，我要查找卡

942
00:50:51,282 --> 00:50:54,883
标识符以获取该卡片上的表情符号。

943
00:50:54,951 --> 00:50:57,719
每个人都知道，在我们移动之前，要明白

944
00:50:57,788 --> 00:51:01,823
在这。那么如何创建这些字典中的一个，

945
00:51:01,892 --> 00:51:04,126
和我用数组完全一样。

946
00:51:04,195 --> 00:51:05,694
我只是要打开括号，

947
00:51:05,763 --> 00:51:08,063
关闭括号，创建一个空的字典。

948
00:51:08,132 --> 00:51:12,133
所以这是一个映射到字符串的整数字典，但是

949
00:51:12,202 --> 00:51:14,937
它是空的。现在在这里以表情符号

950
00:51:15,006 --> 00:51:19,174
我只是要看这本字典和

951
00:51:19,243 --> 00:51:23,612
拿一张卡。所以，让我们说选择表情符号和

952
00:51:23,681 --> 00:51:26,314
这里是你在字典中查找的东西。你说

953
00:51:26,383 --> 00:51:28,817
字典的名称，方括号，

954
00:51:28,886 --> 00:51:32,554
你想看的东西。这最好是一个整数，

955
00:51:32,623 --> 00:51:34,689
因为这是一个查询字典

956
00:51:34,758 --> 00:51:37,392
整数，并给你回串，这将是

957
00:51:37,461 --> 00:51:40,796
一个字符串。如果我点击，点击这个选项，

958
00:51:40,865 --> 00:51:44,299
这是一个字符串，显然不是，或者我不会

959
00:51:44,368 --> 00:51:47,969
问这个问题。让我们看看这个选择的表情符号是什么，

960
00:51:48,038 --> 00:51:51,773
你认为这将是一个字符串，哦，那是什么？什么

961
00:51:51,842 --> 00:51:56,578
类型是，任何人想冒险，我听到它在那里

962
00:51:56,646 --> 00:52:01,616
低声说，一个可选。它返回一个可选的，为什么呢

963
00:52:01,685 --> 00:52:04,319
返回一个可选的而不是返回一个字符串？善于

964
00:52:04,388 --> 00:52:07,222
当然，因为当我们在字典中查找某些东西时，

965
00:52:07,291 --> 00:52:09,624
它可能不在那里。

966
00:52:09,693 --> 00:52:11,493
我们抬头的东西不一定在那里，而且

967
00:52:11,562 --> 00:52:15,030
如果它不在那里，我们会回来没有设置，

968
00:52:15,098 --> 00:52:18,066
可选不设。如果它在那里，我们会得到

969
00:52:18,135 --> 00:52:21,036
可选的集合，它将会是一个字符串

970
00:52:21,105 --> 00:52:24,039
相关的价值，因为当然，一个字符串是在什么

971
00:52:24,107 --> 00:52:27,643
词典。每个人，都明白，看

972
00:52:27,711 --> 00:52:29,745
在字典中的东西返回一个可选的。

973
00:52:30,881 --> 00:52:32,747
顺便说一下，看到这样的事情，

974
00:52:32,816 --> 00:52:35,317
你知道我们如何有特殊的数组语法，

975
00:52:35,385 --> 00:52:37,952
打开方括号，键入数组中的位。

976
00:52:38,021 --> 00:52:39,388
我们对字典有同样的事情，

977
00:52:39,457 --> 00:52:40,956
它看起来像这样，方括号开放。

978
00:52:41,025 --> 00:52:45,593
打开方括号，关键，

979
00:52:45,662 --> 00:52:50,499
冒号，值的类型。所以那是，

980
00:52:50,568 --> 00:52:52,834
字典和字符串是我们最常见的东西，

981
00:52:52,903 --> 00:52:55,571
我们正在使用的数据结构。所以我们有特殊的语法

982
00:52:55,639 --> 00:52:58,440
他们两个，所以这是一个字典的声明。

983
00:52:58,508 --> 00:53:00,742
这和我刚才所说的完全一样，

984
00:53:00,811 --> 00:53:04,546
字典，整数，字符串。

985
00:53:04,615 --> 00:53:08,116
所以我们可以，因为我们知道这返回，

986
00:53:08,185 --> 00:53:11,786
这个东西是可选的，我们可以做，如果放在这里。但

987
00:53:11,855 --> 00:53:14,022
我会告诉你一个不同的方式来处理可选。所以

988
00:53:14,090 --> 00:53:16,258
你知道如何做感叹号，我们肯定

989
00:53:16,327 --> 00:53:18,394
不想在这里做。因为，例如，

990
00:53:18,462 --> 00:53:21,163
这本字典开始是空的，所以如果我们感叹

991
00:53:21,232 --> 00:53:24,533
指向这里，每次都会崩溃，所以这是不好的。

992
00:53:24,601 --> 00:53:26,968
我们可以做，如果让，这将是安全的，但我会

993
00:53:27,037 --> 00:53:29,471
告诉你我们经常处理的另一种方式

994
00:53:29,540 --> 00:53:32,741
可能是可选的。是我们只是看看，

995
00:53:32,809 --> 00:53:37,613
如果这个东西不等于零，那么我们可以感叹

996
00:53:37,681 --> 00:53:43,184
指出它。我可以返回这个东西感叹号，和

997
00:53:43,253 --> 00:53:48,423
这是安全的，因为我检查，以确保它不是第一。

998
00:53:48,492 --> 00:53:50,559
所以这是另一种处理可选项的方法，只需检查和

999
00:53:50,628 --> 00:53:51,526
确保它不是零，和

1000
00:53:51,595 --> 00:53:53,829
那么你可以感叹号呢。然后呢，

1001
00:53:53,898 --> 00:53:57,165
我猜如果我们在字典中找不到表情符号，我们会的

1002
00:53:57,234 --> 00:54:00,568
只是返回问号，所以我们会放弃和

1003
00:54:00,637 --> 00:54:04,840
只是显示问号。现在，这个代码是很常见的想要的

1004
00:54:04,909 --> 00:54:07,809
得到一些可选的东西

1005
00:54:07,878 --> 00:54:11,813
如果不是，如果它被设置，然后使用它。但是如果没有设定，

1006
00:54:11,882 --> 00:54:14,816
做一些这样的明确的事情，但你可以

1007
00:54:14,885 --> 00:54:17,819
写一个特殊的操作符，看起来像这样。

1008
00:54:17,888 --> 00:54:22,591
回来，这个东西就在这里。

1009
00:54:26,263 --> 00:54:29,697
但如果是零，问号，问号，

1010
00:54:29,766 --> 00:54:34,369
返回一个不同的东西。所以这是返回这个，但是

1011
00:54:34,438 --> 00:54:37,305
如果它是零返回这个。很常见，

1012
00:54:37,374 --> 00:54:41,443
这完全一样的代码，完全一样。所以

1013
00:54:41,512 --> 00:54:44,879
我们不需要那个，每个人都有这个语法，

1014
00:54:44,948 --> 00:54:49,251
这样做很常见。所以我们很好看

1015
00:54:49,319 --> 00:54:52,253
在我们的表情符号字典和

1016
00:54:52,322 --> 00:54:55,490
希望能够返回表情符号。但是我们从来不放东西

1017
00:54:55,559 --> 00:54:58,060
在那本字典中，所以总是会返回一个问题

1018
00:54:58,128 --> 00:55:00,462
马克，那么我们怎么把东西放在字典里呢？

1019
00:55:00,531 --> 00:55:03,899
好吧，我会按需求把它们放在字典里，

1020
00:55:03,967 --> 00:55:06,435
因为它们被使用。所以每次有人问我

1021
00:55:06,504 --> 00:55:08,036
卡片上的表情符号，我要检查和

1022
00:55:08,104 --> 00:55:13,007
看到。如果该卡的表情符号目前为零，

1023
00:55:13,076 --> 00:55:16,778
那么我会在那张卡片的字典里放一个表情符号。

1024
00:55:16,847 --> 00:55:21,049
所以我正好赶上这本词典，

1025
00:55:21,118 --> 00:55:24,285
现在，我该怎么做？我将要采取其中之一

1026
00:55:24,354 --> 00:55:27,956
随机放在这本字典中，让我们来看看

1027
00:55:28,025 --> 00:55:33,195
一个随机指标。我会让randomIndex等于什么

1028
00:55:33,264 --> 00:55:36,865
我要使用这个很好的Swift函数

1029
00:55:36,934 --> 00:55:38,933
arc4rando_uniform。

1030
00:55:39,002 --> 00:55:41,603
所以arc4rando_uniform是一个伪随机数

1031
00:55:41,672 --> 00:55:44,539
发生器，它会产生一个0到0之间的随机数

1032
00:55:44,608 --> 00:55:47,075
这个上限。你看它说了吗_uppe_bound，

1033
00:55:47,144 --> 00:55:48,977
这是一个无符号整数，32位整数。

1034
00:55:49,046 --> 00:55:51,613
它会产生一个0到0之间的随机数，

1035
00:55:51,682 --> 00:55:55,350
不包括那个数字。这正是我想要的，

1036
00:55:55,419 --> 00:55:58,820
上限是多少，这个数组有多少？

1037
00:55:58,889 --> 00:56:01,757
因为我想索引到这个数组之间的零和

1038
00:56:01,825 --> 00:56:05,160
然而，很多东西在数组中减去一个。所以在这里，

1039
00:56:05,228 --> 00:56:05,827
上限，

1040
00:56:05,896 --> 00:56:10,198
我只是会说emojiChoices.count。

1041
00:56:10,266 --> 00:56:14,236
现在这是伟大的，但它不工作。我得到一个错误，

1042
00:56:14,304 --> 00:56:17,639
这个错误是什么意思？它说不能转换价值

1043
00:56:17,707 --> 00:56:22,344
int类型为意外参数类型无符号32位

1044
00:56:22,413 --> 00:56:27,115
INT。我们随机完全只能使用未签名的整数。

1045
00:56:27,184 --> 00:56:32,354
而这个数组的数量是一个int。不是一个无符号的int。

1046
00:56:32,423 --> 00:56:35,924
Swift永远不会自动进行类型转换。

1047
00:56:35,993 --> 00:56:38,526
它永远不会自动转换为无符号

1048
00:56:38,595 --> 00:56:41,696
从双进入。你必须明确地转换它。

1049
00:56:41,765 --> 00:56:43,999
那么如何在Swift中转换类型呢？

1050
00:56:44,068 --> 00:56:45,267
这就是为什么我这样向你展示

1051
00:56:45,336 --> 00:56:47,402
你会知道如何在Swift中转换类型

1052
00:56:47,470 --> 00:56:50,072
你必须创造一个新的东西

1053
00:56:50,140 --> 00:56:53,007
使用这个新东西的初始化器来创建一个。所以

1054
00:56:53,076 --> 00:56:58,246
在这里，我想创建一个uint32，一个unsigned int 32.所以我有

1055
00:56:58,315 --> 00:57:03,485
调用uint32初始化程序来创建一个uint32。幸运的是，

1056
00:57:03,554 --> 00:57:07,389
uint32，这是一个结构，顺便说一句，就像INT，

1057
00:57:07,457 --> 00:57:09,957
就像字符串一样，就像数组一样，就像字典一样，

1058
00:57:10,026 --> 00:57:12,894
就像卡片一样。这些都是结构。

1059
00:57:12,963 --> 00:57:15,630
它有一个初始化程序，它接受一个int。

1060
00:57:15,699 --> 00:57:19,734
正是我想要的，好吗？所以我可以通过创建一个UInt32

1061
00:57:19,803 --> 00:57:21,636
传递一个int emojiChoices。

1062
00:57:21,705 --> 00:57:23,905
这就是为什么它在这里建议这个修复。

1063
00:57:23,974 --> 00:57:27,175
所以我会这样做，修复。你看看它做了什么？ UInt32的，

1064
00:57:27,244 --> 00:57:30,345
打开括号。它的init的参数是一个Int。

1065
00:57:30,414 --> 00:57:33,015
它知道如何做到这一点。现在我们还没有。

1066
00:57:33,083 --> 00:57:35,517
因为在这里查看返回值，randomIndex。

1067
00:57:35,585 --> 00:57:38,086
这也是一个无符号整数，这是不好的。

1068
00:57:38,155 --> 00:57:41,623
因为我想用它作为这个数组的索引。和

1069
00:57:41,692 --> 00:57:43,791
我们知道索引不是无符号整数，

1070
00:57:43,860 --> 00:57:47,495
尽管他们应该是。他们是整数。好的，

1071
00:57:47,564 --> 00:57:50,766
主要是为了向后兼容性问题。

1072
00:57:50,834 --> 00:57:55,203
所以我需要把这整个事情转换为一个int，幸运的是

1073
00:57:55,272 --> 00:57:59,974
int有一个初始化程序，将采取一个无符号整数和

1074
00:58:00,043 --> 00:58:04,913
把它变成一个整数。好的，现在我在这里有随机索引。

1075
00:58:04,981 --> 00:58:08,583
这是一个int，它适合索引到这个数组中。

1076
00:58:08,652 --> 00:58:12,620
那是一个随机指标。所以为了得到它，我可以说表情符号

1077
00:58:12,689 --> 00:58:16,892
sub card.identifier。现在把东西放在字典里。

1078
00:58:16,960 --> 00:58:20,795
你只是说平等和你想要的东西。表情符号，

1079
00:58:20,864 --> 00:58:25,266
选择，分，随机，索引。但我不是，这不完全

1080
00:58:25,335 --> 00:58:27,769
我要做什么这将是一种工作。

1081
00:58:27,838 --> 00:58:31,006
唯一的问题是，我可以得到两个标识符

1082
00:58:31,075 --> 00:58:34,576
使用相同的表情符号。所以，而不是只是抓住

1083
00:58:34,645 --> 00:58:38,580
这里有东西，我要删除它。好的，当我使用

1084
00:58:38,649 --> 00:58:40,915
其中一个emojis，我要把它从这里删除

1085
00:58:40,984 --> 00:58:44,586
我再也不用它了。所以要做到这一点，我要使用

1086
00:58:44,655 --> 00:58:47,288
一个不同于下标的方法

1087
00:58:47,357 --> 00:58:52,460
删除。我只是要随机索引删除。

1088
00:58:52,529 --> 00:58:55,797
所以删除返回的东西，它被删除。所以它会

1089
00:58:55,865 --> 00:58:58,266
从这里挑出这些表情符号之一，并将其​​返回。

1090
00:58:58,335 --> 00:59:01,370
我会把它放在字典里。每个人都得到了

1091
00:59:01,438 --> 00:59:04,339
那？现在只有一件事了，

1092
00:59:04,407 --> 00:59:07,442
这是如果emojiChoices.count为零。

1093
00:59:07,511 --> 00:59:10,045
换句话说，如果我已经使用了所有的表情符号

1094
00:59:10,113 --> 00:59:12,447
在emojiChoices中，我把它们都拉出去了吗？

1095
00:59:12,516 --> 00:59:15,283
这会导致一个问题。跑了，arc4random不能

1096
00:59:15,352 --> 00:59:18,687
取零，因为它从零到这个数字减1。

1097
00:59:18,755 --> 00:59:21,522
它是一个无符号整数，所以它不能是一个负数。

1098
00:59:21,591 --> 00:59:23,591
所以我们必须防范这种情况。

1099
00:59:23,660 --> 00:59:28,029
所以我会说如果emojichoices.count

1100
00:59:28,097 --> 00:59:30,732
大于0，那么我可以抓住

1101
00:59:30,801 --> 00:59:33,635
一个表情符号出来并使用它。但如果

1102
00:59:33,704 --> 00:59:36,971
它不是那个，如果它等于0，那么我不能这样做。

1103
00:59:37,040 --> 00:59:39,975
然后我在这里用问号卡住了。通过

1104
00:59:40,043 --> 00:59:42,477
在Swift的方式很酷的事情，你看我们如何回到

1105
00:59:42,546 --> 00:59:46,881
回到这里。你可以把它们放回原处

1106
00:59:46,950 --> 00:59:51,253
通过用逗号分隔它们，好吧，

1107
00:59:51,321 --> 00:59:54,155
那么你不需要那里嵌入的ifs。

1108
00:59:54,224 --> 00:59:56,858
尤其是当事情相关时，比如外表

1109
00:59:56,927 --> 00:59:59,761
在这个代码片段如何读取。如果是表情符号

1110
00:59:59,829 --> 01:00:02,530
这个卡片标识符没有被设置

1111
01:00:02,599 --> 01:00:08,736
如果我们有表情符号，那么去拿一个，好吗？

1112
01:00:08,805 --> 01:00:11,272
好吧，让我们看看这是否有效。我们去跑步吧

1113
01:00:11,341 --> 01:00:14,675
看看我们是否抓取了一个随机的表情符号，然后放

1114
01:00:14,744 --> 01:00:18,513
他们在我们的四个卡之一。这是伪随机的，

1115
01:00:18,582 --> 01:00:20,548
所以你会看到它不是超级随机的。

1116
01:00:20,617 --> 01:00:22,183
但无论如何，好吧，让我们来看看。

1117
01:00:22,252 --> 01:00:26,154
噢，看，我们有一个随机的表情符号。哦还有另一个，

1118
01:00:26,223 --> 01:00:29,791
小糖果，希望这两个是一样的，耶！好的

1119
01:00:29,860 --> 01:00:33,161
所以它的工作。好的，它是通过标识符来查找的，

1120
01:00:33,230 --> 01:00:36,164
选择表情符号和使用该表情符号作为标识符

1121
01:00:36,233 --> 01:00:38,466
在所有卡上。希望它是随机的。我们再来一次

1122
01:00:38,535 --> 01:00:41,603
所以我们有这个魔鬼家伙和糖果

1123
01:00:41,671 --> 01:00:45,440
伪随机发生器做你的手指，

1124
01:00:45,509 --> 01:00:48,643
让我们来看看。哦，魔鬼家伙，哦，我们得到了猫，

1125
01:00:48,711 --> 01:00:52,280
害怕的猫或者别的什么，尖叫的猫。所以

1126
01:00:52,349 --> 01:00:54,182
我们正在随机，这看起来像在工作。

1127
01:00:54,251 --> 01:00:56,217
所以我们在这里已经有了我们的用户界面。

1128
01:00:56,286 --> 01:00:58,687
所以唯一剩下的事情就是现在

1129
01:00:58,756 --> 01:01:00,354
是使这个事情发挥浓度和

1130
01:01:00,423 --> 01:01:02,457
这纯粹是一个模范的事情。所以要做

1131
01:01:02,525 --> 01:01:05,594
那个工作我将要提出我的模型。和

1132
01:01:05,662 --> 01:01:07,929
我只是将代码放在我的模型中。

1133
01:01:07,998 --> 01:01:10,699
现在它翻转卡片。我们会阻止的

1134
01:01:10,768 --> 01:01:13,869
相反，我们会让它玩这个游戏。和

1135
01:01:13,937 --> 01:01:16,337
作为实现这一点的一部分，我会使用一个可选的。

1136
01:01:16,406 --> 01:01:17,872
因为我知道你们都还没有

1137
01:01:17,941 --> 01:01:20,342
这个问这个问题的人你们都还没有

1138
01:01:20,410 --> 01:01:21,877
相当肯定我了解可选的事情。

1139
01:01:21,945 --> 01:01:24,946
所以这里有一个机会，我将使用一个可选项

1140
01:01:25,014 --> 01:01:27,849
作为我的基本语义实现的一部分

1141
01:01:27,918 --> 01:01:30,451
这种方法。所以我们走了

1142
01:01:30,520 --> 01:01:34,155
我选择卡片时要做的第一件事是

1143
01:01:34,224 --> 01:01:37,458
我会忽略已经匹配的卡片。所以

1144
01:01:37,527 --> 01:01:39,994
如果您选择已经在板上的卡

1145
01:01:40,063 --> 01:01:42,029
匹配到另一张卡，我只是会忽略它。所以

1146
01:01:42,098 --> 01:01:46,735
我要说，如果你选择的卡，索引卡，

1147
01:01:46,804 --> 01:01:50,739
isMatched。那么我不会这样做，所以

1148
01:01:50,808 --> 01:01:53,107
我要说如果不匹配，那么做，

1149
01:01:53,176 --> 01:01:56,811
如果它匹配，那么不要这样做。这个缺口，

1150
01:01:56,880 --> 01:01:59,481
就像其他语言一样，意味着不是，相反

1151
01:01:59,550 --> 01:02:02,250
这个布尔。我会忽略所有匹配的卡。

1152
01:02:02,319 --> 01:02:05,519
现在我该怎么办？这里有三种情况

1153
01:02:05,588 --> 01:02:10,091
这可能发生。一，没有牌面朝上。如果没有卡

1154
01:02:10,159 --> 01:02:12,894
当我选择一张卡片时，它正面朝上翻转。

1155
01:02:12,962 --> 01:02:16,764
就是这样。另一种选择是两张牌是面对

1156
01:02:16,833 --> 01:02:19,900
不管是匹配还是不匹配。如果这是真的，

1157
01:02:19,969 --> 01:02:22,704
当我选择另一张卡片时，需要将这些卡片翻转过来

1158
01:02:22,773 --> 01:02:27,541
因为我现在开始一场新的比赛。第三个选择是

1159
01:02:27,610 --> 01:02:30,978
有一张牌面朝上，我选择了其他一些卡。

1160
01:02:31,047 --> 01:02:33,882
现在我需要匹配。我需要看看他们是否匹配。

1161
01:02:33,950 --> 01:02:37,585
所以这三个选项。所以我想

1162
01:02:37,654 --> 01:02:40,455
真的跟踪有一张牌的选项

1163
01:02:40,524 --> 01:02:42,691
因为那是我真正要做的工作。

1164
01:02:42,760 --> 01:02:44,392
我必须尝试看看他们是否匹配。所以

1165
01:02:44,461 --> 01:02:47,662
我将创建一个var来跟踪是否有一个和

1166
01:02:47,730 --> 01:02:49,363
只有一张牌正面朝上。

1167
01:02:49,432 --> 01:02:53,067
我打算把它叫做indexOfOneAndOnlyFaceUpCard

1168
01:02:53,136 --> 01:02:59,541
当然它的索引也是一个整数。

1169
01:02:59,609 --> 01:03:03,978
现在是什么indexOfOneAndOnlyFaceUpCard如果

1170
01:03:04,047 --> 01:03:10,218
没有牌面朝上？如果两者有什么价值呢？

1171
01:03:10,286 --> 01:03:14,155
卡面朝上？啊，有趣。

1172
01:03:14,224 --> 01:03:19,393
我认为这是可选的。你明白为什么，因为

1173
01:03:19,462 --> 01:03:22,197
在那些没有一个索引的情况下

1174
01:03:22,266 --> 01:03:25,133
只有面卡，那么这个就不会设置了，

1175
01:03:25,201 --> 01:03:28,603
因为没有唯一的面子卡。所以这

1176
01:03:28,672 --> 01:03:32,473
在这里是一个很好的使用可选项。所以一直在

1177
01:03:32,542 --> 01:03:35,076
我的比赛，当只有一张面朝上的牌时，这个

1178
01:03:35,145 --> 01:03:37,712
去告诉我它的索引，所以我可以匹配它。

1179
01:03:37,780 --> 01:03:40,114
而所有其他时间，这将是n and

1180
01:03:40,183 --> 01:03:42,550
我会知道我不必做任何工作。我不需要

1181
01:03:42,619 --> 01:03:44,652
做任何匹配，因为没有卡匹配

1182
01:03:44,721 --> 01:03:47,522
反对。那么代码是什么样的呢？

1183
01:03:47,590 --> 01:03:50,591
我要说如果我可以让一个匹配指数，

1184
01:03:50,660 --> 01:03:54,295
这是一个局部变量，等于这个指数的一个和

1185
01:03:54,364 --> 01:03:57,665
只有在这里面对卡，然后我有东西

1186
01:03:57,734 --> 01:04:01,135
比赛。顺便说一句，我想确保那场比赛

1187
01:04:01,204 --> 01:04:06,207
该事物的索引不等于您选择的卡片。

1188
01:04:06,276 --> 01:04:08,709
如果只有，只有，如果有一个和

1189
01:04:08,778 --> 01:04:10,979
只有一张牌的脸，你选择了，

1190
01:04:11,047 --> 01:04:13,748
它会忽略这一点。你必须选择一个不同的

1191
01:04:13,817 --> 01:04:19,220
卡。这里面的花括号是，你知道，

1192
01:04:19,289 --> 01:04:24,892
检查卡是否匹配。然后外面这里是什么？

1193
01:04:24,961 --> 01:04:28,129
要么没有卡或

1194
01:04:28,198 --> 01:04:33,734
两张牌正面朝上，所以我无法比拟。所以

1195
01:04:33,803 --> 01:04:36,638
在这种情况下，我需要将牌面朝下

1196
01:04:36,706 --> 01:04:38,673
有你选择的卡是唯一的面朝上卡。

1197
01:04:38,741 --> 01:04:41,008
然后我会把它设置成那个的索引

1198
01:04:41,077 --> 01:04:43,311
只有正视卡。

1199
01:04:43,379 --> 01:04:45,714
我们来做这些吧让我们来看看这些卡是否匹配

1200
01:04:45,782 --> 01:04:52,786
如果卡匹配索引它的标识符真的很容易

1201
01:04:52,855 --> 01:04:57,592
等于您选择的索引的卡片。这是选择卡

1202
01:04:57,661 --> 01:05:01,596
在指数。如果他们匹配，那么我要标记他们匹配。

1203
01:05:01,664 --> 01:05:06,501
比赛指数卡匹配

1204
01:05:06,570 --> 01:05:11,772
你选择的牌是匹配的。

1205
01:05:11,841 --> 01:05:18,412
所以我匹配他们，很好。现在，即使他们不匹配，

1206
01:05:18,481 --> 01:05:21,549
当我在那里选择第二张牌时会发生什么？二

1207
01:05:21,617 --> 01:05:26,621
事情发生了，其中一个，我得把你选择的卡片翻起来。

1208
01:05:26,689 --> 01:05:29,023
因为你选择了一张面朝下的牌，就在那里

1209
01:05:29,092 --> 01:05:32,193
我会说卡子指数是...

1210
01:05:33,697 --> 01:05:37,198
面朝上是真的，因为你选择了一张卡，

1211
01:05:37,267 --> 01:05:39,400
我正在翻转它当然。和第二和

1212
01:05:39,469 --> 01:05:43,337
最重要的是唯一一张面朝上的卡片的索引

1213
01:05:43,406 --> 01:05:48,542
等于零。因为现在有两张匹配的卡片，

1214
01:05:48,611 --> 01:05:51,979
两个，匹配或不匹配，两张面朝上的卡。所以

1215
01:05:52,048 --> 01:05:55,549
没有一张唯一的牌面朝上。所以这是零

1216
01:05:55,618 --> 01:05:58,653
将可选项设置为零是完全合法的。所以那是

1217
01:05:58,721 --> 01:06:00,755
如果卡片匹配我们做什么，这就是我们所要做的。

1218
01:06:00,823 --> 01:06:03,024
现在我们在这里或者没有卡片或者

1219
01:06:03,093 --> 01:06:04,792
两张牌正面朝上。在这种情况下，

1220
01:06:04,861 --> 01:06:07,795
我要把所有的牌面朝下。现在他们可能已经

1221
01:06:07,864 --> 01:06:10,798
都面朝下，但这是一个浪费的工作。

1222
01:06:10,867 --> 01:06:15,636
我只是要去翻转索引，什么？

1223
01:06:15,705 --> 01:06:21,943
在我的卡片的指数。 Cards.indices，

1224
01:06:22,012 --> 01:06:24,679
这就是全部，这是一个可数范围。记得，

1225
01:06:24,747 --> 01:06:29,884
这是所有指标的可数范围

1226
01:06:29,952 --> 01:06:33,321
在我的卡片里。所以对于每一张牌，

1227
01:06:33,389 --> 01:06:39,527
我要说在flipDownIndex.isFaceup = false卡。

1228
01:06:39,596 --> 01:06:43,131
我只是把电路板上的每一张牌都面朝下。

1229
01:06:43,199 --> 01:06:45,766
但现在你已经选择了一张卡，所以我要把这张卡

1230
01:06:45,835 --> 01:06:53,541
你只是选择回来面对。 .isFaceUp = true和

1231
01:06:53,610 --> 01:06:56,944
当然，因为我只是把所有的牌面朝下，

1232
01:06:57,013 --> 01:07:00,414
把一张牌面朝上，那个牌的指数是多少？

1233
01:07:00,483 --> 01:07:04,752
只有正视卡？这是这个指数。我刚刚把它

1234
01:07:04,821 --> 01:07:08,256
因此，按照定义，这是唯一的一张牌。

1235
01:07:08,325 --> 01:07:10,858
这位女士们，先生们，我们到了什么地方？哦，这个

1236
01:07:10,926 --> 01:07:15,229
是cardsindex.identifier来比较标识符。

1237
01:07:15,298 --> 01:07:18,532
这是整个游戏逻辑的集中，

1238
01:07:18,601 --> 01:07:21,502
就是这样，这就是必要的。

1239
01:07:21,571 --> 01:07:23,437
你能看到如何有这个可选的

1240
01:07:23,506 --> 01:07:26,407
这里有点简单明了吗？

1241
01:07:26,475 --> 01:07:29,810
因为我很容易跟踪我想要的卡

1242
01:07:29,879 --> 01:07:32,379
匹配所有的时间。这很容易

1243
01:07:32,448 --> 01:07:35,183
我要告诉你是否有一个反对或者匹配它

1244
01:07:35,251 --> 01:07:37,518
不是，都包含在一个有很多的小变量

1245
01:07:37,587 --> 01:07:41,856
它的信息。就这样，我们去看看我们的

1246
01:07:41,924 --> 01:07:44,325
应用正在工作。它应该只是工作，我的意思是一旦你做

1247
01:07:44,393 --> 01:07:47,561
这个模型，做它想要做的UI不关心。

1248
01:07:47,630 --> 01:07:49,630
这只是展示了模型的内容

1249
01:07:49,699 --> 01:07:52,200
它应该只是工作。所以让我们在这里尝试。好吧，

1250
01:07:52,268 --> 01:07:56,837
我们有这个，猫，哦，有尖叫的脸。

1251
01:07:56,906 --> 01:07:58,873
现在当我点击另一张卡时会发生什么？

1252
01:07:58,941 --> 01:08:00,741
它应该全部面朝下翻转。

1253
01:08:00,810 --> 01:08:02,276
它不匹配，这不匹配，所以

1254
01:08:02,345 --> 01:08:05,213
它应该把这些全部倒下。转动新的脸

1255
01:08:05,281 --> 01:08:07,615
现在，选项将被设置。所以

1256
01:08:07,684 --> 01:08:10,418
让我们试试吧。果然，它把他们全部面朝下

1257
01:08:10,486 --> 01:08:14,589
把这个转了一下。现在如果我选择一场比赛会发生什么？

1258
01:08:14,657 --> 01:08:17,458
现在他们都被标记为匹配。现在下一次我

1259
01:08:17,527 --> 01:08:19,760
点击一张卡片，它会把他们面朝下。

1260
01:08:19,829 --> 01:08:24,365
他们会面朝下和匹配的，所以

1261
01:08:24,434 --> 01:08:28,303
他们会得到一个清晰的背景和

1262
01:08:28,371 --> 01:08:32,973
我们不能看到他们，看。

1263
01:08:33,042 --> 01:08:38,312
现在游戏已经完成了。现在在你的功课，你会去的

1264
01:08:38,381 --> 01:08:40,882
添加一个新的游戏按钮，这是你会按这个

1265
01:08:40,950 --> 01:08:46,354
点。我不会玩另一个游戏。最后一件事

1266
01:08:46,423 --> 01:08:51,492
在这里做，我们幸运的是添加更多的卡。

1267
01:08:51,561 --> 01:08:54,262
因为四张牌就是一种无聊的游戏

1268
01:08:54,331 --> 01:08:59,400
让我们到这里来我们的用户界面。我们有我们的用户界面。我做了我的

1269
01:09:01,771 --> 01:09:05,673
这里的按钮是80点宽，我有点建议你做

1270
01:09:05,742 --> 01:09:08,776
为了你的功课。由于80点宽，

1271
01:09:08,845 --> 01:09:12,747
他们真的很适合四个好吗？让我们把它们

1272
01:09:12,816 --> 01:09:15,816
现在我要用小蓝线来帮助我

1273
01:09:15,885 --> 01:09:21,389
把他们放在这里。如果你用蓝线看，

1274
01:09:21,458 --> 01:09:24,559
其中四个在80分，每个正确的跨越。和

1275
01:09:24,627 --> 01:09:26,126
那么我会再做一些。我要选择他们

1276
01:09:26,195 --> 01:09:29,496
复制粘贴。用百叶窗，蓝线贴一些

1277
01:09:29,565 --> 01:09:31,466
更多的，我们在这里有12个。

1278
01:09:33,202 --> 01:09:36,136
而且我需要确保所有东西都连接好了

1279
01:09:36,205 --> 01:09:38,839
让我们看看像触摸卡。嘿，他们都在发送触摸

1280
01:09:38,908 --> 01:09:43,411
卡，太好了。卡按钮怎么样？当我们复制和

1281
01:09:43,479 --> 01:09:47,682
粘贴它不会把它们放到那个卡片按钮outlet

1282
01:09:47,751 --> 01:09:49,584
按钮数组，所以我们需要这样做。

1283
01:09:49,652 --> 01:09:51,351
所以我只是要按Ctrl +拖动。

1284
01:09:51,420 --> 01:09:56,557
现在，如果你真的有12张牌或超过12张牌

1285
01:09:56,626 --> 01:09:59,527
生活，你可能不会使用一个outlet集合。

1286
01:09:59,595 --> 01:10:03,064
你可能会去你的代码，并找到所有这些

1287
01:10:03,133 --> 01:10:04,698
事情，你可以做一个或所有的一切

1288
01:10:04,767 --> 01:10:07,301
两行代码实际上。但是，你真的没有学到

1289
01:10:07,370 --> 01:10:10,537
关于视图层次结构如何工作，我已经足够了

1290
01:10:10,606 --> 01:10:13,007
所有这些事情要做到这一点。所以你的作业

1291
01:10:13,075 --> 01:10:15,443
你只需要做一些控制拖动

1292
01:10:15,512 --> 01:10:19,380
就像我要把他们勾起来一样。他们都迷上了，

1293
01:10:19,448 --> 01:10:22,183
他们都迷上了。我们的翻盖计数标签挂钩了。

1294
01:10:22,252 --> 01:10:25,286
我们的用户界面看起来都设置我没有改变任何东西，但

1295
01:10:25,354 --> 01:10:30,324
那。我没有去任何地方改变任何代码。好吧，我只是

1296
01:10:30,392 --> 01:10:32,827
把更多的按钮在我的用户界面。而且因为我建立了这个不错的

1297
01:10:32,895 --> 01:10:37,799
灵活的用户界面，可以真正处理任何数量的卡，

1298
01:10:37,867 --> 01:10:46,374
这应该只是工作。开始了，

1299
01:10:46,443 --> 01:10:49,977
咱们试试吧。我们得到了糖果，苹果，

1300
01:10:50,046 --> 01:10:54,882
没有匹配。我有蝙蝠，没有匹配。

1301
01:10:54,951 --> 01:11:01,021
南瓜怎么样？哦，糖果，我想我记得糖果，

1302
01:11:01,090 --> 01:11:04,725
这可能就在这里吗？是，

1303
01:11:04,794 --> 01:11:07,795
呜呜，我们发现糖果是相邻的。

1304
01:11:07,863 --> 01:11:11,365
让我们试试别的。好的，这个怎么样，苹果，

1305
01:11:11,433 --> 01:11:16,604
不，不匹配。哦，苹果哦，这是一个非常简单的游戏。

1306
01:11:16,673 --> 01:11:18,505
我不知道为什么每个人都认为浓度是如此

1307
01:11:18,574 --> 01:11:20,174
努力，看看。好的，

1308
01:11:20,242 --> 01:11:24,312
全做完了。那么为什么这个游戏如此简单？

1309
01:11:24,380 --> 01:11:27,882
那么，因为你们还没有完成你的功课，

1310
01:11:27,951 --> 01:11:31,719
如果你还记得这里，我们有集中

1311
01:11:31,788 --> 01:11:37,124
这一点做。顺便说一句，是一个特别的评论。

1312
01:11:37,193 --> 01:11:40,194
如果你在这里看看你的事情的最上面一行，哪一个

1313
01:11:40,262 --> 01:11:42,797
显示你正在选择的文件。它也显示你

1314
01:11:42,865 --> 01:11:46,533
在那个文件中包含你所有的方法和属性

1315
01:11:46,602 --> 01:11:51,906
如果你把/ /做，它显示出来。看到洗牌。

1316
01:11:51,975 --> 01:11:55,242
好的，星期一见。 >>对于

1317
01:11:55,311 --> 01:12:04,718
更多，请访问Stanford.edu。

