1
00:00:00,401 --> 00:00:03,568
[MUSIC]

2
00:00:03,637 --> 00:00:07,239
斯坦福大学。好的，

3
00:00:07,307 --> 00:00:12,311
欢迎来到斯坦福CS193P第三讲，

4
00:00:12,379 --> 00:00:16,447
2017年秋季和18学年。

5
00:00:16,516 --> 00:00:19,885
今天大多数时候，我们要谈谈一些Swift的东西。

6
00:00:19,953 --> 00:00:23,321
现在，你有希望完成你的阅读功课，

7
00:00:23,390 --> 00:00:25,891
所以一些东西将有点总结，但是

8
00:00:25,959 --> 00:00:28,560
这其中的一些内容在阅读中并没有涉及到。

9
00:00:28,629 --> 00:00:32,197
所以我试图给你的东西的全貌，

10
00:00:32,266 --> 00:00:36,201
阅读真的很棒，但很简洁。

11
00:00:36,270 --> 00:00:37,201
我知道你可能感觉很好，

12
00:00:37,270 --> 00:00:39,171
这是一个简洁的东西，但是，阅读很多

13
00:00:39,240 --> 00:00:41,473
这是相当简洁的。所以我会尝试和

14
00:00:41,541 --> 00:00:43,909
覆盖一些其他的东西。但是在我这样做之前，

15
00:00:43,977 --> 00:00:46,912
我会做一些，我称之为传情演示

16
00:00:46,981 --> 00:00:50,115
自动布局，我要告诉你我们怎么做

17
00:00:50,184 --> 00:00:53,919
当我们旋转手机时，我们的用户界面看起来不错，

18
00:00:53,987 --> 00:00:57,355
或者当我们运行一点不同大小的iPhone，或者

19
00:00:57,424 --> 00:01:01,226
随你。我把它称为传情，因为我不打算

20
00:01:01,295 --> 00:01:04,295
教你自动布局，这是允许的功能

21
00:01:04,364 --> 00:01:06,765
我们这样做。这只是为了告诉你什么是可能的。

22
00:01:06,833 --> 00:01:09,034
我们实际上将有一个关于汽车的整个讲座

23
00:01:09,103 --> 00:01:13,204
我认为在三个星期左右的布局。但是之后，

24
00:01:13,273 --> 00:01:15,907
在我做了这个小演示之后，我会回来的。我第一次会

25
00:01:15,976 --> 00:01:18,577
花一分钟时间回顾一下你应该拥有的东西

26
00:01:18,645 --> 00:01:21,513
通过我们上周做的事情学习，我简直就是

27
00:01:21,582 --> 00:01:24,482
要用简单的例子把它读出来。你可以

28
00:01:24,551 --> 00:01:26,818
有种说在你的脑海里，哦，是的，是的，我明白了，

29
00:01:26,887 --> 00:01:29,454
我知道了，或者等等，我真的不明白这一点

30
00:01:29,523 --> 00:01:31,390
这是一个提示回去看看它。

31
00:01:31,458 --> 00:01:34,626
然后，我们将深入你在这里看到的这个长长的名单，

32
00:01:34,694 --> 00:01:38,163
各种Swift的东西。那么让我们从这个演示开始

33
00:01:38,232 --> 00:01:41,232
在谈论这个自动布局演示。

34
00:01:41,301 --> 00:01:45,770
我们要在这里做什么，我为任何技术道歉

35
00:01:45,839 --> 00:01:48,873
我们在这里遇到的问题，实际上，我的电脑死了，

36
00:01:48,942 --> 00:01:51,008
我必须把它。这是全新的电脑，所以

37
00:01:51,077 --> 00:01:54,512
我希望一切都安装正确。但是这里的代码，

38
00:01:54,581 --> 00:01:58,016
我想，就是我们在最后一次演讲结束时所做的。

39
00:01:58,085 --> 00:02:01,986
用户界面看起来不错。我们摆脱了。

40
00:02:02,055 --> 00:02:04,156
但我只是通过拖拽这些东西来做到这一点

41
00:02:04,224 --> 00:02:06,624
用小短划线把它们放在一起

42
00:02:06,693 --> 00:02:11,763
在位。而当我们运行这个东西，它看起来还好，但是

43
00:02:11,832 --> 00:02:13,464
只在iPhone X和

44
00:02:13,533 --> 00:02:16,534
只有像这样的肖像模式。如果我是为了

45
00:02:16,603 --> 00:02:20,772
例如，旋转这个iPhone到我可以做的一面

46
00:02:20,841 --> 00:02:23,742
在模拟器中，通过硬件，向左旋转或

47
00:02:23,811 --> 00:02:28,579
对，你可以看到我的用户界面看起来像这样。我的按钮

48
00:02:28,648 --> 00:02:31,983
在这里的角落里都挤满了人。我失去了翻转，

49
00:02:32,052 --> 00:02:34,285
它在这里某处我什至不能看到它。

50
00:02:34,354 --> 00:02:37,756
仍然有效，但是在中途没有任何意义。

51
00:02:37,824 --> 00:02:40,826
我们真正想要的是这个UI自我传播

52
00:02:40,894 --> 00:02:44,762
并填充整个涉及的空间。顺便一提，

53
00:02:44,831 --> 00:02:47,766
您也可以使用Command和

54
00:02:47,835 --> 00:02:51,102
箭头。一种很酷的方式来翻转和

55
00:02:51,171 --> 00:02:54,305
向前。好的，那么我们该怎么做呢？

56
00:02:54,374 --> 00:02:57,209
我们如何扩大UI？让我们继续

57
00:02:57,277 --> 00:02:59,444
打开这里，给自己更多的空间。

58
00:02:59,513 --> 00:03:00,846
而且我也会放大一点

59
00:03:00,914 --> 00:03:03,949
你可以看到。我要做的另一件事是我们会成为的

60
00:03:04,018 --> 00:03:06,150
用这些蓝线，蓝色的虚线

61
00:03:06,219 --> 00:03:09,488
当你移动东西时出现的一行，作为它的一部分。

62
00:03:09,556 --> 00:03:12,256
所以我会改变我的背景从黑色

63
00:03:12,325 --> 00:03:15,494
暂时回白，就这样

64
00:03:15,563 --> 00:03:18,296
我们可以看到那些蓝线和

65
00:03:18,364 --> 00:03:20,331
东西好一点。所以我只会去白色。

66
00:03:20,400 --> 00:03:22,400
当我们运行的时候，我会把它变回黑色。

67
00:03:22,469 --> 00:03:27,104
所以这纯粹是为了解决发展问题。所以

68
00:03:27,173 --> 00:03:31,009
为了完成这项工作，我需要做两件事。

69
00:03:31,077 --> 00:03:35,246
一个是，我需要采取所有这些按钮和

70
00:03:35,315 --> 00:03:37,249
让他们坚持到最后，对吧？

71
00:03:37,318 --> 00:03:38,483
所以，当他们旋转和

72
00:03:38,552 --> 00:03:42,287
边缘变得更长，更瘦，他们坚持。

73
00:03:42,355 --> 00:03:45,390
现在，一切都卡在左上角。

74
00:03:45,458 --> 00:03:47,258
左上角，你会发现下周，

75
00:03:47,327 --> 00:03:50,829
是绘画的起源。在IOS里，一切都是有点儿的

76
00:03:50,897 --> 00:03:52,998
卡在左上方，然后恰好如此

77
00:03:53,066 --> 00:03:55,600
当我们旋转它时，它只是从底部，

78
00:03:55,668 --> 00:03:58,536
我们看不到它。所以这真的是我们需要做的，但是

79
00:03:58,605 --> 00:03:59,904
坚持他们的边缘，

80
00:03:59,973 --> 00:04:02,807
我们也需要将它们组合在一起。因为当

81
00:04:02,876 --> 00:04:05,544
边缘将这组12个按钮分开，

82
00:04:05,613 --> 00:04:07,812
他们都需要分享这个空间。

83
00:04:07,881 --> 00:04:09,581
所以有两件事我们必须做。

84
00:04:09,650 --> 00:04:12,584
一个是把他们组合在一起，一个是把他们钉在边缘。

85
00:04:12,653 --> 00:04:17,756
所以我们要在IOS中使用两种不同的功能。

86
00:04:17,824 --> 00:04:19,257
一，把事情分在一起，

87
00:04:19,326 --> 00:04:22,227
我们要做堆栈视图。好的，那么UI堆栈视图

88
00:04:22,296 --> 00:04:26,231
就像iOS中的另一个类UI Button是一个类和

89
00:04:26,300 --> 00:04:29,734
UI标签实际上只是另一种视图。和

90
00:04:29,803 --> 00:04:32,770
它会做什么，会采取其他意见，如让我们

91
00:04:32,839 --> 00:04:36,508
说这四个按钮，并将它们堆叠在一起。

92
00:04:36,577 --> 00:04:39,244
现在，它只知道如何水平堆叠或

93
00:04:39,313 --> 00:04:42,981
垂直。它不能将这些东西中的12个堆叠在一起

94
00:04:43,050 --> 00:04:45,950
这样的尺寸。所以我必须做三个

95
00:04:46,019 --> 00:04:50,155
水平堆栈出这个组，出这个组，和

96
00:04:50,223 --> 00:04:53,024
在这个小组之外。但是，我会拿这三个堆栈

97
00:04:53,092 --> 00:04:55,794
并垂直堆叠。因为这是完美的罚款

98
00:04:55,863 --> 00:04:59,230
堆栈里面，好吗？一旦我这样做，

99
00:04:59,299 --> 00:05:02,667
我将把所有12种这些种类放在一起。和

100
00:05:02,736 --> 00:05:05,803
然后我可以把它钉在边缘，他们会伸出。所以

101
00:05:05,872 --> 00:05:07,405
我们如何使这个堆栈使用？

102
00:05:07,473 --> 00:05:10,074
超级简单，你只需在这里选择它。让我放大

103
00:05:10,143 --> 00:05:12,977
我们可以真正看到这里发生了什么。我们只需要顶部

104
00:05:13,046 --> 00:05:15,347
现在的一部分。所以我取消了这四件事。

105
00:05:15,416 --> 00:05:17,215
我正在这里按下这个按钮。

106
00:05:17,284 --> 00:05:19,751
你看到这个按钮，嵌入和堆叠？

107
00:05:19,820 --> 00:05:22,020
那么，这就是它的作用。它嵌入在堆栈中。

108
00:05:22,089 --> 00:05:24,188
它嵌入它。现在，几件事情。

109
00:05:24,257 --> 00:05:27,392
一个是，它使得按钮尽可能小，当你把它

110
00:05:27,460 --> 00:05:30,028
在堆栈中。它有50点字体，请记住

111
00:05:30,097 --> 00:05:32,730
那些emojis。所以这就和他们一样小。

112
00:05:32,799 --> 00:05:36,434
它之间也没有间隔。但我可以把间距

113
00:05:36,503 --> 00:05:40,638
只需选择它即可。之后被选中

114
00:05:40,707 --> 00:05:43,809
我堆积并且因为这个去检查员

115
00:05:43,877 --> 00:05:47,145
堆栈视图，就像一个按钮，可以检查，

116
00:05:47,213 --> 00:05:49,881
对？你可以看到它横向，

117
00:05:49,950 --> 00:05:52,617
它有点注意到我的按钮大多是水平的。所以

118
00:05:52,686 --> 00:05:57,522
它采取水平。所以这里是我如何设置间距。

119
00:05:57,590 --> 00:06:00,492
我下去我会用一个标准的间距。

120
00:06:00,560 --> 00:06:03,027
当你在UI设计的地方有很多地方

121
00:06:03,096 --> 00:06:05,463
你可以选择一个UI标准值和

122
00:06:05,532 --> 00:06:07,498
它会选择一个标准的间距。

123
00:06:07,567 --> 00:06:09,167
这是按钮之间的标准间距。

124
00:06:09,235 --> 00:06:11,336
你想尽可能地使用它。

125
00:06:11,404 --> 00:06:14,005
这样，你的用户界面将像其他用户界面和

126
00:06:14,074 --> 00:06:17,609
你会感觉像在同一页上滚动

127
00:06:17,678 --> 00:06:21,746
所有这些应用程序的UI设计师。另外我想确定一下

128
00:06:21,814 --> 00:06:26,317
这四个按钮获得相同的空间量。好的，

129
00:06:26,386 --> 00:06:29,421
无论我在这里给予的空间得到平等分配和

130
00:06:29,489 --> 00:06:31,322
我在这里用这个分配的东西来做，

131
00:06:31,391 --> 00:06:36,228
我说平等。对齐只是意味着我填充整个

132
00:06:36,296 --> 00:06:38,563
空间，我可以让这些东西被集中或

133
00:06:38,632 --> 00:06:40,431
有点被推到栈顶，但

134
00:06:40,500 --> 00:06:42,801
我要把它填满整个空间。就是这样了。

135
00:06:42,869 --> 00:06:45,503
所以我只是要用这两行做同样的事情。

136
00:06:45,572 --> 00:06:48,373
所以这个下来，嵌入堆栈，

137
00:06:48,441 --> 00:06:52,210
这个组在这里嵌入堆栈。哎呀，

138
00:06:52,279 --> 00:06:56,080
我在那里做了两次。现在我要选择这两个。

139
00:06:56,149 --> 00:07:00,851
使他们平等和标准值间距。所以

140
00:07:00,920 --> 00:07:04,756
现在我有三个水平堆栈。我要堆叠这些

141
00:07:04,824 --> 00:07:06,991
一起，我要选择他们。顺便一提，

142
00:07:07,060 --> 00:07:09,694
拖动选择真的是一个很好的选择方式。

143
00:07:09,763 --> 00:07:12,163
我强烈建议你这样做，而不是试图点击

144
00:07:12,231 --> 00:07:15,433
的东西。因为顺便说一下，让我们试着点击

145
00:07:15,502 --> 00:07:19,370
这里选择这一行。哎呀，我选择了里面的按钮。

146
00:07:19,439 --> 00:07:21,940
我不想要那个，我想整整一排。但

147
00:07:22,008 --> 00:07:25,610
如果我只是拖动，而不是拖动而是经常拖动，

148
00:07:25,679 --> 00:07:30,048
它会选择我用我的拖动拦截的东西。

149
00:07:30,117 --> 00:07:32,650
无论如何，所以我要用拖动来选择所有这三个。

150
00:07:32,719 --> 00:07:35,086
而且我要嵌入堆栈。你把他们放进去

151
00:07:35,155 --> 00:07:37,622
一个垂直堆栈。你注意到这次是垂直的，

152
00:07:37,691 --> 00:07:39,623
因为它注意到这三件事是垂直的。

153
00:07:39,692 --> 00:07:40,925
如果你的东西是随机的，

154
00:07:40,994 --> 00:07:43,461
它会选择一个它认为是最有可能的。

155
00:07:43,530 --> 00:07:44,863
你可以随时去这里改变它

156
00:07:44,931 --> 00:07:47,932
改成另一个。所以我们有垂直的，

157
00:07:48,001 --> 00:07:51,135
我们也想在这里从上到下平等地填充

158
00:07:51,204 --> 00:07:53,271
我们也想要标准间距。所以

159
00:07:53,340 --> 00:07:56,607
这很棒。我们在这个漂亮的网格中获得了按钮。

160
00:07:56,676 --> 00:08:02,046
它们都完美地摆放在这个矩形中。现在，

161
00:08:02,115 --> 00:08:05,483
我们想把这个矩形固定到边上。可以，然后呢

162
00:08:05,552 --> 00:08:08,820
当设备旋转时，或者设备较大时，

163
00:08:08,888 --> 00:08:10,388
就好像它是iPhone 8 Plus，或者

164
00:08:10,457 --> 00:08:12,223
这样的事情，这是更广泛的，所以

165
00:08:12,292 --> 00:08:15,026
它会全部伸展。所以，我们的方式

166
00:08:15,095 --> 00:08:17,529
那首先我要用那些蓝线。

167
00:08:17,598 --> 00:08:21,065
我拿起这个东西。再一次，拿起来，

168
00:08:21,134 --> 00:08:23,601
你想先选择它，然后把它拿起来。

169
00:08:23,669 --> 00:08:26,538
如果你不先选择它并尝试捡起它，哎呀，

170
00:08:26,606 --> 00:08:28,706
你可以尝试从这里拉出其中的一个东西。

171
00:08:28,775 --> 00:08:30,742
好的？所以，小心一点。好吧。

172
00:08:30,810 --> 00:08:32,176
所以，我要用蓝线。我会去的

173
00:08:32,245 --> 00:08:35,013
把这个地方，它有点建议

174
00:08:35,082 --> 00:08:36,147
在左上角。

175
00:08:36,216 --> 00:08:39,484
你看到了吗？这几乎是蓝线，

176
00:08:39,552 --> 00:08:41,953
这将是从边缘的标准间距。

177
00:08:42,022 --> 00:08:43,387
这就是蓝线告诉你的。

178
00:08:43,456 --> 00:08:45,857
这是一个标准的地方，把这个。现在，

179
00:08:45,926 --> 00:08:49,227
我需要把它和我们之间的关系的方式

180
00:08:49,296 --> 00:08:52,764
视图和用户界面像钉他们对方和

181
00:08:52,832 --> 00:08:56,200
东西是与控制拖动。完全相同的方式，我们做了

182
00:08:56,269 --> 00:08:58,202
我们的UI和我们的代码之间的关系，

183
00:08:58,271 --> 00:09:01,239
通过拖动代码，我们在视图之间做同样的事情。

184
00:09:01,308 --> 00:09:04,675
所以，我要控制已经选择的拖动

185
00:09:04,744 --> 00:09:09,047
框在这里顶部。好的，所以我只是拖着走

186
00:09:09,115 --> 00:09:11,750
顶部，当我放开它会说，好吧，

187
00:09:11,818 --> 00:09:14,619
你和这个视图之间有什么关系？

188
00:09:14,687 --> 00:09:17,588
顶端。而且你可以有各种各样的关系，

189
00:09:17,657 --> 00:09:19,090
就像我说的，在三个星期内我们将会有

190
00:09:19,159 --> 00:09:21,159
关于这些关系的整个演讲，但是

191
00:09:21,227 --> 00:09:24,962
在顶部是一个顶部空间到安全区域。

192
00:09:25,031 --> 00:09:28,132
你看到顶层到太空区域？安全区域

193
00:09:28,201 --> 00:09:31,336
在屏幕附近是一个安全的边缘，你可以

194
00:09:31,405 --> 00:09:34,639
安全地绘制而不重叠其他用户界面。

195
00:09:34,707 --> 00:09:37,241
所以，这里把它放在所有的地方

196
00:09:37,310 --> 00:09:40,578
相机和脸部识别的东西都在

197
00:09:40,647 --> 00:09:44,883
这里。所以，这是保持在低于。现在，如果我有

198
00:09:44,951 --> 00:09:47,752
其他用户界面，如标签栏或标题栏或

199
00:09:47,820 --> 00:09:51,455
无论如何，那么安全区将在那里。所以，

200
00:09:51,524 --> 00:09:54,325
我们不会重叠我们的标题和东西。这个真的很酷。

201
00:09:54,394 --> 00:10:00,264
所以，我会把这个顶部空间的小针，所以

202
00:10:00,333 --> 00:10:03,501
我有点连接它，你可以看到这条蓝线出现

203
00:10:03,570 --> 00:10:07,371
就在这儿。好的？这条蓝线在这里，长长的蓝线。

204
00:10:07,440 --> 00:10:11,375
它代表了固定，我甚至可以点击它。好的，

205
00:10:11,444 --> 00:10:14,045
当我点击它时，看，它在顶部是可以检查的

206
00:10:14,113 --> 00:10:17,248
一半在这里。好的？这只是告诉我，不固定

207
00:10:17,317 --> 00:10:20,284
从安全区顶部到堆栈视图的顶部。和

208
00:10:20,353 --> 00:10:23,321
我们离它零点。

209
00:10:23,389 --> 00:10:25,824
我们想要对抗这个安全的边缘。

210
00:10:25,892 --> 00:10:28,058
那是蓝色的虚线让我说的，所以

211
00:10:28,127 --> 00:10:30,661
那就是我要放的地方现在，我们可以做同样的事情

212
00:10:30,730 --> 00:10:34,032
到这边的左边，所以我要控制拖拉。

213
00:10:34,101 --> 00:10:37,001
这次它说，领先的空间安全区。

214
00:10:37,069 --> 00:10:40,872
现在，你为什么认为这是领先而不是左？

215
00:10:40,941 --> 00:10:45,743
任何人都想猜？它说领先，而不是离开，

216
00:10:45,812 --> 00:10:50,081
因为一些语言希伯来语，阿拉伯语，他们去的权利

217
00:10:50,150 --> 00:10:53,117
剩下。信件来自右边，他们流动

218
00:10:53,186 --> 00:10:55,820
向左走。在这些情况下，你想要的非常多

219
00:10:55,889 --> 00:10:58,656
你的整个UI翻转过来。所以，你会想要这些

220
00:10:58,725 --> 00:11:01,259
固定在另一边的按钮，因为文字

221
00:11:01,328 --> 00:11:03,761
按钮会从右边来。好的？

222
00:11:03,830 --> 00:11:05,830
现在，和我们的表情无关，但是

223
00:11:05,898 --> 00:11:08,332
这就是为什么我们做前导和尾随，而不是左和

224
00:11:08,401 --> 00:11:11,435
对。好的？所以，我要点击这个领导空间

225
00:11:11,504 --> 00:11:14,405
保存区域就在这里。连接它，我又得到了一点蓝色

226
00:11:14,474 --> 00:11:17,141
就在这里你看到这个？如果我点击它，

227
00:11:17,210 --> 00:11:19,143
它看起来像一个小眼睛，

228
00:11:19,212 --> 00:11:22,947
它钉住这两个，它被钉住了16点。

229
00:11:23,016 --> 00:11:25,950
你看到16分，显然是蓝色的思路

230
00:11:26,019 --> 00:11:28,986
左边缘，或者你想要的16分的领先优势。

231
00:11:29,055 --> 00:11:31,489
好的，我会接受的。然后，当然，

232
00:11:31,557 --> 00:11:36,026
我可以钉在另一边。按住Ctrl +拖动到这里。

233
00:11:36,095 --> 00:11:39,397
而现在，在这里我没有用蓝线来表示这个边缘。

234
00:11:39,466 --> 00:11:42,634
所以，这里如果我说尾随空间到安全区域。

235
00:11:42,702 --> 00:11:44,635
我有一个眼睛，这个巨大的，好的。

236
00:11:44,704 --> 00:11:46,537
所以，就这样一路走来

237
00:11:46,606 --> 00:11:50,241
我不想要那个，我希望它和其他的一样

238
00:11:50,310 --> 00:11:53,444
方面，16分。所以在我这里的检查员

239
00:11:53,513 --> 00:11:56,681
这个距离这个常数在这里215点。

240
00:11:56,749 --> 00:11:58,882
所以，我会改变这是16，

241
00:11:58,951 --> 00:12:02,219
所以它匹配另一边。哦，看看发生了什么

242
00:12:02,288 --> 00:12:06,223
钉住我的按钮的边缘，他们摊开，同样，

243
00:12:06,292 --> 00:12:09,727
一样的填充，因为我们告诉我们要平等地填充。

244
00:12:09,796 --> 00:12:13,664
好吧，这很酷，现在我们有底了。

245
00:12:13,733 --> 00:12:16,467
所以，底部是有点棘手，因为我们有

246
00:12:16,536 --> 00:12:20,771
在这里翻转。所以，我们希望翻转到底部

247
00:12:20,840 --> 00:12:23,874
我们希望这个东西在翻转之上。所以，

248
00:12:23,943 --> 00:12:26,310
让我们先翻转一下，让我们来看看吧

249
00:12:26,379 --> 00:12:28,947
翻转是在底部，我们会做同样的

250
00:12:29,015 --> 00:12:31,549
事情。所以，我要抓住翻转和使用蓝线，

251
00:12:31,618 --> 00:12:33,517
好吧，把它放在底部的中心。

252
00:12:33,586 --> 00:12:36,520
然后一个控制拖到底部，

253
00:12:36,589 --> 00:12:40,658
并说我希望将底部空间固定在保险箱上

254
00:12:40,726 --> 00:12:44,962
区。所以，这很好。现在，当我这样做的时候，

255
00:12:45,031 --> 00:12:47,632
看，我得到了这个黄色和红色的线条和

256
00:12:47,701 --> 00:12:50,434
我在这里得到警告看到警告这个警告，

257
00:12:50,503 --> 00:12:53,037
这意味着有一个警告，如果有的话可以是红色的

258
00:12:53,106 --> 00:12:56,140
一个错误。如果你点击它会告诉你什么

259
00:12:56,209 --> 00:12:59,210
你的警告是那里的一个快速总结，而且

260
00:12:59,278 --> 00:13:02,179
这里说水平位置是不明确的

261
00:13:02,248 --> 00:13:06,183
你的翻转计数标签。其实这是暧昧的。

262
00:13:06,252 --> 00:13:08,052
我从来没有把它水平放在哪里，

263
00:13:08,121 --> 00:13:09,587
我把它固定在底部，但是

264
00:13:09,656 --> 00:13:11,322
我没有说这是在中间，还是离开，或者

265
00:13:11,390 --> 00:13:14,625
现在我用蓝线拖着它，但是

266
00:13:14,694 --> 00:13:18,362
从蓝线开始，它不会钉在那里。所以

267
00:13:18,431 --> 00:13:19,897
真正我想要翻转的是，

268
00:13:19,966 --> 00:13:22,599
我希望它在中心。好吧，我想要它在

269
00:13:22,668 --> 00:13:24,134
中央。只是为了让你看到一些不同的东西。

270
00:13:24,203 --> 00:13:27,738
为了做到这一点，我再次控制+拖动右转

271
00:13:27,807 --> 00:13:30,808
在这里，我想成为中心的东西，

272
00:13:30,876 --> 00:13:33,144
这是这里的背景。所以，

273
00:13:33,212 --> 00:13:35,112
我只是要控制+拖动到背景。和

274
00:13:35,181 --> 00:13:39,750
另一种选择是在安全区域水平居中。

275
00:13:39,819 --> 00:13:44,621
所以，我会这样做的。现在，它把它放在中间。

276
00:13:44,690 --> 00:13:47,758
这里还是黄色的。那么，这个黄色说什么？

277
00:13:47,827 --> 00:13:50,727
它表示翻转计数标签的框架将会不同

278
00:13:50,796 --> 00:13:55,332
在运行时。那是因为我没有限制尺寸

279
00:13:55,401 --> 00:13:58,168
这个翻转计数标签。我已经让它成为任何大小。

280
00:13:58,237 --> 00:13:59,536
而且由于它可以是任何大小，

281
00:13:59,605 --> 00:14:02,206
它会想成为它的自然大小，

282
00:14:02,274 --> 00:14:03,841
无论大小合适

283
00:14:03,910 --> 00:14:07,211
现在，我可以在这个按钮右下方修正这个警告

284
00:14:07,280 --> 00:14:09,813
这里。这是你所有的限制。

285
00:14:09,882 --> 00:14:12,984
所有这些固定的东西都被称为约束

286
00:14:13,052 --> 00:14:15,686
我们将这些视图限制在某个地方，

287
00:14:15,755 --> 00:14:18,522
我们可以，嗯，其实我们并没有解决它，

288
00:14:18,591 --> 00:14:20,458
但是我们要解决这个问题

289
00:14:20,526 --> 00:14:23,627
所以，请记住，我们在这里的文件大纲

290
00:14:23,696 --> 00:14:26,464
这个小东西，我们隐藏。如果你取消隐藏和

291
00:14:26,533 --> 00:14:29,500
在右上角看，如果有这些小的

292
00:14:29,569 --> 00:14:32,436
警告你有这个小按钮，如果你点击它，

293
00:14:32,505 --> 00:14:34,338
它会告诉你所有的问题。所以，

294
00:14:34,407 --> 00:14:39,310
这一个是错位的视图，因为这个翻盖太大了。对于

295
00:14:39,379 --> 00:14:41,345
它应该是什么。所以，再次，如果你点击这一点

296
00:14:41,414 --> 00:14:44,715
三角，它会提供，嘿，你想解决这个问题？和

297
00:14:44,784 --> 00:14:47,051
你可以通过更新我们想要的帧来修复它，

298
00:14:47,120 --> 00:14:49,653
因为我们不在乎这是什么框架，矩形

299
00:14:49,722 --> 00:14:51,389
包围它。只要它可以是任何东西

300
00:14:51,457 --> 00:14:54,058
固定在底部和中心。我们可以

301
00:14:54,126 --> 00:14:56,160
做其他事情，我们会谈几个星期。

302
00:14:56,229 --> 00:14:58,129
所以，我只是要更新框架驱动器在这里修复

303
00:14:58,198 --> 00:15:01,032
missplacement。看下移动的翻转，

304
00:15:01,100 --> 00:15:04,168
它使周围的框架勉强包含它。

305
00:15:04,237 --> 00:15:07,171
好吧，现在他们围绕那个翻转零是这样的

306
00:15:07,240 --> 00:15:10,407
自然大小。如果我运行这个，做一百次翻转，那么

307
00:15:10,476 --> 00:15:12,810
它必须更大，自然会变得更大。

308
00:15:12,879 --> 00:15:15,079
因为它的大小不受限制。

309
00:15:15,147 --> 00:15:17,482
它不固定任何东西，只是它的位置。所以，

310
00:15:17,550 --> 00:15:20,818
它的大小将会变得很大或者很小

311
00:15:20,887 --> 00:15:23,521
它的东西。而现在，我们看到我们没有自动布局问题。

312
00:15:23,590 --> 00:15:27,591
我们在这里没有任何警告，一切都很好。最后一件事我们

313
00:15:27,660 --> 00:15:30,661
需要做的就是翻转顶部的关系，

314
00:15:30,730 --> 00:15:34,632
和这个的底部。现在，我可以把这个东西拿起来

315
00:15:34,701 --> 00:15:38,336
这里和控制之间的拖动和翻转，对吧？

316
00:15:38,405 --> 00:15:40,837
这是一个好主意。我们可以，例如，

317
00:15:40,906 --> 00:15:43,875
限制两者之间的垂直间距，所以我会

318
00:15:43,943 --> 00:15:48,679
单击“垂直间距”即可。这是一个巨大的酒吧。

319
00:15:48,748 --> 00:15:52,917
我可以去这里，把它从454改为0

320
00:15:52,985 --> 00:15:55,986
使用这里的所有空间。但是那看起来不太好。

321
00:15:56,055 --> 00:15:58,722
我真的不喜欢这样的高瘦按钮。

322
00:15:58,791 --> 00:16:01,492
所以我会在这里留下这个限制。但是我

323
00:16:01,561 --> 00:16:04,962
要从平等的地方改变它，它必须是平等的，

324
00:16:05,031 --> 00:16:08,899
到翻转为0。我也许不想要0，我想要

325
00:16:08,968 --> 00:16:11,936
一个标准值在这里，所以我要改变为标准值

326
00:16:12,004 --> 00:16:14,605
差异，好吧，这个，这个，这个距离。

327
00:16:14,674 --> 00:16:17,007
我不是平等的，我希望它大于或大于

328
00:16:17,076 --> 00:16:19,677
等于。所以我只是想确定这些事情

329
00:16:19,746 --> 00:16:23,113
顶部总是在翻转之上，大于或等于。

330
00:16:23,182 --> 00:16:25,716
但是它并不一定要这样。所以

331
00:16:25,785 --> 00:16:28,318
你不必总是有这些限制是平等的。

332
00:16:28,387 --> 00:16:31,388
他们可以大于或等于，小于或

333
00:16:31,457 --> 00:16:35,526
同等的相对限制。你看到这一切？

334
00:16:35,594 --> 00:16:37,795
现在，我们可以运行应用程序，这应该都工作。

335
00:16:37,864 --> 00:16:40,097
一切都是相互制约的。

336
00:16:40,165 --> 00:16:43,834
我们实际上可以在界面上看看它

337
00:16:43,903 --> 00:16:46,470
建设者。对，记住这个按钮在这里显示

338
00:16:46,538 --> 00:16:49,373
我们所有这些电话？我们可以说，好的，这是什么东西

339
00:16:49,442 --> 00:16:52,810
会看起来像一个iPhone 8？这里是iPhone 8，

340
00:16:52,879 --> 00:16:55,346
我们点击它，有时候这样做，

341
00:16:55,415 --> 00:16:58,015
你可以放大或缩小来重画。

342
00:16:58,084 --> 00:17:00,284
所以这就是iPhone 8上的样子。

343
00:17:00,353 --> 00:17:03,988
我们可以看看，回到iPhone X，但旋转它。

344
00:17:04,056 --> 00:17:06,557
所以这就是在iPhone X上旋转的样子，

345
00:17:06,626 --> 00:17:08,960
那看起来会好看的所以

346
00:17:09,028 --> 00:17:11,963
我们可以预览一下发生了什么

347
00:17:12,031 --> 00:17:13,997
这里在界面生成器，但是没有替代品

348
00:17:14,066 --> 00:17:16,667
运行它。所以让我们在我们的模拟器上运行它

349
00:17:16,736 --> 00:17:19,537
看看它是否看起来像我们所期望的。

350
00:17:21,040 --> 00:17:23,340
就在这里，应用程序似乎在工作。哦，

351
00:17:23,409 --> 00:17:27,678
让我们再次让我们的背景变黑。所以回到这里，

352
00:17:27,746 --> 00:17:32,183
背景黑色，保持我们的万圣节主题完好无损。

353
00:17:35,488 --> 00:17:38,655
现在在这里，没关系，所以这件事情还在继续

354
00:17:38,724 --> 00:17:41,458
匹配的东西等，但现在当我们旋转，

355
00:17:41,527 --> 00:17:45,496
记得命令+箭头，看，它重新奠定了整个用户界面

356
00:17:45,565 --> 00:17:48,766
以适应空间。它正在这样做，它正在中继

357
00:17:48,835 --> 00:17:50,868
出于这些限制，我们把它。

358
00:17:50,936 --> 00:17:53,337
我们把这个优势限制在这里，

359
00:17:53,405 --> 00:17:55,573
我们把这个优势限制在这里。

360
00:17:55,641 --> 00:17:57,541
我们限制了这个距离

361
00:17:57,610 --> 00:17:59,610
大于或等于标准距离。

362
00:17:59,679 --> 00:18:02,980
我们把这个底部限制在下面

363
00:18:03,049 --> 00:18:05,783
这里。我们限制了这个位置

364
00:18:05,852 --> 00:18:08,319
中心。我们把这些约束放在这里，等等

365
00:18:08,388 --> 00:18:12,756
当我们翻转这个东西的时候，它是和那些人一起生活的

366
00:18:12,825 --> 00:18:18,095
限制。得到它了？就像我说的，这只是一个传情

367
00:18:18,163 --> 00:18:21,031
这个约束的东西。这是一个非常强大的系统

368
00:18:21,100 --> 00:18:23,768
做这些约束，我们会谈论这一切，

369
00:18:23,837 --> 00:18:27,738
就像我说的，大约三个星期。好的，

370
00:18:27,806 --> 00:18:30,441
回到幻灯片。好，那么

371
00:18:30,510 --> 00:18:32,876
这是你对第一周的简要回顾，好吧，

372
00:18:32,945 --> 00:18:35,846
超速审查。当然你知道target action，

373
00:18:35,914 --> 00:18:38,015
outlet collections。

374
00:18:38,083 --> 00:18:40,651
卡片按钮，您的翻盖计数标签。触摸卡，

375
00:18:40,720 --> 00:18:43,454
你知道的。你了解了所有的方法和

376
00:18:43,523 --> 00:18:46,056
属性，所有这些东西的语法是什么。

377
00:18:46,125 --> 00:18:49,794
像倒计数和吨方法所有的属性

378
00:18:49,862 --> 00:18:53,397
集中在卡和视图控制器中。你学到了

379
00:18:53,466 --> 00:18:56,367
关于倒计数改变时的属性观察权，

380
00:18:56,435 --> 00:18:58,902
我们有那个会导致用户界面改变为

381
00:18:58,971 --> 00:19:01,138
好。你显然知道了数组，

382
00:19:01,207 --> 00:19:04,041
如何把数组放在数组中，如何声明一个数组。

383
00:19:04,110 --> 00:19:06,477
你会学到很多模型视图控制器。

384
00:19:06,545 --> 00:19:09,646
我们去了，使浓度游戏有

385
00:19:09,715 --> 00:19:12,816
像卡上的浓度模型。

386
00:19:12,885 --> 00:19:15,986
您了解了值类型与参考类型，对吗？

387
00:19:16,055 --> 00:19:18,655
卡，这是一个结构，被复制的值类型

388
00:19:18,724 --> 00:19:21,525
当你把它扔掉。所以当我们把它们放在数组中

389
00:19:21,594 --> 00:19:23,961
在那里，我们把它复制两次。

390
00:19:24,029 --> 00:19:25,729
他们每次把它放在那里都会复制它，

391
00:19:25,798 --> 00:19:28,265
记得吗？你了解了初始化器，

392
00:19:28,334 --> 00:19:31,001
我们有两个初始化器

393
00:19:31,069 --> 00:19:32,469
为了集中，他们各自做了不同的事情得到

394
00:19:32,470 --> 00:19:33,870
卡和

395
00:19:33,940 --> 00:19:36,741
他们自己是初始化者。我们没有初始化

396
00:19:36,809 --> 00:19:40,278
我们的UI视图控制器，我们可能永远不会。

397
00:19:40,346 --> 00:19:44,548
UI视图控制器初始化很麻烦。好的，

398
00:19:44,617 --> 00:19:47,585
所以我们尽量不要用init来实现我们的视图

399
00:19:47,653 --> 00:19:50,154
控制器。我在你的作业中解释说

400
00:19:50,223 --> 00:19:53,557
今天出去，你可以阅读。你学到了

401
00:19:53,625 --> 00:19:56,327
关于静态方法，如获取唯一标识符，静态

402
00:19:56,395 --> 00:19:58,829
像我们已经创建的标识符工厂

403
00:19:58,898 --> 00:20:01,698
那里。你学习了像游戏这样的懒惰属性

404
00:20:01,767 --> 00:20:05,736
依赖于另一个属性，所以它不能初始化。

405
00:20:05,804 --> 00:20:07,838
我们只是懒惰，所以它不会

406
00:20:07,907 --> 00:20:09,606
初始化，直到有人要求，

407
00:20:09,675 --> 00:20:12,776
这当然是事后全部初始化的。

408
00:20:12,845 --> 00:20:15,946
你了解了循环，只有在Swift中

409
00:20:16,015 --> 00:20:19,183
通过迭代所谓的序列来工作。

410
00:20:19,252 --> 00:20:21,852
我们知道可数范围是一个序列，对吗？

411
00:20:21,921 --> 00:20:24,421
0 ... <比任何一个可数范围，

412
00:20:24,490 --> 00:20:26,923
这是一个序列。而阵列也是一个序列，

413
00:20:26,992 --> 00:20:28,893
字符串是一个字符序列。

414
00:20:28,961 --> 00:20:31,862
很多东西都是序列，你可以在它们之上。

415
00:20:31,931 --> 00:20:34,464
我们要谈谈成为一个序列意味着什么

416
00:20:34,533 --> 00:20:37,734
稍后，可能在星期三。你了解了

417
00:20:37,803 --> 00:20:40,637
字典。当然，我们的表情符号在字典里。

418
00:20:40,706 --> 00:20:41,839
我们了解了类型转换。

419
00:20:41,908 --> 00:20:45,342
我们通过创建一个新的东西来转换类型。并使用初始化

420
00:20:45,411 --> 00:20:49,480
与像uint 32这样的老东西相提并论，

421
00:20:49,548 --> 00:20:53,016
转换成一个uint 32.当然，你学到了很多东西

422
00:20:53,085 --> 00:20:55,852
关于我敢肯定的选择权对你们来说还是新的

423
00:20:55,921 --> 00:20:58,522
今天我会谈论很多关于可选项和他们如何

424
00:20:58,591 --> 00:21:01,058
真的有用。什么是可选的，好吗？

425
00:21:01,126 --> 00:21:02,759
所以这是您对第一周的回顾。

426
00:21:02,828 --> 00:21:04,995
如果对于其中一些，如果你不觉得你理解

427
00:21:05,063 --> 00:21:08,799
这些，可能还没有做你的功课，那么你

428
00:21:08,868 --> 00:21:11,402
不会明白这一点，非常重要。好的，前两个

429
00:21:11,470 --> 00:21:13,804
我要在这里谈论的事情只是一点点

430
00:21:13,873 --> 00:21:17,741
小事情，旁白。我提到了做一个

431
00:21:17,810 --> 00:21:22,279
循环浮游物。所以这个对于我= 0.5，我<15.25什么的，

432
00:21:22,348 --> 00:21:26,083
这是你可能在C中看到的东西。你不能这样做

433
00:21:26,151 --> 00:21:28,919
在斯威夫特，好吗？Swift没有，只有在，

434
00:21:28,988 --> 00:21:32,589
就是这样。但是，我们如何创建一个可数范围或

435
00:21:32,658 --> 00:21:36,026
这些花车的某种顺序是因为0.5 ... 15.25，

436
00:21:36,094 --> 00:21:40,163
这实际上是合法的说，但是

437
00:21:40,232 --> 00:21:44,134
这只是Swift中的一个范围，不是一个可数范围。和

438
00:21:44,203 --> 00:21:47,071
那是因为我们不知道要在那里算什么，

439
00:21:47,140 --> 00:21:49,739
所以它不能创造一个可数范围。所以

440
00:21:49,808 --> 00:21:52,977
我们这样做的方式是使用一个叫做stride的全局函数。

441
00:21:54,547 --> 00:21:58,114
步伐有形式，通过或从和

442
00:21:58,183 --> 00:22:00,784
取决于你是否会包括最后一个

443
00:22:00,852 --> 00:22:04,588
事情，一个通过告诉你它的进展。步伐是

444
00:22:04,656 --> 00:22:08,492
函数创建一个可数范围。可数

445
00:22:08,561 --> 00:22:11,461
范围是泛型类型，比如数组是泛型类型。

446
00:22:11,530 --> 00:22:13,296
它不仅可以统计整数，

447
00:22:13,365 --> 00:22:15,932
它可以计算浮动，它甚至可以计算在指标

448
00:22:16,001 --> 00:22:18,535
成一串，各种各样的东西都可以数过去。

449
00:22:18,604 --> 00:22:22,172
而这一步知道如何创建一个可数范围，

450
00:22:22,241 --> 00:22:25,476
在这种情况下，因为我做了一个封闭的可数范围

451
00:22:25,545 --> 00:22:28,345
通过15.25，而不是15.25。

452
00:22:28,414 --> 00:22:31,581
它创造了一个超越花车，知道一步一步

453
00:22:31,650 --> 00:22:34,951
0.3，那里。所以这就是你如何做浮点。

454
00:22:35,020 --> 00:22:37,020
而你不必为你的家庭作业或任何事情做到这一点，

455
00:22:37,089 --> 00:22:38,555
但我只想完成我们的工作

456
00:22:38,624 --> 00:22:41,892
一个可数范围的花车。好，元组。

457
00:22:41,961 --> 00:22:45,262
我尝试着把所有的东西都融入到我可以的浓度中，

458
00:22:45,331 --> 00:22:48,332
一切的例子。但我无法弄清楚

459
00:22:48,400 --> 00:22:51,101
即使元组如何适应元组是一个非常简单的

460
00:22:51,170 --> 00:22:55,572
小数据结构。而所有的元组本质上是，

461
00:22:55,641 --> 00:22:59,943
像一个没有方法或变量或任何东西的小型结构。

462
00:23:00,012 --> 00:23:04,114
只是有它的价值。所以它有点像其他结构

463
00:23:04,183 --> 00:23:06,784
语言，如C结构。他们没有方法或

464
00:23:06,852 --> 00:23:08,719
变种或任何东西，或者他们有变数，

465
00:23:08,788 --> 00:23:10,554
他们有数据存储，就是这样。

466
00:23:10,623 --> 00:23:12,956
所以，但是元组是超级轻量级​​的

467
00:23:13,025 --> 00:23:15,392
你有点定义一切。

468
00:23:15,461 --> 00:23:19,296
所以这里是一个元组的样子。这是一个元组x。 X，

469
00:23:19,365 --> 00:23:23,734
在这里，是类型元组。而这个元组有三个

470
00:23:23,802 --> 00:23:26,437
事情在里面。一个字符串，一个int和一个double。和

471
00:23:26,505 --> 00:23:29,839
我只是说等于括号，

472
00:23:29,908 --> 00:23:33,544
三件事，好吧，三件事。现在，是什么

473
00:23:33,612 --> 00:23:37,214
有点酷了一个元组，作为一个轻量级的struct有点

474
00:23:37,283 --> 00:23:41,451
事情是，元素的名字是非常灵活的。

475
00:23:41,520 --> 00:23:44,855
您可以在获取值时定义名称，如下所示，

476
00:23:44,924 --> 00:23:49,092
让括号中的数字值等于x。和

477
00:23:49,161 --> 00:23:52,062
实际上将x的每个值分配给三个值

478
00:23:52,131 --> 00:23:55,833
变量词，数字和价值。好的？所以我是一种

479
00:23:55,901 --> 00:23:59,603
给我这些结构元素的名字，我拿出来，或

480
00:23:59,672 --> 00:24:02,506
我们可以做相反的事情。当我定义x时，

481
00:24:02,574 --> 00:24:05,042
我可以说x是一个具有字符串的元组

482
00:24:05,110 --> 00:24:09,045
互联网双叫winv。然后，

483
00:24:09,114 --> 00:24:13,484
当我手中有x时，我可以得到w，

484
00:24:13,552 --> 00:24:16,186
我和v使用，使用这个点符号，

485
00:24:16,255 --> 00:24:20,057
有点像它几乎是一个结构体，xw，xi，xv

486
00:24:20,125 --> 00:24:23,026
看，所以现在我声明的名字，当我声明

487
00:24:23,095 --> 00:24:27,131
事情。但是，即使你这样做，你仍然可以

488
00:24:27,199 --> 00:24:29,766
让我们重新声明这个名字是别的

489
00:24:29,835 --> 00:24:33,904
word num val = x，那么它会创建这三个局部变量

490
00:24:33,972 --> 00:24:37,273
在这三件事的命名上超级灵活。

491
00:24:37,342 --> 00:24:39,943
通常当我们创建一个元组时，我们想要使用第二种方法

492
00:24:40,012 --> 00:24:43,146
x：i：v的方式，尽管我们可能不会使用x，

493
00:24:43,215 --> 00:24:45,615
我和V这些都是可怕的名字，只是我的

494
00:24:45,684 --> 00:24:47,350
幻灯片只有这么多的空间。

495
00:24:47,419 --> 00:24:49,386
水平，可能是单词，数字或

496
00:24:49,455 --> 00:24:51,789
价值会是更好的名字。通常我们这样做，而且

497
00:24:51,858 --> 00:24:53,457
这主要是因为文档，

498
00:24:53,526 --> 00:24:56,226
我们希望人们知道这三件事情是什么。要是我们

499
00:24:56,295 --> 00:24:59,163
只是声明它像在最上面的x，string，int，

500
00:24:59,231 --> 00:25:01,865
人们都喜欢，呃，这三件事情是什么？

501
00:25:01,933 --> 00:25:03,266
那么，什么是元组好？好，

502
00:25:03,335 --> 00:25:06,336
任何时候你想组合一些东西都很好

503
00:25:06,404 --> 00:25:08,205
这真的很轻，它没有任何方法或

504
00:25:08,274 --> 00:25:10,974
任何与之相关的东西。这也是非常好的

505
00:25:11,042 --> 00:25:14,945
从一个函数返回多个值。一个函数

506
00:25:15,014 --> 00:25:17,781
Swift只能返回一个单一的东西，但是

507
00:25:17,850 --> 00:25:21,251
那东西可能是一个元组，现在你可以返回许多

508
00:25:21,319 --> 00:25:24,821
你想要的东西，好吗？所以如果我有一个函数getSize，

509
00:25:24,890 --> 00:25:28,158
得到一个人的体型，身高和体重。

510
00:25:28,227 --> 00:25:32,229
比方说，我可以返回一个重量和身高的元组，并且

511
00:25:32,298 --> 00:25:34,898
所以当我回来时，我只是x.weight或

512
00:25:34,966 --> 00:25:38,902
即使只是getSize.weight或getSize.height，访问

513
00:25:38,970 --> 00:25:42,773
它直接。所以这就是元组，我不是让你做的

514
00:25:42,841 --> 00:25:45,109
在你的第一次阅读任务中阅读它的元组，但是

515
00:25:45,177 --> 00:25:46,376
你会在下一个阅读。

516
00:25:46,445 --> 00:25:48,178
这很简单，看起来就是这样，

517
00:25:48,247 --> 00:25:50,981
那里没有什么神奇的东西，没有隐藏的东西，这是

518
00:25:51,049 --> 00:25:56,120
只是一个简单的小结构，是吗？抱歉？他们支持吗？

519
00:25:57,523 --> 00:25:59,589
索引？做元组支持索引，你的意思是，

520
00:25:59,658 --> 00:26:04,194
得到事物编号1，或得到事物编号2？不是真的，

521
00:26:04,262 --> 00:26:06,730
我们并不想这样做。如果我们真的

522
00:26:06,798 --> 00:26:09,299
有我们要索引的东西，我们想在那里使用一个数组，

523
00:26:09,368 --> 00:26:12,369
因为，你知道我在说什么吗？它会混淆

524
00:26:12,438 --> 00:26:14,204
这是怎么回事。关于元组的全部伟大的事情，

525
00:26:14,273 --> 00:26:16,740
你可以命名每一个，让人们知道他们是什么，所以。

526
00:26:18,477 --> 00:26:21,111
好的，现在好吧，那就是了

527
00:26:21,180 --> 00:26:23,813
小事情，现在我们回到了非常重要的事情。

528
00:26:23,882 --> 00:26:27,651
这是一件大事。这是计算的属性。

529
00:26:27,720 --> 00:26:30,888
所以你在浓度中看到的所有属性，

530
00:26:30,956 --> 00:26:34,057
被存储的属性。他们只是正常的变数

531
00:26:34,126 --> 00:26:36,126
像你习惯于在另一种语言，对不对？

532
00:26:36,195 --> 00:26:39,429
像这样var foo：Double，这是一个双精度

533
00:26:39,498 --> 00:26:42,332
浮点数，它只是存储在内存中。

534
00:26:42,400 --> 00:26:45,536
它与任何结构或类的一部分存储。

535
00:26:45,604 --> 00:26:48,405
但是可以像这样声明foo，

536
00:26:48,474 --> 00:26:53,410
foo双开大括号，拿大括号，设置，

537
00:26:53,478 --> 00:26:55,445
与一些花括号。

538
00:26:55,514 --> 00:26:59,316
在这种情况下，foo永远不会存储在任何地方，相反，

539
00:26:59,385 --> 00:27:00,751
每次有人要求

540
00:27:00,820 --> 00:27:05,255
美孚，它得到计算与代码里面得到。和

541
00:27:05,324 --> 00:27:07,624
每次有人设定foo的值，

542
00:27:07,692 --> 00:27:13,196
这里面的这个代码被执行。

543
00:27:13,265 --> 00:27:14,531
好的，所以我在这里得到了一个小指针。所以

544
00:27:14,600 --> 00:27:17,801
这个代码在你设置的时候被执行，这个代码在这里

545
00:27:17,870 --> 00:27:21,070
当你得到执行。而不是被存储

546
00:27:21,139 --> 00:27:25,942
某处。现在，顺便说一下，set（newValue）部分，

547
00:27:26,011 --> 00:27:28,478
这是可选的。所以你可以有计算属性

548
00:27:28,547 --> 00:27:32,215
只能得到，调用那些只读的计算属性。

549
00:27:32,284 --> 00:27:34,618
你不能只有一套，

550
00:27:34,687 --> 00:27:36,920
你只能得到但不能设置。

551
00:27:36,988 --> 00:27:40,523
如果你只设置了一个函数设置。

552
00:27:40,592 --> 00:27:44,894
你不会使用这样的变种。好吧，那么为什么计算

553
00:27:44,963 --> 00:27:49,065
属性重要？你用什么来做？

554
00:27:49,134 --> 00:27:51,835
好吧，很多时候你有一些被认为是的东西

555
00:27:51,904 --> 00:27:56,940
您的结构或类的实际派生的属性

556
00:27:57,008 --> 00:28:00,510
从你的结构中的其他状态。当你有

557
00:28:00,578 --> 00:28:03,313
那种情况，你不想拥有一个存储的属性

558
00:28:03,382 --> 00:28:04,881
因为你不想拥有相同的东西

559
00:28:04,950 --> 00:28:09,886
信息在两个不同的变量。因为他们可以得到

560
00:28:09,955 --> 00:28:11,755
不同步，各种各样的问题发生，所以

561
00:28:11,824 --> 00:28:14,257
你以某种方式想要得到自己

562
00:28:14,326 --> 00:28:17,761
从另一个。这是一个非常好的例子

563
00:28:17,829 --> 00:28:21,765
indexOfOneAndOnlyFaceUpCard集中。

564
00:28:21,833 --> 00:28:26,736
这很容易通过查看卡片派生出来。所以

565
00:28:26,805 --> 00:28:30,373
你真的，我们真的很糟糕的做到这一点

566
00:28:30,442 --> 00:28:33,143
一个存储的属性，因为我们必须保持这个事情

567
00:28:33,211 --> 00:28:37,146
与所有卡的正面状态完全同步。

568
00:28:37,215 --> 00:28:41,184
这真是容易出错的设计方式。所以，我们可以

569
00:28:41,253 --> 00:28:44,654
想象一下，实现indexOfOneAndOnlyFaceUpCard为

570
00:28:44,723 --> 00:28:45,822
计算属性

571
00:28:45,891 --> 00:28:48,591
得到只是看所有的卡。如果你愿意

572
00:28:48,660 --> 00:28:51,862
只有找到一个FaceUpCard才会返回该索引，否则

573
00:28:51,930 --> 00:28:56,332
它返回零。而该集只是看着那个指数，

574
00:28:56,401 --> 00:28:59,035
确保卡面朝上，其余的将面临

575
00:28:59,104 --> 00:29:03,940
下来，你看？所以，我们只是使用这个计算的属性

576
00:29:04,009 --> 00:29:07,678
基本上提供这个概念性的属性，

577
00:29:07,747 --> 00:29:09,546
这是indexOfOneAndOnlyFaceUpCard，

578
00:29:09,615 --> 00:29:11,982
那是我们游戏的属性，但是

579
00:29:12,050 --> 00:29:14,885
它是从另一个计算的。每个人都得到什么

580
00:29:14,953 --> 00:29:18,354
我在那里说？好吧，让我们去浓度和

581
00:29:18,423 --> 00:29:20,290
做出这个改变，看看这会是什么样子

582
00:29:20,358 --> 00:29:22,426
如果你像我们一样使用计算属性

583
00:29:22,495 --> 00:29:25,228
应该放在第一位，好吗？

584
00:29:25,297 --> 00:29:30,700
所以我们回到这里来看看X代码

585
00:29:30,769 --> 00:29:33,971
在这里，我们去弹出我们的代码备份，摆脱这一点。

586
00:29:34,039 --> 00:29:38,208
走吧，哎呀，让我们去集中，这是在哪里

587
00:29:38,277 --> 00:29:41,811
这样好吗？所以大家都认识这个代码吧？

588
00:29:41,880 --> 00:29:43,680
这是我们的全部注意力，

589
00:29:43,748 --> 00:29:45,882
相当有效的代码，但它实际上会看起来

590
00:29:45,951 --> 00:29:49,586
一旦我们这样做了，就像你会看到的一样。所以我们在这里，

591
00:29:49,655 --> 00:29:51,354
我们有索引和一个唯一的FaceUpCard。所以

592
00:29:51,423 --> 00:29:54,557
我要把这些花括号放进去计算，

593
00:29:54,626 --> 00:29:57,827
只要我这样做，现在它是一个计算属性。其实，

594
00:29:57,896 --> 00:30:00,330
在我们这样做之前，让我告诉你更简单的情况

595
00:30:00,399 --> 00:30:04,401
只是为了让你热身计算的属性。

596
00:30:04,469 --> 00:30:07,804
有时候，你只是这样简单的计算。

597
00:30:07,873 --> 00:30:11,040
从中计算的卡片对的数量

598
00:30:11,109 --> 00:30:14,444
卡片按钮，好吗？可能还有其他时间

599
00:30:14,513 --> 00:30:17,013
在我们的视图控制器里面，我们想知道这个数字，

600
00:30:17,082 --> 00:30:19,949
我们有多少张卡。所以

601
00:30:20,018 --> 00:30:23,787
这是一种属性，是从这个数据派生。所以

602
00:30:23,856 --> 00:30:25,789
我要把这个从这里拿出来

603
00:30:25,857 --> 00:30:30,127
有多少副牌是属性。

604
00:30:30,195 --> 00:30:35,766
这将是一个新的var numberOfPairsOfCards，和

605
00:30:35,834 --> 00:30:39,870
它会是Int类型的，所以会被计算出来

606
00:30:39,938 --> 00:30:43,339
我会得到一个。这将是只读，所以

607
00:30:43,408 --> 00:30:45,976
我会回来这个。这不会有一套，

608
00:30:46,044 --> 00:30:49,112
没有，这里不会有任何一套。和

609
00:30:49,181 --> 00:30:52,950
瞧，我已经创建了一个简单的计算属性读取

610
00:30:53,018 --> 00:30:56,119
只要。顺便说一下，如果你有一个只读属性，

611
00:30:56,187 --> 00:31:00,456
你实际上并不需要有这个词。所以

612
00:31:00,525 --> 00:31:01,190
一个只读属性

613
00:31:01,259 --> 00:31:04,094
可以看起来像那样只有你只有一个得到，

614
00:31:04,162 --> 00:31:07,663
如果你有一套不能做到这一点。所以这是一个超级

615
00:31:07,732 --> 00:31:10,567
简单的小一个。所以，现在我们回到这里

616
00:31:10,635 --> 00:31:12,436
在这里做更复杂的一点。

617
00:31:12,504 --> 00:31:16,840
这个有一个get，它也有一个集合。和

618
00:31:16,909 --> 00:31:20,577
在这里设置，我把放在有新值的幻灯片。

619
00:31:20,646 --> 00:31:23,146
这只是这里面的局部变量

620
00:31:23,215 --> 00:31:25,482
包含某人设定的新值，

621
00:31:25,551 --> 00:31:29,018
indexOfTheOneAndOnlyFaceUpCard两项。很多时候我们没有

622
00:31:29,087 --> 00:31:31,421
把任何东西放在那里，如果你这样做，

623
00:31:31,490 --> 00:31:34,858
它默认为newValue。这是当地人的名字，

624
00:31:34,926 --> 00:31:36,960
这里有一个特殊的变量叫newValue。

625
00:31:37,028 --> 00:31:39,562
但是如果你想把它叫做索引，

626
00:31:39,631 --> 00:31:42,632
你可以做到这一点，完全取决于你，

627
00:31:42,701 --> 00:31:46,936
很多时候我们只是说使用newValue。好的，

628
00:31:47,005 --> 00:31:50,173
所以得到索引我们必须做什么

629
00:31:50,241 --> 00:31:53,110
来计算代码的索引。所以我只是会去

630
00:31:53,178 --> 00:31:56,346
写小代码，并有一点变量，

631
00:31:56,415 --> 00:32:00,417
说foundIndex这将是一个可选的Int。所以

632
00:32:00,485 --> 00:32:03,453
我要翻看所有的面牌和

633
00:32:03,522 --> 00:32:05,622
看看我能找到一个我会找到的人。

634
00:32:05,691 --> 00:32:07,490
所以我要在这里使用for循环

635
00:32:07,559 --> 00:32:10,227
通过所有的卡片，指示，好吗？

636
00:32:10,295 --> 00:32:15,398
我要看看每张牌，如果这张牌是FaceUp。

637
00:32:15,467 --> 00:32:17,667
所以我找到了FaceUp卡，whoo-hoo。

638
00:32:17,735 --> 00:32:20,870
我会说，如果找到一个零，换句话说，

639
00:32:20,939 --> 00:32:24,041
我还没有找到该卡，这是我的第一个。

640
00:32:24,109 --> 00:32:28,211
然后我会找不到一个，它叫什么，

641
00:32:28,280 --> 00:32:32,849
foundIndex = index，好吗？所以在这里我只是说如果我

642
00:32:32,918 --> 00:32:35,985
刚刚找到我的第一个让我们记住它。

643
00:32:36,054 --> 00:32:39,522
否则，如果foundIndex不是零，这意味着这是

644
00:32:39,591 --> 00:32:41,958
我找到的第二张FaceUpCard。

645
00:32:42,027 --> 00:32:44,494
因为我已经找到了一个，我发现了另一个，所以

646
00:32:44,563 --> 00:32:47,431
这里我只是要返回零。因为如果有两个

647
00:32:47,499 --> 00:32:49,900
FaceUpCards显然是那个的索引和

648
00:32:49,968 --> 00:32:53,270
只有FaceUpCard是零，没有这样的事情。和

649
00:32:53,339 --> 00:32:55,371
如果我通过这一切的方式

650
00:32:55,440 --> 00:32:58,708
循环我只是要返回foundIndex，这也是

651
00:32:58,776 --> 00:33:01,211
将被设置为我找到的一张卡或

652
00:33:01,280 --> 00:33:03,680
这个声明仍然是零。

653
00:33:03,748 --> 00:33:05,682
请记住，可选项总是得到

654
00:33:05,750 --> 00:33:09,051
这个免费等于零时，他们宣布，对不对？所以

655
00:33:09,120 --> 00:33:12,222
开始零，如果我从来没有找到一个，它仍然是零，

656
00:33:12,291 --> 00:33:15,692
这是正确的，这意味着将没有FaceUpCards。

657
00:33:15,761 --> 00:33:18,395
我们会在这里理解这个简单的代码，

658
00:33:18,464 --> 00:33:20,730
那套案子呢？在案件上，

659
00:33:20,799 --> 00:33:22,198
我只是要循环所有的卡片和

660
00:33:22,267 --> 00:33:26,236
除了这个他们刚才设置的那个之外，把所有的面都翻下来

661
00:33:26,304 --> 00:33:29,338
到，这将是新的价值，好吗？所以我只是

662
00:33:29,407 --> 00:33:33,243
将card.indices通过我的卡片索引。

663
00:33:33,312 --> 00:33:36,412
伟大的方式去遍历这个可数

664
00:33:36,481 --> 00:33:39,348
我阵列中所有索引的范围。我会说，

665
00:33:39,417 --> 00:33:45,756
cards.index.isFaceUp = false，

666
00:33:45,824 --> 00:33:50,327
对于大多数卡片。但是在这里索引的情况下，

667
00:33:50,395 --> 00:33:54,264
这个指数等于这个新的价值，那么我会

668
00:33:54,332 --> 00:33:59,369
将其设置为true。好的，这是一个表达

669
00:33:59,438 --> 00:34:03,874
如果有人说indexOfTheOneAndOnlyFaceUpCard，这是真的

670
00:34:03,942 --> 00:34:07,210
等于什么。如果这是他们所说的话，

671
00:34:07,279 --> 00:34:10,547
那么如果牌面朝上，我们会有这个真实的，

672
00:34:10,615 --> 00:34:13,549
否则这将永远是错误的。每个人都有这个

673
00:34:13,618 --> 00:34:17,553
那里有小代码？通过这个？好吧，

674
00:34:17,622 --> 00:34:21,391
而已。好吧，现在是指数的上一个和下一个上档卡

675
00:34:21,459 --> 00:34:22,859
是这样计算的，

676
00:34:22,927 --> 00:34:26,329
从卡上，我们不需要承担责任

677
00:34:26,398 --> 00:34:30,233
做这样的事情，在这里设置为零。情况就是如此

678
00:34:30,302 --> 00:34:33,136
在那里我们找到了两张牌，我们有两张牌

679
00:34:33,204 --> 00:34:36,273
试图匹配，很明显，有两张牌。

680
00:34:36,341 --> 00:34:38,474
所以我们不得不设置indexOfTheOneAndOnlyFaceUpCard

681
00:34:38,543 --> 00:34:40,744
无零，有两个。但我们不必这样做

682
00:34:40,812 --> 00:34:42,912
因为它总是计算，

683
00:34:42,981 --> 00:34:45,749
每次我们问，它都会看着卡片。和

684
00:34:45,817 --> 00:34:49,418
甚至比这里的情况更好。好的，

685
00:34:49,487 --> 00:34:51,520
这种情况下来，我们正在设置

686
00:34:51,589 --> 00:34:53,523
indexOfTheOneAndOnlyFaceupCard来

687
00:34:53,592 --> 00:34:56,259
成为指标。那是因为在那里

688
00:34:56,328 --> 00:34:57,894
已经是两个还是没有，

689
00:34:57,963 --> 00:35:01,364
现在我们把这些faceDown，并做这个新的。

690
00:35:01,433 --> 00:35:04,734
所以我们已经设置了这一切，它完成了这一切。

691
00:35:04,802 --> 00:35:07,470
设置这个东西已经变成了一切

692
00:35:07,539 --> 00:35:11,641
其他卡faceDown。而且已经把那张卡面朝上，

693
00:35:11,709 --> 00:35:16,178
所以我们不需要任何代码。所以你看看如何制作

694
00:35:16,247 --> 00:35:20,083
计算的属性使这个代码更加简单

695
00:35:20,152 --> 00:35:23,819
直截了当。因为它真的得到了什么的核心

696
00:35:23,888 --> 00:35:26,656
继续。我只是设置indexOfTheOneAndOnlyFaceUpCard

697
00:35:26,725 --> 00:35:27,223
到这个指标

698
00:35:27,292 --> 00:35:28,191
我只是点击或

699
00:35:28,260 --> 00:35:30,727
我只是把这张卡faceUp。而下一次

700
00:35:30,795 --> 00:35:34,063
有人要求索引的是OneOn和OnlyFaceUpCard

701
00:35:34,132 --> 00:35:36,466
它会做正确的事情，对不对？

702
00:35:36,535 --> 00:35:39,302
所以让我们去跑步，确保我们没有中断

703
00:35:39,371 --> 00:35:43,306
任何使这成为一个计算的属性。开始了，

704
00:35:43,374 --> 00:35:46,009
希望我们仍然可以匹配，匹配，

705
00:35:46,077 --> 00:35:48,645
匹配正在工作，而且不匹配也是

706
00:35:48,714 --> 00:35:52,982
加工。真的很酷的计算属性，

707
00:35:53,050 --> 00:35:55,718
你会看到iOS中的计算属性，

708
00:35:55,787 --> 00:36:01,223
他们很常见，是的。 >> [不可思议]

709
00:36:01,292 --> 00:36:02,258
>>好的很好的问题，所以

710
00:36:02,326 --> 00:36:04,995
我什么时候可以重用这个var和

711
00:36:05,063 --> 00:36:07,664
有两个方法，一个是索引和

712
00:36:07,732 --> 00:36:09,833
一个真的[不可思议]和一个设置它。

713
00:36:09,901 --> 00:36:14,003
好吧，这是否被视为属性。

714
00:36:14,072 --> 00:36:17,807
这个指数实际上被我们认为是程序员

715
00:36:17,875 --> 00:36:20,710
这是一个属性对吗？这是游戏的一个属性

716
00:36:20,779 --> 00:36:22,379
是卡面上的索引，所以

717
00:36:22,447 --> 00:36:27,049
这就是你会在这里做的。如果是另一种方式

718
00:36:27,118 --> 00:36:32,021
决定是否设置或得到真正做了很多工作。

719
00:36:32,090 --> 00:36:35,158
就像它真的在捣鼓什么东西

720
00:36:35,227 --> 00:36:36,826
你可能想做一个功能。

721
00:36:36,895 --> 00:36:38,628
只是这样的人不认为，哦，这是一个轻量级的

722
00:36:38,696 --> 00:36:41,731
我可以得到的小财产。现在，这可能看起来像

723
00:36:41,800 --> 00:36:43,966
很多工作，但其实很简单。

724
00:36:44,035 --> 00:36:46,703
然后在讲座的后面，大概在星期三，

725
00:36:46,771 --> 00:36:50,073
我会告诉你一个更简单的版本。

726
00:36:50,141 --> 00:36:51,775
当我们更多地了解Swift时。

727
00:36:51,843 --> 00:36:53,676
但是，它只是看着没有那么多的工作

728
00:36:53,745 --> 00:36:56,412
另一个数据结构。但如果你做了很多工作

729
00:36:56,481 --> 00:36:58,114
那么你可能想要做设置和

730
00:36:58,182 --> 00:37:01,651
得到清楚。但如果是的话

731
00:37:01,720 --> 00:37:06,322
一个变种，如果它看起来像一个变种使其变种。好问题。

732
00:37:06,391 --> 00:37:09,892
好的，我的，这里是主题演讲，

733
00:37:09,961 --> 00:37:13,897
让我们回到这里，回到我们的幻灯片。好吧，

734
00:37:13,965 --> 00:37:17,199
所以接下来我们要谈的是这里，

735
00:37:17,268 --> 00:37:20,303
是我们知道的另一个话题，访问控制。可以，然后呢

736
00:37:20,372 --> 00:37:23,372
什么是访问控制？所以呢有多少人在做

737
00:37:23,441 --> 00:37:27,243
一个项目，一个面向对象的程序项目

738
00:37:27,312 --> 00:37:31,147
十几班？好，就像两个或者

739
00:37:31,216 --> 00:37:35,284
你们三个，也许四个，所以，不是很多你们。好的，

740
00:37:35,353 --> 00:37:37,853
当你在做这样一个非常小的项目时，

741
00:37:37,922 --> 00:37:40,056
你可以在任何类中调用任何方法，

742
00:37:40,124 --> 00:37:42,224
你可能是唯一编程的程序员。

743
00:37:42,293 --> 00:37:44,627
或者，也许你正在和一个哥们一起工作，等等

744
00:37:44,695 --> 00:37:47,229
你可以互相交谈。好吧，但现在想象一下

745
00:37:47,298 --> 00:37:50,967
你在Google工作或Facebook，或苹果，

746
00:37:51,035 --> 00:37:54,471
或类似的东西，这是有点荒谬的。

747
00:37:54,539 --> 00:37:57,273
但是让我们假设你正在专注于那里。和

748
00:37:57,342 --> 00:37:59,942
另外一栋建筑里还有另外一个小组

749
00:38:00,011 --> 00:38:03,546
游戏设计和他们写的模型。和

750
00:38:03,615 --> 00:38:05,848
你只是IOS的UI团队，

751
00:38:05,917 --> 00:38:08,050
直到你只写视图控制器。

752
00:38:08,119 --> 00:38:11,054
好吧，现在，你不想互相调用

753
00:38:11,122 --> 00:38:13,656
代码只是无所谓。调用任何旧的方法

754
00:38:13,724 --> 00:38:16,225
你不希望你的视图控制器像某人一样

755
00:38:16,294 --> 00:38:17,761
indexOfOneAndOnlyFaceUpCard。

756
00:38:17,829 --> 00:38:20,363
如果这些人就像他们摆脱了这种方法

757
00:38:20,431 --> 00:38:23,566
进入下个月，现在你的代码破了。现在，

758
00:38:23,634 --> 00:38:26,236
有一些方法，你必须能够调用

759
00:38:26,304 --> 00:38:29,172
在那边和他们的代码，我们要说清楚

760
00:38:29,241 --> 00:38:31,541
哪些正在使用访问控制。

761
00:38:31,610 --> 00:38:35,244
所以关于有关键字的存取控制，关于那个放

762
00:38:35,313 --> 00:38:37,981
进入我们的API，把它放在方法和酒吧上，

763
00:38:38,049 --> 00:38:41,684
它对其他组织说，我们正在编程，是的，

764
00:38:41,753 --> 00:38:45,088
你可以打电话给我，我保证不打破这个

765
00:38:45,156 --> 00:38:48,892
在你身上。它也告诉他们如何使用你的东西，因为

766
00:38:48,960 --> 00:38:51,794
那些他们被允许调用或他们应该的

767
00:38:51,863 --> 00:38:54,997
被用来使用你的集中游戏或

768
00:38:55,066 --> 00:38:57,300
随你。那么这些关键字是什么？

769
00:38:57,368 --> 00:39:01,237
那么第一个被称为内部。这些是关键字

770
00:39:01,306 --> 00:39:04,541
你把前面的vars和funcs。甚至是类和

771
00:39:04,609 --> 00:39:07,176
结构，你可以做出整个类和结构，

772
00:39:07,245 --> 00:39:10,813
有他们的访问控制。所以默认的内部，

773
00:39:10,881 --> 00:39:12,682
这一个我们从来没有实际输入

774
00:39:12,751 --> 00:39:15,485
因为这是默认的所以所有的方法和

775
00:39:15,554 --> 00:39:17,653
我们到目前为止在集中所做的变数都是

776
00:39:17,722 --> 00:39:20,656
内部。现在内部访问控制是什么意思？

777
00:39:20,725 --> 00:39:26,061
它意味着你的应用程序中的任何人，任何对象，任何地方的任

778
00:39:26,130 --> 00:39:29,665
可以调用该方法或访问该栏。所以这是非常多的

779
00:39:29,734 --> 00:39:33,335
无限的控制在你的应用程序现在我们开始说话了

780
00:39:33,404 --> 00:39:35,772
关于访问控制，我们必须意识到总是有两个

781
00:39:35,841 --> 00:39:39,442
各种编程，有一个应用程序，

782
00:39:39,510 --> 00:39:42,445
然后写一个框架。像苹果一样，

783
00:39:42,514 --> 00:39:46,582
UI工具包，好吗？这是框架。更多的访问

784
00:39:46,651 --> 00:39:49,285
控制问题，如果你正在编写一个框架。所以

785
00:39:49,354 --> 00:39:51,120
我会告诉你事情是什么

786
00:39:51,188 --> 00:39:53,789
写一个框架，但是，我们不会真的付出太多

787
00:39:53,858 --> 00:39:55,625
关注他们，因为我们只是要学习

788
00:39:55,694 --> 00:39:59,228
在本课程中编写应用程序。所以内在意味着一切

789
00:39:59,296 --> 00:40:02,699
您的应用程序或您的框架中，可以访问此代码。

790
00:40:02,767 --> 00:40:05,000
所以它几乎是无限的内部

791
00:40:05,069 --> 00:40:08,671
你的苹果框架。然后是三个私有点。

792
00:40:08,740 --> 00:40:10,473
这些是非常重要的，这些是你的

793
00:40:10,542 --> 00:40:14,143
会一直使用一个是私有的，

794
00:40:14,212 --> 00:40:17,313
这意味着它的内部实现这个对象，

795
00:40:17,381 --> 00:40:22,384
没有其他对象可以调用它。这是一个很好的设置，

796
00:40:22,453 --> 00:40:25,722
它使Google和其他组织中的某个人保持联系

797
00:40:25,790 --> 00:40:28,858
通过访问该代码构建。因为你

798
00:40:28,927 --> 00:40:31,527
保持私有，这是你的私有的实现。

799
00:40:31,596 --> 00:40:35,164
Private set几乎是一模一样的，它只适用于变种，

800
00:40:35,232 --> 00:40:39,201
这意味着设置这个变种是私有的，但得到它

801
00:40:39,270 --> 00:40:43,639
不是私有的。所以你让人们得到var，访问

802
00:40:43,708 --> 00:40:46,676
它，但他们不能设置它。那是你的视图，

803
00:40:46,744 --> 00:40:48,611
这是你的内部实现设置它。

804
00:40:48,679 --> 00:40:51,514
我们将在集中中看到一个很好的例子。

805
00:40:51,583 --> 00:40:54,850
然后是fileprivate。 Fileprivate在Swift文件中，

806
00:40:54,919 --> 00:40:56,852
你可以在那里有多个类和结构，

807
00:40:56,921 --> 00:40:58,955
你不必只是我们所做的一个类

808
00:40:59,024 --> 00:41:02,158
到目前为止，fileprivate意味着什么

809
00:41:02,227 --> 00:41:06,162
文件可以互相访问，对。所以类，

810
00:41:06,230 --> 00:41:09,665
在那里四个类，可以互相对方，没关系，

811
00:41:09,734 --> 00:41:12,501
这是file private的意思。好的，其他的

812
00:41:12,570 --> 00:41:15,204
是公开和开放的，这些是框架作家。

813
00:41:15,273 --> 00:41:18,007
公共意味着框架之外的人

814
00:41:18,076 --> 00:41:21,444
可以调用它。在你的应用程序之外没有任何意义，

815
00:41:21,512 --> 00:41:23,746
那永远不会发生，所以在你的框架之外。

816
00:41:23,815 --> 00:41:26,416
而开放不仅意味着你的框架之外的人

817
00:41:26,484 --> 00:41:29,585
称它，但他们可以分类，

818
00:41:29,654 --> 00:41:31,320
重写你的方法所有的东西，

819
00:41:31,388 --> 00:41:35,124
所以开放就像是开放的，好吧。我们不关心这个

820
00:41:35,193 --> 00:41:38,361
因为我们只是，我们没有做框架，对。所以

821
00:41:38,430 --> 00:41:41,030
我们会专注于各种私有的。

822
00:41:41,099 --> 00:41:43,999
一个很好的策略是使用这些非常private的

823
00:41:44,068 --> 00:41:46,969
任何东西，直到你确定，是的，我想要别人

824
00:41:47,038 --> 00:41:48,904
能够在某处调用此方法。

825
00:41:48,973 --> 00:41:53,509
对，这是默认情况下，你应该把事情私有化。所以

826
00:41:53,578 --> 00:41:56,312
让我们看看一个浓度，看起来是什么样子

827
00:41:56,381 --> 00:41:58,114
把访问控制和集中

828
00:41:58,182 --> 00:42:00,883
在这里注意，因为我会要求你所有的

829
00:42:00,952 --> 00:42:04,153
家庭作业前进，你正确地标记的东西。

830
00:42:04,222 --> 00:42:05,922
如果他们应该的话，我希望你把事情标记下来

831
00:42:05,990 --> 00:42:08,224
私人的。好的，因为我想要确保你

832
00:42:08,292 --> 00:42:11,895
明白这是什么。所以我们回到这里

833
00:42:13,565 --> 00:42:16,665
到Xcode。让我们从我们的ViewController开始。

834
00:42:16,734 --> 00:42:19,134
好的，我们有三个类，或三个数据结构，

835
00:42:19,203 --> 00:42:21,304
我们的ViewController，卡和浓度。那么我们开始吧

836
00:42:21,372 --> 00:42:27,210
与ViewController。所以这就是我们的模型。所以

837
00:42:27,278 --> 00:42:31,514
我们希望我们的模型是公开的，而不是私人的？

838
00:42:31,583 --> 00:42:33,582
那实际上取决于。

839
00:42:33,651 --> 00:42:36,319
这取决于你的模型是什么，它是如何工作的。经常，

840
00:42:36,387 --> 00:42:40,256
ViewControllers模型是公开的公开我的意思

841
00:42:40,325 --> 00:42:43,492
非私有的。我们在一个应用程序，所以忘了公共和

842
00:42:43,561 --> 00:42:47,096
打开关键字。我的意思是，当我说公众时，我的意思是非私有的。

843
00:42:47,165 --> 00:42:49,932
所以你做了很多次，因为你给了一个模型

844
00:42:50,001 --> 00:42:51,433
一个视图控制器，它显示它，

845
00:42:51,502 --> 00:42:54,870
这就是它所做的。但是这不是这种情况。这个

846
00:42:54,939 --> 00:42:58,240
想成为private。而它想成为private的原因

847
00:42:58,309 --> 00:43:01,477
是因为游戏中双卡的数量是

848
00:43:01,545 --> 00:43:04,480
与UI紧密联系，好的多少

849
00:43:04,549 --> 00:43:07,083
我们已经在用户界面的卡。所以，如果我们想要做

850
00:43:07,151 --> 00:43:09,585
这个公开的，我们也必须公开一些东西

851
00:43:09,653 --> 00:43:13,356
指定我们允许的卡片按钮的数量

852
00:43:13,425 --> 00:43:15,391
我们目前不这样做，

853
00:43:15,460 --> 00:43:18,127
这是在我们的小场景和

854
00:43:18,195 --> 00:43:21,430
界面生成器，所以我们不这样做。所以我们保留这个，我们

855
00:43:21,499 --> 00:43:25,067
保持这个私密性。如何对卡数量？

856
00:43:25,136 --> 00:43:28,271
那么，如果有人问，我不介意

857
00:43:28,340 --> 00:43:30,706
双卡的数量是多少

858
00:43:30,775 --> 00:43:36,612
设置卡对的数量会很糟糕。但

859
00:43:36,680 --> 00:43:40,816
关于这一点的事情是它已经是一个只能得到的属性。

860
00:43:40,885 --> 00:43:43,419
你无法设置它，它从其他数据派生。

861
00:43:43,488 --> 00:43:47,022
所以我们只是把这个private，抱歉的，而不是private的。

862
00:43:47,091 --> 00:43:49,358
我们会让人们称呼这个，

863
00:43:49,427 --> 00:43:51,493
那些使用我的ViewController的人，他们可以说，

864
00:43:51,562 --> 00:43:53,496
那里有几张卡？但他们无法设定，

865
00:43:53,565 --> 00:43:55,998
因为这是不可设置的。可以，然后呢

866
00:43:56,067 --> 00:43:57,366
没关系公开发表。

867
00:43:57,435 --> 00:43:59,902
同样的事情flipCount，我认为flipCount，

868
00:43:59,970 --> 00:44:03,272
人们可以得到它，但肯定，我们没有

869
00:44:03,341 --> 00:44:06,508
希望人们设置flipCount。这是我们做的事情

870
00:44:06,577 --> 00:44:08,978
内部卡片翻转时，我们执行flipCount。

871
00:44:09,046 --> 00:44:12,148
这对于二传手来说是私密的，但是可以让人们接受

872
00:44:12,216 --> 00:44:14,684
得到正在使用我们的东西的flipCount。

873
00:44:14,752 --> 00:44:19,021
我们的outlet，几乎总是有private outlet。

874
00:44:19,090 --> 00:44:19,989
Cuz我们的private outlets，

875
00:44:20,057 --> 00:44:23,159
这些东西，甚至我们的行为都是这样的

876
00:44:23,227 --> 00:44:26,295
内部实现我们如何实现我们的用户界面。

877
00:44:26,364 --> 00:44:29,365
这是一个ViewController它控制我们的用户界面。

878
00:44:29,433 --> 00:44:32,702
绝对是像UI更新模型的东西

879
00:44:32,771 --> 00:44:35,271
私人的，这是内部实施。

880
00:44:35,339 --> 00:44:38,808
所有这些都是私人的表情符号业务。虽然你

881
00:44:38,876 --> 00:44:42,845
可以设想最终公开一些公共API

882
00:44:42,914 --> 00:44:45,848
在这个ViewController中，让我们使用的人

883
00:44:45,917 --> 00:44:49,051
我们的ViewController指定他们想要的表情符号。

884
00:44:49,120 --> 00:44:53,756
就像，你知道，这个主题需要你有的任务，

885
00:44:53,824 --> 00:44:57,460
你可以想象有一种方法来指定我想要的

886
00:44:57,528 --> 00:44:59,995
你先生视图控制器来玩这个游戏，

887
00:45:00,064 --> 00:45:02,998
但是我希望你使用这个表情符号作为你的主题。

888
00:45:03,067 --> 00:45:05,534
看，所以你可以想象一些事情是公开的。

889
00:45:05,603 --> 00:45:08,471
我不认为这完全是这个API，

890
00:45:08,539 --> 00:45:10,439
这将是一些其他类型的API，

891
00:45:10,508 --> 00:45:13,942
我不确定他们会让你设置表情符号

892
00:45:14,011 --> 00:45:16,946
使用。我们真的不能真正使这个公共cuz我们实际上消耗

893
00:45:17,014 --> 00:45:20,883
这个。这是一个变种，我们消耗它。我们显然

894
00:45:20,952 --> 00:45:23,119
我必须在你的家庭作业中处理这件事。和

895
00:45:23,187 --> 00:45:24,954
你知道，我们正在建立这个字典，

896
00:45:25,022 --> 00:45:26,755
我们不希望任何人搞乱它，所以

897
00:45:26,824 --> 00:45:27,857
我会保留所有这些private的。

898
00:45:27,925 --> 00:45:30,259
这是一个private的第一个例子

899
00:45:30,328 --> 00:45:33,296
那么我会想想我想要公开的。

900
00:45:33,364 --> 00:45:34,997
你看，那里的设计方法？

901
00:45:35,066 --> 00:45:39,802
好，我们去看看卡片吧

902
00:45:39,871 --> 00:45:42,304
这是卡。卡肯定，这必须是公开的。

903
00:45:42,373 --> 00:45:43,839
我们需要知道卡片是否面朝上，

904
00:45:43,908 --> 00:45:45,908
我们必须公开不幸，

905
00:45:45,977 --> 00:45:48,110
这必须是公开的。否则，

906
00:45:48,179 --> 00:45:50,846
我们不能分辨两张牌是否相同，

907
00:45:50,915 --> 00:45:54,516
但是这两个人绝对不需要公开。

908
00:45:54,585 --> 00:45:58,620
我的整个想法，使纯粹的identierFactory

909
00:45:58,689 --> 00:46:02,458
内部实施，好吧，没有理由这样做

910
00:46:04,295 --> 00:46:06,995
上市。而这真的，我想这是private的

911
00:46:07,064 --> 00:46:09,965
好吧，因为一张卡片要么正面朝上，要么匹配

912
00:46:10,034 --> 00:46:12,134
不管是另一张牌，

913
00:46:12,203 --> 00:46:14,971
我不应该看一个标识符来找到。

914
00:46:15,039 --> 00:46:18,007
我应该可以说这张卡==另一张卡，

915
00:46:18,076 --> 00:46:20,308
这不是很酷吗？是的，这是很酷的

916
00:46:20,377 --> 00:46:23,646
我们将在本次讲座中或稍后的讲座中这样做

917
00:46:23,714 --> 00:46:26,582
演讲。呃，这真的很糟糕，但现在我们

918
00:46:26,650 --> 00:46:28,350
不得不离开公众，否则我们会这样做，

919
00:46:28,419 --> 00:46:31,687
我们不能分辨两张牌是一样的。好的，

920
00:46:31,756 --> 00:46:35,090
这里是浓度游戏，这是一个非常有趣的

921
00:46:35,159 --> 00:46:38,660
私人和公众的情况下，因为，这里是一个对象，

922
00:46:38,729 --> 00:46:41,697
一个模型，打算在某个用户界面的某个地方使用，

923
00:46:41,765 --> 00:46:44,500
好的。这是非常有意使用的东西，而且

924
00:46:44,569 --> 00:46:46,535
有些事情我们知道是private的，

925
00:46:46,604 --> 00:46:49,271
像这家伙肯定，indexOfTheOneAndOnlyFaceUpC-

926
00:46:49,340 --> 00:46:51,640
我们不需要有人用我们来知道，

927
00:46:51,709 --> 00:46:53,142
他们不需要知道这一点。

928
00:46:53,211 --> 00:46:55,944
而事实上，如果我们离开公众，有人使用我们会

929
00:46:56,013 --> 00:46:58,613
就像我应该设置的那样，我想知道？

930
00:46:58,682 --> 00:47:01,483
好的，但是它与它无关，这是我们的内在

931
00:47:01,552 --> 00:47:06,488
实现。卡必须公开

932
00:47:06,557 --> 00:47:09,625
因为否则UI不能显示卡片。

933
00:47:09,694 --> 00:47:12,961
然而，卡被翻转或上下

934
00:47:13,030 --> 00:47:18,200
匹配这是我的工作。所以我会把这个私人的

935
00:47:18,269 --> 00:47:22,405
设置，好吧，所以这将是耶，你可以看看我的卡片

936
00:47:22,473 --> 00:47:25,608
如果你想使用计数游戏，但我负责

937
00:47:25,676 --> 00:47:29,077
设置正面和相匹配。所以

938
00:47:29,146 --> 00:47:32,114
你可以看到这个明显的私人设置，

939
00:47:32,183 --> 00:47:35,784
大家看到了吗？是啊。 >>因此，您可以访问

940
00:47:35,853 --> 00:47:38,487
卡，但你不能访问的方法或

941
00:47:38,556 --> 00:47:40,956
与之相关的属性？ >>是的，所以

942
00:47:41,025 --> 00:47:43,759
问题是什么时候这就是我的意思

943
00:47:43,827 --> 00:47:46,962
可以访问卡，但我不能访问的方法

944
00:47:47,031 --> 00:47:50,366
在你的意思？没有卡上的方法，

945
00:47:50,435 --> 00:47:53,436
结束了，这里是公开的，好吧，

946
00:47:53,504 --> 00:47:56,905
那些不是内部的，所以我可以访问这些。从这里，

947
00:47:56,974 --> 00:48:00,542
好的？但是你记得这是一个值类型，所以

948
00:48:00,611 --> 00:48:03,745
我不能设置是空间和东西，我只能设置

949
00:48:03,814 --> 00:48:07,950
直接在数组中。就像我在这里做的一样。你看，

950
00:48:08,018 --> 00:48:10,252
这里我正在修改阵列中的东西。

951
00:48:10,321 --> 00:48:13,121
这是做到这一点的唯一方法。那么，如果这个我不能这样做

952
00:48:13,190 --> 00:48:17,559
是private set。好的？因为这是一个价值类型。

953
00:48:17,628 --> 00:48:20,796
所以这就是这样，这就像是一个让。

954
00:48:20,865 --> 00:48:22,731
这几乎使它像一个让步

955
00:48:22,800 --> 00:48:25,101
其他人，我以外的人。然后，等等

956
00:48:25,169 --> 00:48:28,571
当它是一个let时，你不能触摸数组中的任何东西。所以

957
00:48:28,639 --> 00:48:31,573
这是价值类型的一个非常酷的功能。

958
00:48:31,642 --> 00:48:33,875
记住这个数组是一个值类型和

959
00:48:33,944 --> 00:48:37,646
卡是一种值类型。所以整个事情都被冻结了

960
00:48:37,715 --> 00:48:41,616
谁的人，你不能为外面的人修改

961
00:48:41,685 --> 00:48:44,152
但是对我们来说，这是private set

962
00:48:44,221 --> 00:48:46,789
我们可以在那里做我们想做的任何事情

963
00:48:46,857 --> 00:48:50,259
这样做。好吧。然后，当然，选择卡。

964
00:48:50,328 --> 00:48:53,929
这是我们的基本公共API。所以我们离开了

965
00:48:53,998 --> 00:48:56,298
不是私人的，好吧。人们就是这么做的。和

966
00:48:56,367 --> 00:48:59,869
初始化，初始化也可以是私有的。但

967
00:48:59,937 --> 00:49:02,971
这个显然不能是私有的，否则没有

968
00:49:03,040 --> 00:49:06,976
可以创造一个游戏，好吧。就是这样了。我真的

969
00:49:07,044 --> 00:49:10,045
了解。现在，当我在这里的时候，我会告诉你另一个

970
00:49:10,114 --> 00:49:12,982
API保护与访问控制不同。

971
00:49:13,050 --> 00:49:16,618
这仍然是好的，这是使用断言，好吧。

972
00:49:16,687 --> 00:49:18,654
有谁知道别人的断言是什么？

973
00:49:18,722 --> 00:49:21,957
语言？一个断言只是你调用的一个函数

974
00:49:22,026 --> 00:49:25,027
你断言某事是真实的。如果不是，

975
00:49:25,095 --> 00:49:28,063
你的程序崩溃并打印出一个错误。

976
00:49:28,131 --> 00:49:31,533
而你把它放在你的代码中，assert在被忽略的时候

977
00:49:31,602 --> 00:49:33,936
你发货到App Store。但是当你在开发时，

978
00:49:34,005 --> 00:49:35,504
它会崩溃你的程序，这是好的，

979
00:49:35,572 --> 00:49:38,807
因为它需要调试器正确的断言失败。

980
00:49:38,876 --> 00:49:42,477
断言是保护你的API的好方法。例如

981
00:49:42,546 --> 00:49:43,979
看看这个API，选择卡。

982
00:49:44,047 --> 00:49:46,448
如果有人在索引-1处说什么呢？

983
00:49:46,517 --> 00:49:51,620
或者索引100，他们只有12张牌。

984
00:49:51,689 --> 00:49:54,657
好的，这里会发生一些事情，

985
00:49:54,726 --> 00:49:56,425
可能就像也许在这里或

986
00:49:56,494 --> 00:49:59,694
类似的东西。如果我又是Google的家伙，而且

987
00:49:59,763 --> 00:50:01,363
这些家伙在另一栋建筑里

988
00:50:01,431 --> 00:50:05,900
我不小心在这里传球-1，我不知道是什么。和

989
00:50:05,969 --> 00:50:09,438
崩溃发生在这里，我需要有这个代码，

990
00:50:09,507 --> 00:50:11,807
看看那里，我正在调试它。

991
00:50:11,876 --> 00:50:13,842
该代码属于另一个建筑物中的某个人，

992
00:50:13,910 --> 00:50:16,712
为什么我会想在这里调试呢？代替，

993
00:50:16,780 --> 00:50:20,382
另一栋建筑的人应该在这里提出一个主张。

994
00:50:20,450 --> 00:50:28,290
这表明卡指数包含该指数。

995
00:50:28,359 --> 00:50:31,360
好的，如果卡片的索引不包含这个索引，

996
00:50:31,429 --> 00:50:34,563
那么我们会崩溃，如果我们正在开发，所以，

997
00:50:34,632 --> 00:50:37,266
那么我们希望在这里提供某种类型的崩溃消息。

998
00:50:37,334 --> 00:50:40,736
我喜欢把结构或类的名称和

999
00:50:40,805 --> 00:50:44,739
选择卡的功能。我甚至想包括

1000
00:50:44,808 --> 00:50:47,876
你通过的实际论点，你可以看到你

1001
00:50:47,944 --> 00:50:51,914
通过那里，然后，我给消息。在这种情况下，

1002
00:50:51,983 --> 00:50:57,186
像选择的索引不在卡片里。

1003
00:50:59,523 --> 00:51:02,091
所以，现在如果有人调用来选择

1004
00:51:02,159 --> 00:51:04,860
卡在减号，它会立即崩溃

1005
00:51:04,928 --> 00:51:06,695
把它放在控制台上。他们会像，

1006
00:51:06,763 --> 00:51:08,564
哦，显示在卡上的索引，哦，和

1007
00:51:08,632 --> 00:51:11,667
我通过了减号。你看，他们会一站式的。

1008
00:51:11,735 --> 00:51:14,803
知道他们做了什么。和类似的事情下来

1009
00:51:14,872 --> 00:51:18,239
这里的对卡数是因为它是非法的

1010
00:51:18,308 --> 00:51:22,678
有0对或更少的卡。你必须至少有一个

1011
00:51:22,747 --> 00:51:25,514
对卡。所以在这里我只是要断言

1012
00:51:25,583 --> 00:51:29,184
对卡的数量大于0。

1013
00:51:29,253 --> 00:51:30,986
如果有一个错误，那么我会说是的，

1014
00:51:31,054 --> 00:51:34,890
我在浓度初始和

1015
00:51:34,959 --> 00:51:40,629
你在这里通过了我这对数卡

1016
00:51:40,698 --> 00:51:45,100
这里的问题是你必须至少有

1017
00:51:45,169 --> 00:51:49,604
一双牌。好的？所以，你看我怎么样，我正在使用

1018
00:51:49,673 --> 00:51:53,476
搜索这里有点保护我的API不正当使用。

1019
00:51:53,544 --> 00:52:00,282
问题回到那里？是吗？ >>对不起，

1020
00:52:00,351 --> 00:52:01,616
对不起，当你 -  >>什么时候你会设置初始化

1021
00:52:01,685 --> 00:52:02,250
作为private？ >>哦，那么

1022
00:52:02,319 --> 00:52:07,122
问题是什么时候我会把我的init设置为private，好吧。

1023
00:52:07,191 --> 00:52:10,826
那么，你可能有一个复杂的对象

1024
00:52:10,895 --> 00:52:14,062
只创建自己的实例。例如，

1025
00:52:14,131 --> 00:52:16,030
用静态方法或类似的东西。

1026
00:52:16,099 --> 00:52:18,600
或者你可能有多个。其中一些你会允许的

1027
00:52:18,669 --> 00:52:21,537
其他人调用。但其中一些你在内部调用

1028
00:52:21,605 --> 00:52:24,906
创造，好吧。你甚至可能有公开的

1029
00:52:24,975 --> 00:52:27,409
部分实施称为private。好的，

1030
00:52:27,477 --> 00:52:30,312
因为他们可以互相调用，我们会讲到在

1031
00:52:30,381 --> 00:52:34,149
星期三。所以这就是为什么你可能有一些私人的。好的，

1032
00:52:34,218 --> 00:52:36,451
每个人都冷静与访问控制和

1033
00:52:36,520 --> 00:52:40,922
断言？好吧，回到幻灯片。

1034
00:52:40,991 --> 00:52:45,127
我们在哪？好的酷一个，所有正确的扩展。所以

1035
00:52:45,195 --> 00:52:49,732
扩展是超强大的。他们有点像

1036
00:52:49,800 --> 00:52:52,367
你挥舞的时候要小心的武器，

1037
00:52:52,436 --> 00:52:56,004
因为你可以跟他们发疯。和什么扩展

1038
00:52:56,073 --> 00:53:01,176
允许你做的是添加变数和功能到其他类

1039
00:53:01,245 --> 00:53:03,378
即使你没有这些类的代码。

1040
00:53:03,447 --> 00:53:06,681
即使在另一个框架工作像UI套件什么的

1041
00:53:06,750 --> 00:53:10,753
像那样。所以你可以添加条和方法。你可以加

1042
00:53:10,821 --> 00:53:14,389
它到UI按钮。你可以添加UI视图控制器。

1043
00:53:14,458 --> 00:53:17,459
任何你想要的。好的？所以这是非常非常非常的

1044
00:53:17,528 --> 00:53:21,296
强大的功能。我真的很确定游泳的是什么

1045
00:53:21,364 --> 00:53:23,865
上限，可能性与实际情况相比毫无意义

1046
00:53:23,934 --> 00:53:26,702
因为还有其他的数据结构

1047
00:53:26,770 --> 00:53:30,105
我们甚至没有谈到增加扩展

1048
00:53:30,173 --> 00:53:33,141
真的很强大，我们会在最后得到

1049
00:53:33,210 --> 00:53:38,213
星期三也是。它的基本路线是非常简单的。

1050
00:53:38,281 --> 00:53:40,949
您只需使用关键字扩展名和

1051
00:53:41,018 --> 00:53:44,319
你想添加一个var属性的结构类

1052
00:53:44,388 --> 00:53:46,554
然后把你想要的东西放在那里。

1053
00:53:46,623 --> 00:53:51,560
现在有一个非常严重的限制

1054
00:53:51,629 --> 00:53:56,331
它可以没有存储。这个扩展，这个代码

1055
00:53:56,400 --> 00:53:59,300
你扩大了这个其他的东西，它可以没有变数

1056
00:53:59,369 --> 00:54:01,270
那是存储。它可能有计算的变量。

1057
00:54:01,338 --> 00:54:04,373
但它不能有存储的任何变数。所以

1058
00:54:04,441 --> 00:54:07,676
这确实限制了你可以做的事情

1059
00:54:07,745 --> 00:54:11,013
添加到一个功能。好吧，但你有点变得这样

1060
00:54:11,081 --> 00:54:14,149
限制实际上是一个很好的限制。这不是

1061
00:54:14,217 --> 00:54:16,952
太糟糕了，他们可以用存储来发明它。您

1062
00:54:17,020 --> 00:54:19,354
其实不想存储，你会看到我们

1063
00:54:19,423 --> 00:54:22,690
去为什么那是。所以，你可以想象这个功能

1064
00:54:22,759 --> 00:54:26,728
很容易被滥用，并且是被滥用的头号方法，

1065
00:54:26,797 --> 00:54:29,598
我鼓励你不要以这种方式来虐待你

1066
00:54:29,667 --> 00:54:33,835
不想添加一个bar或一个func到没有的类

1067
00:54:33,904 --> 00:54:38,840
对那个阶级有意义。这是一个真正的诱惑

1068
00:54:38,909 --> 00:54:43,578
例如一个init或字符串来添加一个必须的函数

1069
00:54:43,647 --> 00:54:47,916
用专心做。一些浓度特定的方法

1070
00:54:47,984 --> 00:54:50,719
你添加到字符串cuz它会清理你的代码或

1071
00:54:50,788 --> 00:54:53,689
看起来不错或什么但是你真的不想这样做。

1072
00:54:53,757 --> 00:54:56,658
唯一的方法和功能，你想添加到字符串或

1073
00:54:56,727 --> 00:54:59,962
方法，使字符串关于一个类。他们使它更好

1074
00:55:00,030 --> 00:55:03,398
字符串不是他们知道集中。现在，

1075
00:55:03,467 --> 00:55:06,134
这可能是可能的添加字符串，使其成为可能

1076
00:55:06,203 --> 00:55:08,503
知道浓度，没有什么真正的错误。

1077
00:55:08,572 --> 00:55:10,405
这只是一种糟糕的设计。可以，然后呢

1078
00:55:10,474 --> 00:55:14,209
像我说的这个扩展的功能是非常强大的，

1079
00:55:14,277 --> 00:55:17,979
既然你刚刚从这里开始，你可以考虑一下

1080
00:55:18,048 --> 00:55:21,783
开始只是添加实用程序，功能和方法的一种方式

1081
00:55:21,852 --> 00:55:24,419
这样的事情来清理你的代码。

1082
00:55:24,488 --> 00:55:27,622
好吧，这是关于扩展的第一级学习

1083
00:55:27,691 --> 00:55:29,925
我将向你展示我们如何做到这一点

1084
00:55:29,994 --> 00:55:33,862
例如浓度。所以让我们去集中和

1085
00:55:33,930 --> 00:55:37,298
使用扩展来添加一些有趣的东西

1086
00:55:37,367 --> 00:55:41,202
我们要做的有趣的事情是我们要去做

1087
00:55:41,271 --> 00:55:43,805
去我们的视图控制器在这里和

1088
00:55:43,874 --> 00:55:47,876
看看这里的代码是有点混乱。

1089
00:55:47,945 --> 00:55:50,245
就在这儿。好的？什么是这个代码混乱？

1090
00:55:50,314 --> 00:55:55,150
好。好的。我真正想要做的是删除一个随机的表情符号。

1091
00:55:55,219 --> 00:55:57,051
而且你必须有一整行的代码。

1092
00:55:57,120 --> 00:56:02,457
那行代码有这个可怕的数额。更改

1093
00:56:02,526 --> 00:56:06,328
从无符号整数到正则整数和所有这些东西。

1094
00:56:06,396 --> 00:56:08,930
所以它看起来很糟糕，而且很难阅读，

1095
00:56:08,999 --> 00:56:10,865
很难理解这里发生了什么。

1096
00:56:10,934 --> 00:56:13,502
我不得不这样做很多类型转换，类似的东西。

1097
00:56:13,570 --> 00:56:18,006
这太可怕了，好吗？真的，我想要做的是产生

1098
00:56:18,075 --> 00:56:24,146
一个随机数，并把它放在这里。那么如果int，

1099
00:56:24,215 --> 00:56:27,916
int类型，有一个var给了我一个随机的

1100
00:56:27,984 --> 00:56:31,319
整数？好吧，这是一个非常整洁的事情，没有什么

1101
00:56:31,388 --> 00:56:33,822
集中注意力，这是一个整体的东西。

1102
00:56:33,891 --> 00:56:38,126
它给了我一个随机整数。所以我们要扩展int

1103
00:56:38,195 --> 00:56:42,263
给一个随机整数。具体来说，我们会做的

1104
00:56:42,332 --> 00:56:44,799
这样当你问一个int时，请给我一个随机的

1105
00:56:44,868 --> 00:56:47,436
整数它给出了一个0和那个之间的随机整数

1106
00:56:47,504 --> 00:56:51,840
INT。好，如果我说五，我甚至可以说，我会成为的

1107
00:56:51,909 --> 00:56:55,143
这里可以说让x等于五点随机整数。

1108
00:56:55,212 --> 00:56:58,580
而且我会把这个东西叫做arc4random，这个变种。

1109
00:56:58,649 --> 00:57:01,349
因为我要用arc4random生成它

1110
00:57:01,418 --> 00:57:03,919
人们知道arc4random的语义

1111
00:57:03,988 --> 00:57:04,786
一个随机的数字

1112
00:57:04,854 --> 00:57:08,523
在0和另一个数字之间。所以这是我要做的

1113
00:57:08,592 --> 00:57:13,428
所以这将工作，这会给我0,1,2,3或4。

1114
00:57:13,496 --> 00:57:18,634
那我该怎么做？扩展int然后在这里

1115
00:57:18,702 --> 00:57:24,306
我把这个var arc4random。我不得不说什么类型，

1116
00:57:24,374 --> 00:57:27,175
这也将是一个整数。它可能是一个字符串或

1117
00:57:27,244 --> 00:57:29,411
无论如何，这也将是一个整数。和

1118
00:57:29,479 --> 00:57:33,014
我基本上会在这里把这一切都弄回去。所以

1119
00:57:33,083 --> 00:57:37,819
我只是要把那个切掉我会回来这个。

1120
00:57:37,888 --> 00:57:40,622
但它不是0到emojiChoices.count之间的随机数

1121
00:57:40,691 --> 00:57:44,526
它是0到什么之间的随机

1122
00:57:44,595 --> 00:57:50,665
顺序？是的，我希望我可以给予额外的信贷或

1123
00:57:50,734 --> 00:57:53,201
像Mehran，把糖果扔到那里或者

1124
00:57:53,270 --> 00:57:56,337
因为是绝对的，它介于0和

1125
00:57:56,406 --> 00:58:01,443
self。因为这是int中的一个var。自我就是整体

1126
00:58:01,512 --> 00:58:06,514
你发给它。这真的很酷。所以现在

1127
00:58:06,583 --> 00:58:09,784
因为int可以做到这一点，所以我们需要做的就是我们

1128
00:58:09,853 --> 00:58:13,789
这里不需要任何垃圾。而不是randomIndex，

1129
00:58:13,857 --> 00:58:17,993
我们只是要说emojiChoices.count.arc4random。

1130
00:58:18,062 --> 00:58:22,664
好吧，那么，我们的代码清理了很多。现在，

1131
00:58:22,733 --> 00:58:25,467
如果我们要这样做，我们想要

1132
00:58:25,536 --> 00:58:28,803
真是好程序员，我们看看这个，说，嗯，

1133
00:58:28,872 --> 00:58:30,905
如果自己是0呢？呃这个不行，

1134
00:58:30,974 --> 00:58:32,674
cuz arc4rando_uniform不起作用，但是

1135
00:58:32,743 --> 00:58:35,744
如果自我是负面的呢？其实，如果自己是

1136
00:58:35,812 --> 00:58:38,513
否定的，也许我可以做一个0到negative之间的随机数

1137
00:58:38,582 --> 00:58:42,684
我可以决定，我会说如果

1138
00:58:42,753 --> 00:58:46,955
自我大于0，那么我会这样做。

1139
00:58:47,024 --> 00:58:52,026
否则，如果自己小于0，那么我会几乎这样做。

1140
00:58:52,095 --> 00:58:56,865
我要做什么，我会返回货减去这个

1141
00:58:56,934 --> 00:59:00,202
我自己的绝对价值。好的，

1142
00:59:00,270 --> 00:59:04,339
abs只是一个全局函数。但我也可以说

1143
00:59:04,408 --> 00:59:06,675
减去自我因为我检查，看看是否是负的。

1144
00:59:06,743 --> 00:59:10,345
否则，如果自己是0，这里就是其他情况，

1145
00:59:10,414 --> 00:59:12,580
那么也许我只会返回0.所以，如果你说，0，

1146
00:59:12,649 --> 00:59:15,950
给我一个随机数，它给你一个0.所以，我在这里

1147
00:59:16,019 --> 00:59:19,887
使它从不崩溃。这不是必须的

1148
00:59:19,956 --> 00:59:23,825
是一个可选的int，它给出了合理的响应。

1149
00:59:23,894 --> 00:59:26,995
看，当你添加条形图时，这很好

1150
00:59:27,063 --> 00:59:30,632
功能到任何类别。现在你可以通过扩展，

1151
00:59:30,700 --> 00:59:34,302
你希望他们有很好的语义，合理的语义。

1152
00:59:34,371 --> 00:59:36,905
而且你通常不希望他们崩溃，这是

1153
00:59:36,974 --> 00:59:38,607
否则这将会做什么。

1154
00:59:38,675 --> 00:59:40,942
如果你发送到-3。

1155
00:59:41,011 --> 00:59:45,346
每个人都看到这是如何使我们的代码更具可读性。

1156
00:59:45,415 --> 00:59:48,083
而我们如何添加一些对int来说是明智的。

1157
00:59:49,953 --> 00:59:53,755
好吧，就这样，让我们​​再回到我们的幻灯片。

1158
00:59:55,659 --> 00:59:58,960
这是我们的枚举。好吧，可选项，

1159
00:59:59,029 --> 01:00:03,832
可怕的单词可选。所以我最后告诉你了

1160
01:00:03,901 --> 01:00:06,701
一周，可选只是Swift中的一个常规旧式。

1161
01:00:06,770 --> 01:00:07,969
其实这是一个枚举，

1162
01:00:08,037 --> 01:00:11,539
枚举。所以让我们来学习枚举，因为枚举是

1163
01:00:11,608 --> 01:00:13,909
另一件事情我不能把它集中注意力，

1164
01:00:13,977 --> 01:00:17,045
尽管我会在下周的演示中使用它。好的，

1165
01:00:17,114 --> 01:00:19,981
我们的绘图演示。但是我想解释一下这是怎么回事

1166
01:00:20,050 --> 01:00:22,751
我可以解释什么是可选的更好一点。

1167
01:00:22,820 --> 01:00:25,753
所以枚举就像其他语言中的枚举一样。

1168
01:00:25,822 --> 01:00:28,156
这是一个数据类型，就像struct是一个类型或

1169
01:00:28,225 --> 01:00:29,824
类是一个类型，枚举是一个类型。

1170
01:00:29,893 --> 01:00:32,828
完全一样，你可以在完全相同的地方使用它。

1171
01:00:32,896 --> 01:00:37,899
只是它只有离散值。这里的

1172
01:00:37,968 --> 01:00:40,701
一个FastFoodMenuItem枚举，它只能是汉堡包，薯条，

1173
01:00:40,770 --> 01:00:43,471
饮料或饼干。就是这样，它不可能是别的

1174
01:00:43,540 --> 01:00:45,172
除了这四件事之一之外

1175
01:00:45,241 --> 01:00:50,645
这是一个枚举是什么。枚举是值类型，比如结构体，

1176
01:00:50,714 --> 01:00:55,783
当你通过它们时，它们会被复制。现在枚举

1177
01:00:55,852 --> 01:01:00,488
因为你的典型枚举，Swift更强大一些

1178
01:01:00,556 --> 01:01:05,026
每个案例也可以有所谓的相关数据，或者

1179
01:01:05,094 --> 01:01:08,296
一个相关的值。所以在我的快餐项目之一

1180
01:01:08,365 --> 01:01:10,565
汉堡包有馅饼的数量，

1181
01:01:10,634 --> 01:01:12,400
这是一个双汉堡还是一个三重的？

1182
01:01:12,469 --> 01:01:15,303
单？薯条有薯条的大小，

1183
01:01:15,371 --> 01:01:18,773
大炒，还是小炒。而且我甚至用另一个枚举，

1184
01:01:18,842 --> 01:01:20,842
你在这里看到底部。

1185
01:01:20,911 --> 01:01:24,245
我有另一个，哎呀，我的东西在这里工作。在那里。

1186
01:01:24,314 --> 01:01:29,250
这不是很好。好的，我们知道了。在那里。所以

1187
01:01:29,319 --> 01:01:32,153
我可以使用另一个枚举来做它的大小和

1188
01:01:32,222 --> 01:01:37,058
然后喝。它有两个相关的数据。

1189
01:01:37,127 --> 01:01:39,160
好的，让我们看看我们是否能为此工作。

1190
01:01:39,229 --> 01:01:41,062
如果你看看它的两个相关数据，

1191
01:01:41,130 --> 01:01:42,097
看看第一个。

1192
01:01:42,165 --> 01:01:45,499
那个字符串，它没有名字。这些其他的有名字，

1193
01:01:45,568 --> 01:01:47,969
像馅饼的数量，大小，这一个没有名字

1194
01:01:48,038 --> 01:01:50,705
第一个，它确实有第二个名字。

1195
01:01:50,774 --> 01:01:53,374
首先是字符串，然后是int。现在这里的名字没有

1196
01:01:53,443 --> 01:01:56,544
这很重要，因为当我们提取这些信息时，

1197
01:01:56,613 --> 01:01:59,246
无论如何，我们将能够给我们自己的名字，

1198
01:01:59,315 --> 01:02:02,350
有点像元组。其实这些看起来很像元组，

1199
01:02:02,419 --> 01:02:04,552
不是吗？这些相关的小数据，

1200
01:02:04,620 --> 01:02:07,055
他们有点像元组，因为你可以拥有很多元组

1201
01:02:07,124 --> 01:02:08,990
他们是你想要的，你指定的类型，

1202
01:02:09,059 --> 01:02:11,093
他们有名字，他们超级简单

1203
01:02:11,161 --> 01:02:14,095
他们看起来很像元组。所以无论如何，

1204
01:02:14,164 --> 01:02:16,697
所以这是看起来像声明一个枚举

1205
01:02:16,766 --> 01:02:20,334
关联的数据。现在，你如何分配一个枚举？

1206
01:02:20,403 --> 01:02:23,071
所以这里有两个变量，一个叫菜单项，

1207
01:02:23,140 --> 01:02:25,840
一个叫其他项目。它们是FastFoodMenuItem类型的，

1208
01:02:25,909 --> 01:02:28,876
这是他们的类型。所以我只是说，

1209
01:02:28,945 --> 01:02:31,779
FastFoodMenuItem点我想要的情况。

1210
01:02:31,848 --> 01:02:37,118
如果它有相关的数据，我必须提供它。

1211
01:02:37,187 --> 01:02:42,057
所以你唯一可以设置一个枚举的关联数据

1212
01:02:42,125 --> 01:02:45,226
是当你分配它。那是唯一的一次好的，

1213
01:02:45,294 --> 01:02:48,062
你不能晚一点回去，把这个变成三重的，

1214
01:02:48,131 --> 01:02:51,032
因为这根本是一个双重汉堡。

1215
01:02:51,101 --> 01:02:53,634
就是这样。如果它改变的话，它永远不会

1216
01:02:53,703 --> 01:02:56,871
变成完全不同的东西。好，那么

1217
01:02:56,940 --> 01:03:01,008
你不改变肉饼，明白吗？好的，那么，什么时候

1218
01:03:01,077 --> 01:03:04,980
你正在设置这些值，当然你可以使用

1219
01:03:05,048 --> 01:03:08,683
类型推理，但只在这一方的平等。所以

1220
01:03:08,752 --> 01:03:12,354
你可以说menuItem等于FastFoodMenuItem.hamburger。

1221
01:03:12,422 --> 01:03:15,089
这是前一张幻灯片上的内容，或者

1222
01:03:15,158 --> 01:03:18,626
你可以说FastFoodMenuItem类型的otherItem等于

1223
01:03:18,695 --> 01:03:19,727
。曲奇饼。你看，

1224
01:03:19,796 --> 01:03:21,996
我只是基本上把这个类型移到了另一边。但

1225
01:03:22,065 --> 01:03:25,966
你不能说另一个项目等于.cookie。Swift不

1226
01:03:26,035 --> 01:03:29,337
在那里知道足够的推断在另一边的类型。那里

1227
01:03:29,406 --> 01:03:31,505
例如，可以是其他的.cookie的枚举，

1228
01:03:31,574 --> 01:03:33,775
你可能会稍后添加。然后突然你的代码

1229
01:03:33,844 --> 01:03:35,309
不会编译，因为它不知道。所以

1230
01:03:35,378 --> 01:03:38,680
它只是从一开始就说，我不知道那是什么。

1231
01:03:39,783 --> 01:03:42,350
现在你如何检查一个枚举是什么？

1232
01:03:42,419 --> 01:03:44,953
你不使用等于。所以你不要说，

1233
01:03:45,021 --> 01:03:49,523
如果这个菜单项等于一个汉堡，那么无论如何，好吧，

1234
01:03:49,592 --> 01:03:53,328
你不使用等于，你使用开关。再次，其他语言

1235
01:03:53,397 --> 01:03:56,097
有开关。开关在Swift中更强大。

1236
01:03:56,166 --> 01:03:58,900
这是我在哪里的开关的基本用法

1237
01:03:58,968 --> 01:04:02,137
只是看每一个可能的情况下，和

1238
01:04:02,205 --> 01:04:03,938
如果是这种情况，我会做一些代码。

1239
01:04:04,007 --> 01:04:07,041
所以在这里我只是打印出各种情况是如此

1240
01:04:07,110 --> 01:04:09,043
如果是汉堡包，例如，

1241
01:04:09,112 --> 01:04:11,379
你可以看到我正在打印汉堡。

1242
01:04:11,448 --> 01:04:14,249
请注意，我忽略了这里的关联数据

1243
01:04:14,317 --> 01:04:15,249
非常好。

1244
01:04:15,318 --> 01:04:17,886
您可以完全忽略相关数据

1245
01:04:17,955 --> 01:04:21,555
当你用开关检查状态时。现在

1246
01:04:21,624 --> 01:04:25,326
开关要求你解决每一个案件。你不是

1247
01:04:25,395 --> 01:04:28,463
只允许看两个案件。但是当然，

1248
01:04:28,531 --> 01:04:34,068
它有一些可以帮助你的东西。哦，是的，

1249
01:04:34,137 --> 01:04:37,605
顺便说一句，你看我已经拿走了FastFoodMenuItem。

1250
01:04:37,674 --> 01:04:40,775
在汉堡面前，薯条，饮料和可乐。因为迅速

1251
01:04:40,843 --> 01:04:43,077
可以推断出，你正在切换一个菜单项，所以

1252
01:04:43,146 --> 01:04:45,280
它知道这是一个FastFoodMenuItem，所以

1253
01:04:45,348 --> 01:04:49,317
你可以把那些拿走好的，如果你有其中一个的话

1254
01:04:49,385 --> 01:04:52,287
你不想做任何事情，你可以

1255
01:04:52,356 --> 01:04:55,890
打破break。休息意味着打破这个switch。所以

1256
01:04:55,958 --> 01:04:58,626
在这种情况下，这是一种无所作为的方式。所以，在这里，

1257
01:04:58,694 --> 01:05:01,062
这个代码，我们打印什么都不是因为汉堡包的情况，

1258
01:05:01,130 --> 01:05:03,698
菜单项是一个有两个肉饼的汉堡包

1259
01:05:03,767 --> 01:05:04,999
那汉堡包什么都不做，所以

1260
01:05:05,068 --> 01:05:08,636
我们只会break out，什么也不做。同样的，

1261
01:05:08,705 --> 01:05:12,306
如果你想为所有其他case做一些事情，

1262
01:05:12,375 --> 01:05:13,841
像这里我只想做点什么

1263
01:05:13,910 --> 01:05:16,977
汉堡包和薯条。其实我对汉堡包什么都不做

1264
01:05:17,046 --> 01:05:18,079
我为薯条做点什么

1265
01:05:18,147 --> 01:05:20,949
在其他所有情况下，我只想打印其他的，然后你

1266
01:05:21,017 --> 01:05:24,919
可以使用默认值而不是大小写。现在在切换中

1267
01:05:24,987 --> 01:05:29,424
你可以切换任何类型，甚至可以打开一个字符串。

1268
01:05:29,492 --> 01:05:32,426
但是如果你打开一个字符串，你必须有情况A，

1269
01:05:32,495 --> 01:05:35,029
案例B，案例C，案例AA，案例AB，你明白我的意思了吗？

1270
01:05:35,098 --> 01:05:37,165
你必须有世界上的每一个case。

1271
01:05:37,234 --> 01:05:40,502
所以当然你会使用默认离子字符串的情况下

1272
01:05:40,570 --> 01:05:41,836
切换情况下的情侣

1273
01:05:41,904 --> 01:05:45,306
你想要的情况下，那么你会默认其余的。所以

1274
01:05:45,375 --> 01:05:50,778
默认是一个必须，甚至对于枚举我们使用它相当多，

1275
01:05:50,847 --> 01:05:53,948
好吧？所以这是一个枚举。所以

1276
01:05:54,017 --> 01:05:58,753
如果这是一个cookie，那么它会打印其他。好吧，

1277
01:05:58,822 --> 01:06:01,455
多线，我只是想澄清，多个

1278
01:06:01,524 --> 01:06:03,724
代码行是允许的，它不一定是一行。

1279
01:06:03,793 --> 01:06:05,025
这只是因为我在这里的幻灯片，

1280
01:06:05,094 --> 01:06:06,661
我正在努力使一切合适，而且

1281
01:06:06,730 --> 01:06:10,265
没有经过。所以在这种情况下，我有炸薯条，

1282
01:06:10,333 --> 01:06:12,166
你看到那里顶部，薯条，

1283
01:06:12,234 --> 01:06:13,701
那里有大薯条。和

1284
01:06:13,770 --> 01:06:18,039
所以这个代码会打印出美味的火，就是这样。所以

1285
01:06:18,107 --> 01:06:20,007
我在薯条下有多行代码，

1286
01:06:20,076 --> 01:06:22,977
两行代码，它不会掉下来喝酒，

1287
01:06:23,046 --> 01:06:26,080
像其他语言一样。在C中，东西在切换中

1288
01:06:26,149 --> 01:06:28,116
但他们不会经过这里。有一个关键字

1289
01:06:28,184 --> 01:06:30,585
所谓的fallthrough，会让你跌倒，但是

1290
01:06:30,653 --> 01:06:36,591
默认情况下不是。顺便说一下，它推断

1291
01:06:36,660 --> 01:06:40,561
一直在这里的类型，它也可以用于这种类型。

1292
01:06:40,630 --> 01:06:45,066
我不必说大小，炸薯条大小enum.large，

1293
01:06:45,135 --> 01:06:47,902
我只能说，。大，因为它知道相关的

1294
01:06:47,971 --> 01:06:53,274
薯条的数据是大小枚举。好的，

1295
01:06:53,342 --> 01:06:57,778
现在，如果我想获得关联的数据。所以我呢，

1296
01:06:57,847 --> 01:07:00,815
我对它感兴趣。我们也是用开关来做的，

1297
01:07:00,883 --> 01:07:05,319
我们只是做这个小生意。看到小小的让步。

1298
01:07:05,388 --> 01:07:07,789
在所有你想要这个相关数据的情况下，

1299
01:07:07,858 --> 01:07:09,190
你不必在所有情况下都这样做，但是

1300
01:07:09,258 --> 01:07:11,326
在你想要的？你只是说，开括号，

1301
01:07:11,394 --> 01:07:15,229
让和一个小的局部变量的名字为

1302
01:07:15,298 --> 01:07:18,265
每个相关的数据块。现在，

1303
01:07:18,334 --> 01:07:21,702
你用的那个小名字，所以如果这是一个可乐看到它

1304
01:07:21,771 --> 01:07:25,306
会打印任何盎司可乐，因为只是

1305
01:07:25,374 --> 01:07:28,409
把可乐变成品牌它正在进入盎司

1306
01:07:28,477 --> 01:07:31,145
一些叫做盎司的东西，然后就是这样打印。

1307
01:07:31,214 --> 01:07:35,716
这个命名不一定是相同的名字

1308
01:07:35,785 --> 01:07:38,419
如你所宣布的枚举。事实上，

1309
01:07:38,487 --> 01:07:42,723
如果我们在这里看这个可口可乐，这让品牌，

1310
01:07:42,792 --> 01:07:45,827
记得在最初没有名字的枚举中，

1311
01:07:45,896 --> 01:07:48,929
这只是一个字符串，对吧？它有盎司，

1312
01:07:48,998 --> 01:07:52,399
结肠盎司，并在这里与汉堡，pattyCount，

1313
01:07:52,468 --> 01:07:56,837
这在原来的声明中被称为肉饼。所以

1314
01:07:56,906 --> 01:08:00,641
再次，这看起来不熟悉元组，对吗？

1315
01:08:00,710 --> 01:08:03,878
您可以在获取信息时对其进行重命名

1316
01:08:03,946 --> 01:08:07,549
在他们之外。所以这是如何提取数据

1317
01:08:07,617 --> 01:08:11,953
脱离相关的类型。很简单，和

1318
01:08:12,022 --> 01:08:14,756
再次，它是可选的，你不必在那里。

1319
01:08:15,992 --> 01:08:19,126
还枚举，他们就像结构和类。

1320
01:08:19,195 --> 01:08:23,431
他们可以有方法，他们可以有变数，但没有储存。

1321
01:08:23,500 --> 01:08:26,600
所有的枚举的故事是在这种情况下，它是

1322
01:08:26,669 --> 01:08:28,035
这种情况是关联的数据。

1323
01:08:28,104 --> 01:08:30,872
就是这样，你不能有许多其他的变数或别的东西。

1324
01:08:30,940 --> 01:08:34,275
所以唯一的变数就是计算变量。

1325
01:08:34,344 --> 01:08:37,245
所以看看我在这里的例子，它的卡路里，

1326
01:08:37,313 --> 01:08:40,148
在那里你会计算该菜单项的卡路里

1327
01:08:40,216 --> 01:08:43,618
这将是一个计算类型。不能存储

1328
01:08:43,686 --> 01:08:47,422
除了关联的数据权限之外，枚举中的任何东西

1329
01:08:47,490 --> 01:08:50,291
那里。现在如果你正在写一个这样的func，

1330
01:08:50,360 --> 01:08:53,495
isIncludedInSpecialOrder number or one or two two or

1331
01:08:53,563 --> 01:08:56,164
随你。如果你这样做，那么你可以

1332
01:08:56,232 --> 01:09:01,336
使用开启自己获取您自己的相关数据。

1333
01:09:01,404 --> 01:09:03,972
因为我在里面的枚举排列在这里，对不对？

1334
01:09:04,040 --> 01:09:05,573
所以我可以打开自己，然后，

1335
01:09:05,642 --> 01:09:07,241
我可以得到我的相关数据

1336
01:09:07,310 --> 01:09:08,743
我可以计算出我的卡路里。要么

1337
01:09:08,811 --> 01:09:11,445
在这种情况下，我正在计算是否与汉堡包

1338
01:09:11,514 --> 01:09:14,015
特别的二号包括两个馅饼。

1339
01:09:14,084 --> 01:09:17,285
而我的代码在这里说是的，因为相当多，

1340
01:09:17,353 --> 01:09:19,120
特殊的订单号码是一个汉堡，

1341
01:09:19,189 --> 01:09:21,789
和/或2是double。现在还有其他一些

1342
01:09:21,858 --> 01:09:24,358
有趣的事情，看在这个代码。注意到

1343
01:09:24,427 --> 01:09:27,629
薯条和饼干就在那里。在中间，薯条和

1344
01:09:27,697 --> 01:09:31,565
曲奇饼。那些我把它们合并成一个case，

1345
01:09:31,634 --> 01:09:34,468
这是逗号可以有多个

1346
01:09:34,537 --> 01:09:38,206
去那里。还注意饮料，好吧，我

1347
01:09:38,274 --> 01:09:41,042
得到一个饮料，但明显在一个盎司的数量

1348
01:09:41,110 --> 01:09:44,145
一个特殊的订单，你可以有任何饮料是16盎司。

1349
01:09:44,214 --> 01:09:47,314
所以我不在乎是什么样的饮料，我不在乎

1350
01:09:47,383 --> 01:09:51,152
那个品牌。所以我用通用的我不在乎的象征

1351
01:09:51,221 --> 01:09:54,722
在斯威夫特下吧，对吗？请记住，我们用过

1352
01:09:54,791 --> 01:09:58,359
当我们不在乎什么外部名称和

1353
01:09:58,427 --> 01:10:01,662
触摸卡了。当我们没有时，我们在四个循环中使用它

1354
01:10:01,731 --> 01:10:04,065
关心标识符在集中什么，

1355
01:10:04,134 --> 01:10:07,535
所以我们也可以在这里使用它，好吗？

1356
01:10:09,239 --> 01:10:14,074
只要它在var中就可以在枚举中修改self。如果

1357
01:10:14,143 --> 01:10:17,845
它是可以修改的，你只是说自己等于其他情况。

1358
01:10:17,914 --> 01:10:19,847
如果其他情况需要相关数据，

1359
01:10:19,915 --> 01:10:23,083
那么你必须提供它，你可以说自我平等。

1360
01:10:23,152 --> 01:10:25,720
现在，要注意一个非常重要的事情，如果你要去的话

1361
01:10:25,789 --> 01:10:28,890
通过说自我平等在一个枚举中修改自己，

1362
01:10:28,959 --> 01:10:30,357
这是修改自己的唯一方法，

1363
01:10:30,426 --> 01:10:34,195
顺便一提。那么你必须改变

1364
01:10:34,264 --> 01:10:37,197
在变异你的函数前面，

1365
01:10:37,266 --> 01:10:38,566
那修改自己。

1366
01:10:38,634 --> 01:10:43,304
这是因为快速枚举是一个值类型和

1367
01:10:43,372 --> 01:10:46,073
记住值类型通过复制传递，但是

1368
01:10:46,142 --> 01:10:49,810
写上有副本。所以，如果它不写在哪写

1369
01:10:49,879 --> 01:10:52,546
意味着它直到你写下来才真正做出一个副本。

1370
01:10:52,615 --> 01:10:53,615
那么如果这样做，

1371
01:10:53,683 --> 01:10:58,519
它需要知道哪些funcs可能会写。所以

1372
01:10:58,588 --> 01:11:01,388
这就是变异的意思，这意味着这个func可能会写，

1373
01:11:01,457 --> 01:11:05,025
它可能会改变这一点。你必须做同样的事情

1374
01:11:05,094 --> 01:11:08,996
在一个结构中。如果你在一个结构体中有一个func，

1375
01:11:09,064 --> 01:11:10,965
它修改任何内部状态

1376
01:11:11,033 --> 01:11:13,100
结构，它必须标记突变，所以

1377
01:11:13,169 --> 01:11:16,370
Swift知道要复制和写入。别担心，Swift

1378
01:11:16,439 --> 01:11:19,440
是非常聪明的，它会看到你的代码，它会看到你在说

1379
01:11:19,508 --> 01:11:22,142
自我平等，它会看到你正在修改你的bars

1380
01:11:22,211 --> 01:11:26,046
一个结构它会抱怨，并说这是保护你

1381
01:11:26,115 --> 01:11:29,183
不能写这个东西，因为这不是一个变异的函数。

1382
01:11:29,251 --> 01:11:31,418
你可以通过使它变异来解决它

1383
01:11:31,487 --> 01:11:34,555
事实上，你可以在一秒钟内看到浓度演示

1384
01:11:34,624 --> 01:11:37,758
这里。好吧，让我们来看看是否为枚举，非常简单。

1385
01:11:37,826 --> 01:11:41,562
所以可选的只是一个枚举，看起来像这样，

1386
01:11:41,631 --> 01:11:44,398
种类，概念上。这是一个可选的，

1387
01:11:44,467 --> 01:11:47,435
它是一个像数组一样的泛型类型。数组可以有任何东西

1388
01:11:47,504 --> 01:11:49,103
它，一个可选的可以是一个可选的Int，

1389
01:11:49,172 --> 01:11:51,739
一个可选的字符串，无论它是一个通用的类型。和

1390
01:11:51,808 --> 01:11:53,941
在枚举中有两个例子，

1391
01:11:54,009 --> 01:11:58,713
没有设置的情况下，呃，和其他情况

1392
01:11:58,781 --> 01:12:01,782
其中有一些关联的数据类型。

1393
01:12:01,851 --> 01:12:04,352
所以一个可选的int将意味着int，所以就是这样，

1394
01:12:04,420 --> 01:12:07,588
这是可选的。现在可选，为什么不，

1395
01:12:07,657 --> 01:12:09,190
为什么我们不把它放在枚举？

1396
01:12:09,259 --> 01:12:10,624
那么，上帝，你能想象，

1397
01:12:10,693 --> 01:12:13,360
每次你想打开一个可选的，你必须

1398
01:12:13,429 --> 01:12:16,029
切换的东西，以防万一有关联的数据？

1399
01:12:16,098 --> 01:12:18,866
这将是如此多的打字。所以这些都是特别的

1400
01:12:18,935 --> 01:12:21,135
我们拥有的字符是可选项，问号，

1401
01:12:21,204 --> 01:12:23,470
感叹号，ifs，双重问号。

1402
01:12:23,539 --> 01:12:26,674
所有的东西都是我们不必经常的

1403
01:12:26,743 --> 01:12:29,877
切换我们的可选和做这种情况下，情况。

1404
01:12:29,945 --> 01:12:31,812
但是这只是在封面上做的，

1405
01:12:31,881 --> 01:12:33,781
这只是语法糖，是这样做的。

1406
01:12:33,850 --> 01:12:35,382
这不是别的，

1407
01:12:35,451 --> 01:12:39,019
不是，没什么特别的。所以我会告诉你什么

1408
01:12:39,088 --> 01:12:42,189
这些特殊字符看起来像在enum的土地上。

1409
01:12:42,258 --> 01:12:44,759
而且，我甚至会告诉你一个新的枚举或

1410
01:12:44,827 --> 01:12:47,428
一个新的可选的东西，这是在底部这个东西

1411
01:12:47,497 --> 01:12:50,497
称为可选链。而且这是你使用单一的地方

1412
01:12:50,566 --> 01:12:52,900
当你访问一个可选的问号。

1413
01:12:52,969 --> 01:12:55,436
这是我们没有看到的一件事，而且我会

1414
01:12:55,505 --> 01:12:57,605
通过在enum土地上展示你如何展示你的作品。

1415
01:12:57,673 --> 01:13:02,477
好吧？所以，声明可选项很明显，对吗？

1416
01:13:02,545 --> 01:13:04,412
如果我打招呼，这是一个可选的字符串，

1417
01:13:04,481 --> 01:13:08,181
这只是可选的尖括号字符串。和

1418
01:13:08,250 --> 01:13:11,485
记住，可选项总是从零开始。所以，我会，

1419
01:13:11,554 --> 01:13:15,990
它会从没有开始。不能更简单。

1420
01:13:16,059 --> 01:13:18,959
展开也很简单，那只是切换

1421
01:13:19,028 --> 01:13:22,063
在事情上。所以，如果我有一个可选的字符串你好，我

1422
01:13:22,131 --> 01:13:25,366
打印（你好！），感叹号打开它

1423
01:13:25,435 --> 01:13:27,834
我只是打开你好。如果没有的话，

1424
01:13:27,903 --> 01:13:30,438
我崩溃了。如果在某种情况下，

1425
01:13:30,506 --> 01:13:33,240
然后我打印任何相关的数据。一样

1426
01:13:33,309 --> 01:13:36,577
如果放在谷底的话。我打开你好。

1427
01:13:36,645 --> 01:13:38,445
如果在某种情况下，我这样做。

1428
01:13:38,514 --> 01:13:39,413
如果没有的话，

1429
01:13:39,481 --> 01:13:44,619
我做了其他部分的if。大家都知道了？

1430
01:13:44,687 --> 01:13:47,188
隐含的解包选项是完全一样的。它的

1431
01:13:47,256 --> 01:13:49,956
只是当我在这边打印打招呼的时候，

1432
01:13:50,025 --> 01:13:53,193
这个打印你好，我不用把感叹号。

1433
01:13:53,262 --> 01:13:57,731
如果它没有，它仍然打开hello和崩溃。所以

1434
01:13:57,800 --> 01:14:01,168
这是隐含的解开。那些也从零开始

1435
01:14:01,236 --> 01:14:04,105
因为他们只是可选项。无结合

1436
01:14:04,173 --> 01:14:06,340
运营商，这是我们使用的违约事物，

1437
01:14:06,409 --> 01:14:09,076
如果你还记得，在我们的代码。我们看着我们的表情符号

1438
01:14:09,145 --> 01:14:11,245
字典，如果不在那里，

1439
01:14:11,313 --> 01:14:14,081
然后我们返回问号。那只是

1440
01:14:14,150 --> 01:14:16,918
打开它。如果没有，那么它使用

1441
01:14:16,986 --> 01:14:19,386
默认，好吧，在另一边的东西。和

1442
01:14:19,455 --> 01:14:24,125
如果是这样的话，那就用它找到的东西。

1443
01:14:24,193 --> 01:14:27,861
这是可选的链接。所以可以选择链接，想象一下

1444
01:14:27,930 --> 01:14:31,065
在这里，好吧，如果你看这个小小的让x等于，

1445
01:14:31,134 --> 01:14:34,635
想象一下x和方法foo和

1446
01:14:34,704 --> 01:14:39,040
var吧，所有这三个，想象那些回报

1447
01:14:39,108 --> 01:14:42,476
一个可选的字符串好的，所以我们不知道他们在做什么，

1448
01:14:42,545 --> 01:14:43,878
但他们返回一个可选的字符串。

1449
01:14:43,946 --> 01:14:46,913
他们可能会也可能不会返回零。好吧，什么可选

1450
01:14:46,982 --> 01:14:49,350
那里的链接让我们做的就是打电话给那些事情，

1451
01:14:49,418 --> 01:14:50,985
顺序叫做一个。和

1452
01:14:51,053 --> 01:14:53,320
那么当我们得到这个价值的时候，就接下来的事情。

1453
01:14:53,389 --> 01:14:55,523
我们获得价值，接下来就是这个问题。和

1454
01:14:55,591 --> 01:14:58,525
如果在任何时候任何这些事情都是零，我们只是保释

1455
01:14:58,594 --> 01:15:02,796
退出并返回零。所以在选择的土地上工作的方式是

1456
01:15:02,865 --> 01:15:06,634
我们先打开它。如果没有，我们返回零。

1457
01:15:06,703 --> 01:15:09,637
但是，如果不是，我们得到的数据和foo。

1458
01:15:09,705 --> 01:15:12,139
如果这样做，我们从foo那里得到这些数据

1459
01:15:12,208 --> 01:15:14,475
我们叫吧。最终，

1460
01:15:14,543 --> 01:15:17,311
我们把y等于z出来，对吗？

1461
01:15:17,380 --> 01:15:20,581
我们只是穿过链条。如果在任何时候，

1462
01:15:20,649 --> 01:15:22,883
任何这些东西都是零，看所有的情况nones。

1463
01:15:22,951 --> 01:15:25,486
情况。无，情况。无，情况。无，Y变成零，而

1464
01:15:25,554 --> 01:15:28,322
我们已经完成并继续前进。好的，这是可选的

1465
01:15:28,390 --> 01:15:32,493
链接。我把它做成可选的，没有双关语意

1466
01:15:32,561 --> 01:15:35,462
你可以在你目前的任务中阅读。

1467
01:15:35,531 --> 01:15:38,532
我建议你这样做，因为你可以做出非常漂亮的代码

1468
01:15:38,601 --> 01:15:41,835
使用可选的链接。这太好了。

1469
01:15:41,904 --> 01:15:46,273
好吧，我们今天要完成一点点评论

1470
01:15:46,342 --> 01:15:49,910
期待用来构建的数据结构

1471
01:15:49,979 --> 01:15:54,548
一个在Swift中的应用程序有这四个，类，

1472
01:15:54,616 --> 01:15:57,451
结构体，枚举和协议。协议是新的

1473
01:15:57,519 --> 01:16:01,055
我会在周三开始谈论。所以一个类，

1474
01:16:01,124 --> 01:16:04,458
正如我们所知，支持面向对象的设计。

1475
01:16:04,526 --> 01:16:07,060
它具有功能和数据的单一继承。

1476
01:16:07,129 --> 01:16:09,563
你继承了数据，你的变数。

1477
01:16:09,632 --> 01:16:13,667
存储变量得到继承，嗯，以及所有的方法

1478
01:16:13,736 --> 01:16:17,939
和东西。这是一个参考类型，生活在堆中。

1479
01:16:18,007 --> 01:16:20,073
但是，现在我们没有提到的一件事，

1480
01:16:20,142 --> 01:16:23,510
这个班住在堆里。什么时候清理干净

1481
01:16:23,579 --> 01:16:28,048
出了堆？那又如何呢？好的，所以

1482
01:16:28,117 --> 01:16:30,016
如果来自Java的人可能就是这样，

1483
01:16:30,085 --> 01:16:32,919
哦，垃圾收集也许？好吧，但是，不，好吧，

1484
01:16:32,988 --> 01:16:35,722
Swift不使用垃圾收集。

1485
01:16:35,791 --> 01:16:40,528
它使用了一个称为引用计数的非常棒的系统。和

1486
01:16:40,596 --> 01:16:42,329
实际上它是自动引用计数，

1487
01:16:42,397 --> 01:16:44,965
这一切都为你处理。那么如何引用计数

1488
01:16:45,034 --> 01:16:47,434
工作？好的，我们需要谈一谈

1489
01:16:47,503 --> 01:16:51,739
所以让我们在这里稍微绕行。顺便说一下，例子

1490
01:16:51,807 --> 01:16:54,809
我们已经看到的课程当然是UI视图控制器，

1491
01:16:54,877 --> 01:16:57,845
视图控制器，它是我们的子类，UI按钮，

1492
01:16:57,914 --> 01:17:00,614
用户界面的标签，浓度，我们做了一个类。那些

1493
01:17:00,682 --> 01:17:03,150
是所有的阶级，而不是结构，对吗？好的，让我们来

1494
01:17:03,219 --> 01:17:05,786
说说这个自动引用如何计数的东西

1495
01:17:05,854 --> 01:17:09,389
作品。这真的很简单，每一次，神奇的，

1496
01:17:09,458 --> 01:17:13,227
每次你创建一个指向引用类型的指针

1497
01:17:13,295 --> 01:17:17,665
堆，Swift在某处添加了一个计数器。和

1498
01:17:17,733 --> 01:17:22,035
每次指向它的指针超出范围或者

1499
01:17:22,104 --> 01:17:24,371
不再指向它，就像它是一个可选的，

1500
01:17:24,440 --> 01:17:26,072
它被设置为零，例如，

1501
01:17:26,141 --> 01:17:29,676
那么它减少了这个数字。当这个计数到0时，

1502
01:17:29,745 --> 01:17:32,580
它立即从堆中取出。这不是

1503
01:17:32,648 --> 01:17:34,614
它正在跟踪，它正在做任何标记和

1504
01:17:34,683 --> 01:17:37,250
扫地，像垃圾收集一样。它实际上

1505
01:17:37,319 --> 01:17:40,453
立即删除它，只要没有人指向它。所以

1506
01:17:40,522 --> 01:17:42,689
这不可能简单一些，这是你想象的确切方式，

1507
01:17:42,758 --> 01:17:44,291
从概念上讲，使其工作。

1508
01:17:44,360 --> 01:17:47,861
在封面下面实际上是相当困难的。

1509
01:17:47,930 --> 01:17:50,097
Swift从一开始就被设计了。

1510
01:17:50,165 --> 01:17:55,069
所以这是一个很棒的系统。你可以影响

1511
01:17:55,138 --> 01:17:57,104
这个自动引用计数一点。

1512
01:17:57,172 --> 01:17:59,807
你不能真正控制它，但你可以影响，

1513
01:17:59,875 --> 01:18:02,409
当你声明一个var时，用这三个关键词，

1514
01:18:02,477 --> 01:18:04,612
好吧，一个强大的，软弱的，无主的。

1515
01:18:04,680 --> 01:18:08,081
这些是你能做的三种有影响力的人。

1516
01:18:08,150 --> 01:18:11,151
第一个强，是正常的参考计数。

1517
01:18:11,220 --> 01:18:15,522
所以这只是说如果有一个，这个指针是强的，而且

1518
01:18:15,590 --> 01:18:19,025
所以只要把这件事留在堆里，

1519
01:18:19,094 --> 01:18:20,794
因为我需要它，我指着它。

1520
01:18:20,863 --> 01:18:21,795
这是默认的。

1521
01:18:21,864 --> 01:18:24,431
所以，我们从来没有真正输入关键字strong。

1522
01:18:24,500 --> 01:18:25,666
这是默认的。它总是在那里。

1523
01:18:25,735 --> 01:18:27,501
这就像访问控制的内部。

1524
01:18:27,569 --> 01:18:29,736
我们实际上并没有输入。

1525
01:18:29,805 --> 01:18:33,340
现在weak，你以前见过。你们都记得weak弱？

1526
01:18:33,409 --> 01:18:35,109
这是在outlet。好的，

1527
01:18:35,178 --> 01:18:37,510
当我们做出这个outlet的连接时，我说哦，

1528
01:18:37,579 --> 01:18:40,214
那看到那weak弱？下星期我会告诉你的。

1529
01:18:40,282 --> 01:18:43,017
那么，我正在履行我的诺言，我正在告诉你

1530
01:18:43,086 --> 01:18:47,121
弱。弱意味着什么？弱意味着我

1531
01:18:47,189 --> 01:18:50,690
指着这堆东西，但我只是真的

1532
01:18:50,759 --> 01:18:54,628
如果有人对此感兴趣，对此感兴趣。

1533
01:18:54,697 --> 01:18:57,697
换句话说，如果别人有strong强指针

1534
01:18:57,766 --> 01:19:00,534
它，保持在堆中。但是一旦没有其他人

1535
01:19:00,603 --> 01:19:01,802
对此感兴趣，换句话说

1536
01:19:01,871 --> 01:19:05,505
所有其他强大指针走开。把我设为零和

1537
01:19:05,574 --> 01:19:10,243
把东西从堆中扔出去。所以这不是

1538
01:19:10,312 --> 01:19:14,414
把这个东西放在我的账户类的指针上。

1539
01:19:14,483 --> 01:19:17,384
并注意，如果所有其他的强大，它将被设置为零

1540
01:19:17,453 --> 01:19:20,253
指针走开。那么这是什么类型的？

1541
01:19:20,322 --> 01:19:23,457
它必须是可选的。

1542
01:19:23,525 --> 01:19:28,362
所以这个弱点只适用于可选的指针

1543
01:19:28,430 --> 01:19:31,966
引用类型，好的，在堆中的东西，

1544
01:19:32,034 --> 01:19:34,901
我们的outlets是。如果你还记得我们的outlets，

1545
01:19:34,970 --> 01:19:38,839
像倒数计数标签是一个UI标签感叹号。那

1546
01:19:38,908 --> 01:19:41,875
是一个隐含的解包可选。这是一个可选的，

1547
01:19:41,944 --> 01:19:44,945
对？同样的东西卡按钮是一个隐含的解包

1548
01:19:45,014 --> 01:19:49,817
可选的。所以那些在UI中的东西的指针。

1549
01:19:49,885 --> 01:19:52,619
如果由于某些原因，这些东西离开了用户界面，好吧，

1550
01:19:52,688 --> 01:19:55,589
以某种方式从UI中删除，这是可能的，

1551
01:19:55,657 --> 01:19:59,660
但很少见。那么这些事情会被设置为零，好吗？

1552
01:19:59,728 --> 01:20:00,994
你不会再指向他们，

1553
01:20:01,063 --> 01:20:01,828
这就是他们想要的。

1554
01:20:01,897 --> 01:20:04,130
因为如果没有翻转计数标签

1555
01:20:04,199 --> 01:20:07,234
尝试更新它是没有用的。所以

1556
01:20:07,303 --> 01:20:10,170
这就是为什么他们让这些weak，现在weak，

1557
01:20:10,239 --> 01:20:12,772
只有几个地方，我们使用我们

1558
01:20:12,841 --> 01:20:15,842
常用。一个是outlets，另一个是delegation代理。

1559
01:20:15,911 --> 01:20:19,246
回想我的NBC谈话，我谈到了delegation，

1560
01:20:19,314 --> 01:20:21,815
data source数据源。从这个角度来看，我们有这些指针

1561
01:20:21,883 --> 01:20:23,950
回到那里的那个盲人和那个控制器

1562
01:20:24,019 --> 01:20:25,552
沟通的结构就是这样，

1563
01:20:25,621 --> 01:20:27,320
我将在周三讨论这个问题。

1564
01:20:27,389 --> 01:20:30,090
那些指针是弱weak的，因为这个视图，

1565
01:20:30,159 --> 01:20:32,959
如果他们发送的东西会做的

1566
01:20:33,028 --> 01:20:36,563
应该消失，好吧，他们不会发送这些

1567
01:20:36,632 --> 01:20:40,400
消息，所以他们想成为零，好吧。没有

1568
01:20:40,469 --> 01:20:43,970
一个发送他们的消息，然后他们只是想成为零，

1569
01:20:44,039 --> 01:20:45,872
好的。他们不想被指出什么。

1570
01:20:45,941 --> 01:20:48,475
他们当然不想要一个指向的东西，

1571
01:20:48,544 --> 01:20:50,543
因为它而陷入堆里。

1572
01:20:50,612 --> 01:20:53,179
因为他们很高兴只是不发送消息

1573
01:20:53,248 --> 01:20:55,882
那东西想要离开堆，否则我们不会

1574
01:20:55,951 --> 01:21:00,754
使用那么多弱。好的，最后是无主的。

1575
01:21:00,823 --> 01:21:03,223
无主是不算引用这个，

1576
01:21:03,292 --> 01:21:06,659
换句话说，我指的是堆中的东西，但是

1577
01:21:06,728 --> 01:21:10,163
不要把它作为一个强有力的指针。我保证我会的

1578
01:21:10,232 --> 01:21:14,668
当它从堆中消失时，从来不会访问这个东西。现在，

1579
01:21:14,737 --> 01:21:17,537
这是非常危险的，这基本上是在努力

1580
01:21:17,606 --> 01:21:20,474
智能自动参考计数系统。

1581
01:21:20,542 --> 01:21:23,877
你在说，你知道什么时候在堆中，还有

1582
01:21:23,946 --> 01:21:26,113
这是非常罕见的。而且，

1583
01:21:26,182 --> 01:21:30,584
有一次我们用这个是为了避免一个内存循环，好吧。

1584
01:21:30,653 --> 01:21:32,052
每个人都知道什么是内存周期，

1585
01:21:32,121 --> 01:21:33,854
那就是你在堆里有东西的地方

1586
01:21:33,922 --> 01:21:35,522
它指向堆中的其他东西，

1587
01:21:35,591 --> 01:21:36,657
那东西指向它。

1588
01:21:36,725 --> 01:21:39,159
所以，他们互相指着对方

1589
01:21:39,228 --> 01:21:41,728
堆。但是没有人对他们感兴趣。没有人

1590
01:21:41,797 --> 01:21:44,465
指向他们中的任何一个。他们只是指向对方。

1591
01:21:44,533 --> 01:21:46,533
所以他们无缘无故地坐在一堆。

1592
01:21:46,601 --> 01:21:49,769
没有人甚至访问他们，这是一个内存周期。和

1593
01:21:49,838 --> 01:21:53,540
内存周期通常不是通常在Swift中创建的

1594
01:21:53,609 --> 01:21:56,443
有一种方法可以很容易地创建

1595
01:21:56,511 --> 01:21:57,577
closures闭包，好的。

1596
01:21:57,646 --> 01:22:00,113
星期三我会谈谈这个功能，好吧。

1597
01:22:00,182 --> 01:22:05,285
所以我们将使用unowned无主的闭包。好吧，

1598
01:22:05,353 --> 01:22:07,821
回到我们这里的数据结构列表当然

1599
01:22:07,889 --> 01:22:10,590
有结构，我们知道所有关于这一点。这是一种价值类型，

1600
01:22:10,659 --> 01:22:12,893
它的副本拥有权利，没有数据的继承。

1601
01:22:12,962 --> 01:22:15,495
但是你要学习协议有继承

1602
01:22:15,564 --> 01:22:16,330
的功能，

1603
01:22:16,398 --> 01:22:19,432
实际上是多重继承的功能。而你已经

1604
01:22:19,501 --> 01:22:24,905
看到结构卡，字典，字符串，字符的例子，

1605
01:22:24,973 --> 01:22:29,476
int，double，UInt32，发生了很多结构

1606
01:22:29,545 --> 01:22:32,378
那里。而我在这里，让我们跳到集中

1607
01:22:32,447 --> 01:22:35,315
看看结构集中时会发生什么。

1608
01:22:35,384 --> 01:22:37,017
我从下一个开始，因为我们差不多

1609
01:22:37,018 --> 01:22:38,651
怎么样

1610
01:22:38,721 --> 01:22:41,121
在这里没有时间Enum，我不打算，

1611
01:22:41,189 --> 01:22:44,624
哦，是的，这是演示，我将在下一次做。和

1612
01:22:44,693 --> 01:22:47,794
那么在这里我们已经覆盖了，所以我不打算

1613
01:22:47,863 --> 01:22:51,497
谈谈它，另一种价值类型，离散值。它也是

1614
01:22:51,566 --> 01:22:55,702
可以继承同一种功能的继承。

1615
01:22:55,771 --> 01:22:59,172
这种功能的继承，我保持提及

1616
01:22:59,241 --> 01:23:02,342
是使用这最后一个，这就是所谓的协议。

1617
01:23:02,411 --> 01:23:04,845
所以我会在周三开始详细的

1618
01:23:04,913 --> 01:23:06,613
协议是什么的解释。

1619
01:23:06,682 --> 01:23:10,016
这是所有基础设计的基础，

1620
01:23:10,085 --> 01:23:12,819
所有的数组，字典，字符串，int。

1621
01:23:12,888 --> 01:23:15,522
而所有这些东西从根本上使用协议

1622
01:23:15,591 --> 01:23:17,758
到处都是大量的协议。

1623
01:23:17,826 --> 01:23:20,093
这也是代表团和其他事情的根本

1624
01:23:20,162 --> 01:23:22,796
这样的东西，所以这是非常非常重要的。并圆

1625
01:23:22,865 --> 01:23:26,332
我们完全理解如何构建数据结构

1626
01:23:26,401 --> 01:23:30,436
在Swift中。好吧，我们将在星期三开始

1627
01:23:30,505 --> 01:23:32,739
我们稍后见。 >>更多信息，

1628
01:23:32,808 --> 01:23:41,314
请访问stanford.edu。

