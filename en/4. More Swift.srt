1
00:00:00,401 --> 00:00:04,736
[MUSIC]                         

2
00:00:04,804 --> 00:00:08,840
Stanford University.            
>> All right,                   

3
00:00:08,909 --> 00:00:11,743
well, welcome to                
Lecture number four?            

4
00:00:11,812 --> 00:00:15,180
No. Yes, four of                
Stanford CS193P, Fall of 2017.  

5
00:00:15,249 --> 00:00:18,583
Today, we're gonna continue     
to talk about Swift.            

6
00:00:18,652 --> 00:00:21,019
This will be the last we talk   
about Swift. After this,        

7
00:00:21,088 --> 00:00:23,655
we're pretty much gonna         
kinda assume you know Swift.    

8
00:00:23,724 --> 00:00:26,491
Obviously you'll be learning    
on the fly as you go, but       

9
00:00:26,560 --> 00:00:27,592
starting next week,             

10
00:00:27,661 --> 00:00:29,861
we're gonna dive right          
into iOS, UI kit and            

11
00:00:29,930 --> 00:00:33,198
all that. So I'm gonna do the   
quick demo that I postponed     

12
00:00:33,267 --> 00:00:36,968
from Wednesday of this          
mutating keyword that we have   

13
00:00:37,037 --> 00:00:39,771
to add when we make something   
a struct versus a class. Then   

14
00:00:39,840 --> 00:00:43,274
we're gonna talk about two      
very important topics today.    

15
00:00:43,343 --> 00:00:45,910
Protocols and closures.         

16
00:00:45,979 --> 00:00:48,647
Functions as types of general   
those two and in between, I'm   

17
00:00:48,715 --> 00:00:52,384
gonna talk about string which   
is important in a way but       

18
00:00:52,452 --> 00:00:55,553
it's not like the monstrous     
important topics like           

19
00:00:55,622 --> 00:01:00,859
prototypes and closures are.    
So start right into that demo   

20
00:01:00,928 --> 00:01:05,096
that I had. And remember, we    
were talking at the time about  

21
00:01:05,165 --> 00:01:09,400
making things a struct and      
that it's a little different    

22
00:01:09,469 --> 00:01:13,172
then a class because that copy  
on write. Swift needs to know   

23
00:01:13,240 --> 00:01:15,674
when a function might           
actually modify the thing so    

24
00:01:15,743 --> 00:01:18,576
that it knows to actually       
make a real copy. So            

25
00:01:18,645 --> 00:01:22,147
let's go back here to our app,  
Concentration, where we were.   

26
00:01:22,216 --> 00:01:26,751
Let's go to Concentration,      
which if you recall,            

27
00:01:26,820 --> 00:01:30,422
we made be a class.             
A class Concentration. And      

28
00:01:30,491 --> 00:01:32,857
this could have just as         
easily been a struct.           

29
00:01:32,926 --> 00:01:35,326
I really made it a class        
just so when we're doing        

30
00:01:35,395 --> 00:01:37,428
the initialize and stuff,       
you could see the difference    

31
00:01:37,497 --> 00:01:40,331
between Concentration and card  
because card was a struct and   

32
00:01:40,400 --> 00:01:42,267
Concentration was a class.      
But there's                     

33
00:01:42,336 --> 00:01:44,136
no reason Concentration         
wouldn't have been a struct.    

34
00:01:44,204 --> 00:01:47,572
It's probably, it might even    
be better as a struct here.     

35
00:01:47,641 --> 00:01:51,376
Now we don't pass               
Concentration games around and  

36
00:01:51,445 --> 00:01:55,113
all that, it just kinda         
sits in our controller.         

37
00:01:55,182 --> 00:01:58,716
Not really a pointer to our     
model but this would embed      

38
00:01:58,785 --> 00:02:01,320
the model there. So it doesn't  
really matter too much.         

39
00:02:01,388 --> 00:02:06,124
But when I change this from     
class to struct, notice here    

40
00:02:06,193 --> 00:02:09,194
that I get an error. And let's  
scroll down and here they are,  

41
00:02:09,263 --> 00:02:11,363
here's the error and            
this error is saying,           

42
00:02:11,431 --> 00:02:15,533
cannot assign to property,      
self is immutable. Why is this  

43
00:02:15,602 --> 00:02:18,970
saying self is immutable? I'm   
trying to change the card here  

44
00:02:19,039 --> 00:02:21,273
to say that they've match,      
for example.                    

45
00:02:21,342 --> 00:02:24,442
Well, self is immutable         
because this function right     

46
00:02:24,511 --> 00:02:29,514
is not marked mutable, and so   
it is assumed to not mutate,    

47
00:02:29,583 --> 00:02:34,152
not change this                 
Concentration object. So        

48
00:02:34,220 --> 00:02:37,722
of course we need chooseCard    
to change the Concentration     

49
00:02:37,791 --> 00:02:40,325
object cuz it's the main        
thing. The change of the game,  

50
00:02:40,394 --> 00:02:43,795
so all we need to do is add     
mutable right here, that        

51
00:02:43,864 --> 00:02:47,932
marks, sorry, mutating, not     
mutable, you add that here and  

52
00:02:48,001 --> 00:02:51,470
that says that this is          
a mutating function,            

53
00:02:51,538 --> 00:02:54,372
all the errors go away,         
and we're all good to go.       

54
00:02:54,441 --> 00:02:59,544
Question?                       
>> [INAUDIBLE]                  

55
00:02:59,613 --> 00:03:00,479
>> Okay, the question is why    

56
00:03:00,547 --> 00:03:01,680
does this not need it?          

57
00:03:01,749 --> 00:03:05,784
This is a var. And              
this var is get and set, so     

58
00:03:05,852 --> 00:03:10,121
Swift already knows this is     
mutating, cuz it's settable.    

59
00:03:10,190 --> 00:03:12,357
If this was get only, then      
it wouldn't be mutating and     

60
00:03:12,426 --> 00:03:16,028
Swift would know that.          
So for vars, Swift knows. And   

61
00:03:16,096 --> 00:03:19,264
if it's not a computed var,     
like look at this var,          

62
00:03:19,332 --> 00:03:22,701
how does this one know? That's  
because, well, this one is      

63
00:03:22,770 --> 00:03:26,871
read only externally but        
for us it's writable. Here,     

64
00:03:26,940 --> 00:03:29,641
anything that's a var it        
assumed it's writable. If it    

65
00:03:29,709 --> 00:03:34,846
were a let, a let, then it      
would think it's not writable.  

66
00:03:34,914 --> 00:03:39,450
So that's how you do mutating,  
or mutable. If for vars is      

67
00:03:39,519 --> 00:03:42,620
whether they're vars or let,    
or for computer property,       

68
00:03:42,689 --> 00:03:47,192
whether it has both get and     
set. Where we got all that? So  

69
00:03:47,260 --> 00:03:49,060
it's only funcs that we         
have to put that on.            

70
00:03:49,129 --> 00:03:52,297
Yeah, question.                 
>> [INAUDIBLE]                  

71
00:03:52,366 --> 00:03:52,931
>> Yes, so the question is,     

72
00:03:52,999 --> 00:03:55,733
why is this you need to a       
struct and not a class, why do  

73
00:03:55,802 --> 00:03:58,002
I need to struct? And that's    
very important to understand,   

74
00:03:58,071 --> 00:04:02,974
very good question. Structs     
are value types, not reference  

75
00:04:03,043 --> 00:04:05,844
types. So structs don't live    
in the heap. As we pass         

76
00:04:05,913 --> 00:04:09,013
the struct around since it's    
a value type, it gets copied.   

77
00:04:09,082 --> 00:04:11,649
Constantly copied everywhere.   
Pass through a function,        

78
00:04:11,718 --> 00:04:14,486
a copy is made. Put in a var,   
a copy is made. Well,           

79
00:04:14,554 --> 00:04:17,222
soon, that would be incredibly  
inefficient if it actually      

80
00:04:17,291 --> 00:04:21,159
copy the bits of this entire    
thing every time. So instead,   

81
00:04:21,228 --> 00:04:24,028
Swift is smart. It only         
actually copies the bits when   

82
00:04:24,097 --> 00:04:27,799
you mutate it. That's called    
copy-on-write semantics.        

83
00:04:27,867 --> 00:04:29,434
This is why structs             
are different,                  

84
00:04:29,503 --> 00:04:31,903
because they have that          
copy-on-write semantics.        

85
00:04:31,972 --> 00:04:35,106
A class doesn't have that, cuz  
when you pass a class around,   

86
00:04:35,175 --> 00:04:37,075
the class just lives            
once in the heap,               

87
00:04:37,144 --> 00:04:38,810
and you're passing              
pointers to it around.          

88
00:04:38,878 --> 00:04:41,213
And there could be 20           
pointers to the same object.    

89
00:04:41,281 --> 00:04:44,683
Totally different kinda model   
for memory. So that's why,      

90
00:04:44,751 --> 00:04:48,719
it's because it's a value type  
that copy on writes stuff,      

91
00:04:48,788 --> 00:04:51,523
that's why we care              
that it's mutating.             

92
00:04:51,592 --> 00:04:56,828
Let's go back to our slides     
and talk about the first very,  

93
00:04:56,897 --> 00:05:01,900
very important topic            
today which is protocols.       

94
00:05:01,968 --> 00:05:05,737
It's the fourth pillar of       
building data structures        

95
00:05:05,805 --> 00:05:09,307
inside of Swift. You already    
know a lot now about class,     

96
00:05:09,375 --> 00:05:14,679
struct and enum. And            
a protocol is something where   

97
00:05:14,748 --> 00:05:18,382
its a very simple concept.      
A protocol is basically just    

98
00:05:18,451 --> 00:05:21,453
a list of methods and vars      
with no implementation. But     

99
00:05:21,522 --> 00:05:23,722
it's the use of having          
protocols. It's so              

100
00:05:23,790 --> 00:05:27,025
pervasively used throughout     
the Swift language and          

101
00:05:27,093 --> 00:05:30,529
the runtime that makes it so    
powerful. So first I'm just     

102
00:05:30,597 --> 00:05:32,664
gonna go through a little bit   
of why we have protocols.       

103
00:05:32,733 --> 00:05:35,133
Then I'll show you              
the syntax of protocols.        

104
00:05:35,201 --> 00:05:37,635
What it looks like to type in   
a protocol and define one.      

105
00:05:37,704 --> 00:05:40,005
Then we'll start talking        
about the use of protocols.     

106
00:05:40,073 --> 00:05:43,674
Where do we use them?           
Why are they so valuable? So    

107
00:05:43,743 --> 00:05:47,178
let's start with,               
what protocols are all about?   

108
00:05:47,247 --> 00:05:51,616
Protocols are essentially       
a way for                       

109
00:05:51,685 --> 00:05:55,219
callers to call an API          
with anything they want.        

110
00:05:55,288 --> 00:05:57,122
Any struct, enum, class,        

111
00:05:57,190 --> 00:06:00,391
it can pass anything they       
want in. And at the same time   

112
00:06:00,460 --> 00:06:04,596
the receiving method can        
specify what it really wants.   

113
00:06:04,665 --> 00:06:08,132
So both sides get to do what    
they want. The receiving thing  

114
00:06:08,201 --> 00:06:10,868
gets to say what it wants       
the thing you're passing and    

115
00:06:10,937 --> 00:06:13,772
to do and the thing passing in  
can pass whatever it wants as   

116
00:06:13,840 --> 00:06:17,409
long as it does that thing.     
And to do all this all          

117
00:06:17,478 --> 00:06:22,380
a protocol is, is a list        
of vars and functions.          

118
00:06:22,449 --> 00:06:24,649
That's all a protocol is.       
It's just a list of them.       

119
00:06:24,718 --> 00:06:27,251
Not an implementation or        
anything, just a list of them.  

120
00:06:27,320 --> 00:06:30,622
And it's how we use them in     
the API that let's us get this  

121
00:06:30,691 --> 00:06:33,558
behavior of having              
the callers and the callees.    

122
00:06:33,626 --> 00:06:37,028
Get to express things           
the way they want. Now, what    

123
00:06:37,096 --> 00:06:40,532
are protocols good for? They    
make APIs very flexible and     

124
00:06:40,600 --> 00:06:42,500
expressive, as                  
you're going to see.            

125
00:06:42,569 --> 00:06:45,870
They're super good for blind    
structured communication.       

126
00:06:45,939 --> 00:06:48,439
Like, remember back             
to my MVC talk.                 

127
00:06:48,508 --> 00:06:50,542
The communication between       
the view and the controller.    

128
00:06:50,611 --> 00:06:54,011
All those will, did, shoulds.   
And the data at count,          

129
00:06:54,080 --> 00:06:56,982
those kind of communications    
between a view controller.      

130
00:06:57,050 --> 00:06:59,784
That all had to be blind,       
because the views are generic   

131
00:06:59,853 --> 00:07:03,721
and the controllers are very    
specific, and protocols is how  

132
00:07:03,790 --> 00:07:07,792
we make that work. It's also    
great for mandating behavior,   

133
00:07:07,861 --> 00:07:11,529
for example, in a dictionary,   
a dictionary's a hash table,    

134
00:07:11,597 --> 00:07:15,032
raise your hand if you know     
what a hash table is when I     

135
00:07:15,101 --> 00:07:19,037
say that. Okay, everybody.      
Good. So it's a hash table.     

136
00:07:19,105 --> 00:07:22,407
So the keys of a dictionary     
clearly have to be hashable.    

137
00:07:22,476 --> 00:07:25,509
You have to be able to get a    
hash value otherwise you can't  

138
00:07:25,578 --> 00:07:28,580
hash them and put them in       
as keys of this hash table.     

139
00:07:28,649 --> 00:07:31,983
Well, protocols let us define   
dictionary in a way so          

140
00:07:32,052 --> 00:07:35,319
that we don't use any keys      
that aren't hashable.           

141
00:07:35,388 --> 00:07:38,056
So mandating behavior           
passibility, for example,       

142
00:07:38,125 --> 00:07:40,992
of the key it's great for       
that. It's also great for       

143
00:07:41,061 --> 00:07:43,994
sharing functionality           
between very disparate types,   

144
00:07:44,063 --> 00:07:47,064
types that you would never use  
object oriented inheritance to  

145
00:07:47,133 --> 00:07:50,501
make them share a base class,   
but they are very similar, for  

146
00:07:50,570 --> 00:07:54,472
example, string, array,         
countable range. They are all   

147
00:07:54,540 --> 00:07:57,475
collections of things. Now      
they're completely different.   

148
00:07:57,544 --> 00:07:58,943
Come one,                       
a countable range and           

149
00:07:59,012 --> 00:08:01,446
a string are completely         
different. But they are both    

150
00:08:01,515 --> 00:08:04,182
collections, a string is        
a collection of characters,     

151
00:08:04,251 --> 00:08:06,584
accountable range is a          
collection of integers if it's  

152
00:08:06,653 --> 00:08:09,487
an accountable range of int.    
So they do share some and       

153
00:08:09,555 --> 00:08:12,624
protocols has a mechanism to    
allow you to share that kind    

154
00:08:12,693 --> 00:08:15,426
of similarity without having    
to have all those thing         

155
00:08:15,495 --> 00:08:18,763
inherit from some kind common   
base class that knows about     

156
00:08:18,832 --> 00:08:21,666
collections of things. You      
see what I'm saying? And so     

157
00:08:21,735 --> 00:08:25,536
in a way, protocols provide     
multiple inheritance. Now,      

158
00:08:25,605 --> 00:08:28,873
since protocols are only doing  
the declaration of the vars     

159
00:08:28,942 --> 00:08:32,277
and functions, there's no       
storage of, of those things,    

160
00:08:32,345 --> 00:08:34,378
so there's no                   
inheritance of data,            

161
00:08:34,447 --> 00:08:36,447
it's purely just                
inheritance of,                 

162
00:08:36,516 --> 00:08:41,152
inheritance of functionality.   
All right, as I go              

163
00:08:41,221 --> 00:08:43,688
through this explanation, it's  
super important to understand   

164
00:08:43,757 --> 00:08:47,258
that protocols are just         
a type. Just like a class is    

165
00:08:47,327 --> 00:08:50,194
a type, a struct, an enum,      
a protocol is a type.           

166
00:08:50,263 --> 00:08:52,730
A first-class type, just like   
all the rest of these types,    

167
00:08:52,799 --> 00:08:54,398
that's very important           
to understand.                  

168
00:08:54,467 --> 00:08:58,103
All right, so let's dive        
into what a protocol is.        

169
00:08:58,171 --> 00:08:59,804
There's three parts             
to a protocol.                  

170
00:08:59,873 --> 00:09:02,974
One, there's the declaration    
of the protocol, just like you  

171
00:09:03,043 --> 00:09:05,443
have a declaration of a class   
or an enum or a struct. For     

172
00:09:05,511 --> 00:09:07,245
a protocol,                     
that's just a list of           

173
00:09:07,313 --> 00:09:09,781
methods with their arguments    
and return values and           

174
00:09:09,850 --> 00:09:13,284
a list of vars. That's it,      
that's what a protocol is,      

175
00:09:13,353 --> 00:09:16,620
it's a declaration. Second      
part of a protocol though       

176
00:09:16,689 --> 00:09:21,259
is a class or a struct or       
an enum raises its hand and     

177
00:09:21,327 --> 00:09:24,628
claims to implement those       
methods in vars in that         

178
00:09:24,697 --> 00:09:27,832
protocol. So there's the claim  
to implement a protocol,        

179
00:09:27,901 --> 00:09:30,701
that's the second part.         
Cuz somebody has to actually    

180
00:09:30,770 --> 00:09:33,437
implement those methods that    
the protocol is a list of, and  

181
00:09:33,506 --> 00:09:36,274
that's classes, structs and     
enums, so they have to claim.   

182
00:09:36,343 --> 00:09:39,377
And then the third part is      
the code in those classes,      

183
00:09:39,446 --> 00:09:42,246
structs and in in enums         
that actually implements        

184
00:09:42,315 --> 00:09:45,115
the protocol methods in vars.   
Okay, so                        

185
00:09:45,184 --> 00:09:47,852
notice I'm mentioning vars.     
The vars,                       

186
00:09:47,921 --> 00:09:51,289
the storage of the vars,        
if they're not computed vars,   

187
00:09:51,358 --> 00:09:54,592
has to be in some struct,       
enum or a class. Because,       

188
00:09:54,661 --> 00:09:58,596
that's the only places you can  
have any storage, all right?    

189
00:09:58,665 --> 00:10:00,364
Okay, so that's it, those are   
the three parts of a protocol.  

190
00:10:00,433 --> 00:10:03,401
Now I'm gonna take              
a little aside, and             

191
00:10:03,470 --> 00:10:07,037
not even gonna spend too        
much time on this, but          

192
00:10:07,106 --> 00:10:11,209
all the methods and vars in     
a protocol are mandatory.       

193
00:10:11,278 --> 00:10:12,810
If you're wanna                 
raise your hand and             

194
00:10:12,879 --> 00:10:14,378
say, I implement                
this protocol.                  

195
00:10:14,447 --> 00:10:18,015
If you're a struct or enum or   
a class, you have to implement  

196
00:10:18,084 --> 00:10:22,187
all of the methods and all      
the vars in Swift. However,     

197
00:10:22,255 --> 00:10:27,024
in Objective-C, that was        
not true. In Objective-C,       

198
00:10:27,093 --> 00:10:31,762
protocols could have            
optional methods. Methods or    

199
00:10:31,831 --> 00:10:34,432
vars in the protocol that you   
could choose to implement or    

200
00:10:34,500 --> 00:10:38,970
not. Now, that's quite a big    
difference and the way Swift    

201
00:10:39,039 --> 00:10:42,306
deals with that is it allows    
you to put @objc, in front of   

202
00:10:42,375 --> 00:10:45,276
you declaration of a protocol   
to make it so that this         

203
00:10:45,344 --> 00:10:48,746
is an Objective-C protocol      
instead of a switch protocol.   

204
00:10:48,815 --> 00:10:51,216
And the only difference         
is that now,                    

205
00:10:51,284 --> 00:10:54,252
methods inside of your          
protocol can be marked          

206
00:10:54,321 --> 00:10:57,088
optional. Not optional like     
you know question mark,         

207
00:10:57,157 --> 00:10:59,057
exclamation point,              
that kind of optional enum.     

208
00:10:59,125 --> 00:11:01,292
I'm talking about optional      
like you can optionally         

209
00:11:01,361 --> 00:11:03,728
implement the method but you    
don't have to implement if you  

210
00:11:03,797 --> 00:11:07,498
don't want to. Okay, so that's  
a special kind of backwards     

211
00:11:07,567 --> 00:11:09,533
compatibility mode              
to Objective-C, but             

212
00:11:09,602 --> 00:11:12,470
in Swift, we don't do that. So  
the only time we're ever gonna  

213
00:11:12,538 --> 00:11:15,673
have this going on in this      
class is when we're using iOS   

214
00:11:15,742 --> 00:11:18,642
API that was designed back      
in the Objective-C world.       

215
00:11:18,711 --> 00:11:21,111
Specifically, delegation,       

216
00:11:21,180 --> 00:11:24,348
which is that blind view to     
controller communication.       

217
00:11:24,417 --> 00:11:29,086
That is all Objective-C         
style protocols and so          

218
00:11:29,155 --> 00:11:32,423
when you start using that down  
the road in the coming weeks,   

219
00:11:32,492 --> 00:11:34,191
you're gonna see these          
protocols that are marked       

220
00:11:34,260 --> 00:11:36,694
Objective-C and some of         
them are marked optional        

221
00:11:36,763 --> 00:11:38,429
that you don't have to          
implement a method.             

222
00:11:38,497 --> 00:11:42,366
That's not Swift. That's        
Objective-C compatibility.      

223
00:11:42,435 --> 00:11:44,502
So just put that in             
the back of your brain so       

224
00:11:44,571 --> 00:11:46,570
that when you see it, you're    
like, whoa. I thought I had to  

225
00:11:46,639 --> 00:11:48,973
implement all the methods in    
your protocol. Yes, you do in   

226
00:11:49,042 --> 00:11:54,211
Swift. Only this exception,     
all right, back to protocols.   

227
00:11:54,280 --> 00:11:57,682
Okay, so how do we declare a    
protocol? What does the syntax  

228
00:11:57,750 --> 00:12:00,851
look like? Well, it looks       
a lot like declaring a class.   

229
00:12:00,920 --> 00:12:05,022
Protocol, SomeProtocol,         
SomeProtocol is the name        

230
00:12:05,091 --> 00:12:07,858
of that protocol just like      
if you say at class whatever    

231
00:12:07,927 --> 00:12:09,627
that would be the name          
of the class.                   

232
00:12:09,695 --> 00:12:12,897
Notice that there's also        
colon, InheritedProtocol1,      

233
00:12:12,966 --> 00:12:16,667
InheritedProtocol2 actually it  
can be any number of these.     

234
00:12:16,736 --> 00:12:22,273
These are the other protocols   
that SomeProtocol inherits.     

235
00:12:22,342 --> 00:12:25,276
Okay, so there is inheritance   
in protocols. It means          

236
00:12:25,344 --> 00:12:28,346
a little bit different          
thing then in a class.          

237
00:12:28,415 --> 00:12:30,782
Okay, inheritance in            
the protocol world means,       

238
00:12:30,850 --> 00:12:34,219
if you wanna claim to           
implement some protocol. You    

239
00:12:34,287 --> 00:12:37,355
also have have to implement     
InheritedProtocol1 and          

240
00:12:37,423 --> 00:12:41,759
InheritedProtocol2. So it's     
almost like it's a mandatory    

241
00:12:41,827 --> 00:12:44,629
additional protocols you must   
implement if you wanna say      

242
00:12:44,697 --> 00:12:47,398
you implement this protocol.    
We call that protocol           

243
00:12:47,467 --> 00:12:52,270
inheritance. We call it that    
because some protocol inherits  

244
00:12:52,338 --> 00:12:57,842
the requirement to implement    
these other protocols. Now,     

245
00:12:57,911 --> 00:13:01,712
once you go inside              
the definition of protocol,     

246
00:13:01,781 --> 00:13:05,483
you can see there's no code.    
Protocols have no code,         

247
00:13:05,552 --> 00:13:06,884
they are not implementations,   

248
00:13:06,953 --> 00:13:10,854
they are purely declarations.   
And, in fact, when you declare  

249
00:13:10,923 --> 00:13:13,925
that you're gonna have a var    
be part of your protocol,       

250
00:13:13,994 --> 00:13:16,894
all you get to say is           
whether it's a read-only var,   

251
00:13:16,962 --> 00:13:18,296
which would be get or           

252
00:13:18,364 --> 00:13:20,865
a read-and-write var            
with get set like this.         

253
00:13:20,934 --> 00:13:24,435
So this one right here some     
property would be get and set.  

254
00:13:24,504 --> 00:13:27,104
So if you wanna implement       
this protocol, your class or    

255
00:13:27,173 --> 00:13:29,640
struct and you wanna implement  
this, you would have to have    

256
00:13:29,709 --> 00:13:36,013
a var that can be get and set.  
Okay, that's what that means.   

257
00:13:36,082 --> 00:13:39,283
Any methods that you            
have in your protocol           

258
00:13:39,352 --> 00:13:43,321
that might be implemented by a  
struct and modified the thing   

259
00:13:43,389 --> 00:13:46,791
have to be marked mutating      
of course, right?               

260
00:13:46,860 --> 00:13:50,361
Because again Swift             
needs to know oh                

261
00:13:50,430 --> 00:13:53,264
this method might change        
the thing that implements it.   

262
00:13:53,332 --> 00:13:56,534
Now there's a little trick      
if you want, if you know        

263
00:13:56,602 --> 00:13:59,436
this protocol's never gonna     
be implemented by a struct,     

264
00:13:59,505 --> 00:14:02,339
then you don't need the         
mutating. But you have to mark  

265
00:14:02,408 --> 00:14:06,143
the protocol to say this is     
a class only protocol. You do   

266
00:14:06,212 --> 00:14:09,914
that by saying colon class as   
the first thing right after     

267
00:14:09,982 --> 00:14:13,251
the protocol declaration.       
You see how I put that yellow   

268
00:14:13,319 --> 00:14:16,253
colon class up there? Okay,     
so then if you did that then    

269
00:14:16,322 --> 00:14:18,456
you would not have to put the   
mutating because of course,     

270
00:14:18,525 --> 00:14:20,224
you never have to put           
mutating in a class, but        

271
00:14:20,292 --> 00:14:22,426
then this protocol could not    
be implemented by a struct.     

272
00:14:22,495 --> 00:14:25,829
It could only be implemented    
by a class, we rarely do this.  

273
00:14:25,898 --> 00:14:28,732
Okay we don't usually make      
a protocol, be restricted to    

274
00:14:28,801 --> 00:14:31,435
a class and in fact 99% of all  
the protocols you're gonna see  

275
00:14:31,504 --> 00:14:36,207
in iOS could be implemented     
by anybody. Okay,               

276
00:14:36,276 --> 00:14:40,544
what else we got here. Yes,     

277
00:14:40,613 --> 00:14:44,748
you can an even add an init to  
your protocol. And that means   

278
00:14:44,817 --> 00:14:47,551
if you're a class or a struct   
that implements this protocol,  

279
00:14:47,620 --> 00:14:49,086
you have to                     
implement this init.            

280
00:14:49,155 --> 00:14:53,056
So, I have to be able to        
initialize you. So, that        

281
00:14:53,125 --> 00:14:57,194
was how we declare a protocol,  
now let's look how a class or   

282
00:14:57,263 --> 00:15:00,965
a struct says, raises his       
hand and says yes, I will       

283
00:15:01,033 --> 00:15:03,968
implement this protocol. All    
it does is in a class after     

284
00:15:04,036 --> 00:15:07,505
the superclass, you just say    
comma all the protocols you     

285
00:15:07,574 --> 00:15:12,243
claim to implement. It's as     
simple as that, of course, for  

286
00:15:12,312 --> 00:15:15,279
a struct there is               
no superclass, so               

287
00:15:15,347 --> 00:15:19,717
you would just say enum or      
struct, whatever, colon         

288
00:15:19,786 --> 00:15:24,055
the protocols you implement.    
Okay, so that's how you claim.  

289
00:15:24,123 --> 00:15:26,657
This is you raising your hand   
and say I implement that.       

290
00:15:26,726 --> 00:15:28,759
As soon as you say that the     
source compiler is gonna check  

291
00:15:28,828 --> 00:15:30,961
to make sure you actually       
implement those methods and     

292
00:15:31,030 --> 00:15:33,397
vars in that protocol. And if   
you don't, you're going to get  

293
00:15:33,466 --> 00:15:36,734
errors. It's gonna say you do   
not implement this on protocol  

294
00:15:36,803 --> 00:15:41,338
method whatever. And you're     
have to go do that, all right?  

295
00:15:41,407 --> 00:15:43,240
You can do any number of        
protocols that you want.        

296
00:15:43,309 --> 00:15:46,310
That's sometimes why we say     
that protocols can provide      

297
00:15:46,379 --> 00:15:48,546
multiple inheritance because    
you can have as many of these   

298
00:15:48,615 --> 00:15:51,616
ah, as you want going on        
there. Ah, by the way,          

299
00:15:51,685 --> 00:15:53,551
if there is an init             
in the protocol and             

300
00:15:53,620 --> 00:15:56,487
you're a class and you say,     
implement that protocol,        

301
00:15:56,555 --> 00:15:59,623
you have to mark there,         
your init required.             

302
00:15:59,692 --> 00:16:01,859
That's because you wouldn't     
want a subclass to come along.  

303
00:16:01,927 --> 00:16:05,696
Subclass you, subclass that     
init away which is possible.    

304
00:16:05,765 --> 00:16:07,131
It's possible to subclass and   
make it so                      

305
00:16:07,199 --> 00:16:09,867
an init doesn't work anymore    
from your superclass.           

306
00:16:09,936 --> 00:16:11,935
You don't want to allow         
subclasses to do that because   

307
00:16:12,004 --> 00:16:14,972
then a subclass would no        
longer implement this protocol  

308
00:16:15,041 --> 00:16:17,374
and yet people might think it   
does because it inherits from   

309
00:16:17,443 --> 00:16:21,445
something that does. So, once   
a class implements protocol,    

310
00:16:21,514 --> 00:16:24,248
all it's subclasses have to as  
well, so all init would have    

311
00:16:24,317 --> 00:16:26,684
to be required.                 
Cuz init kind of special,       

312
00:16:26,753 --> 00:16:28,719
in that it's possible in        
your subclass, to make it so    

313
00:16:28,788 --> 00:16:30,921
you no longer implement         
a certain init with certain     

314
00:16:30,990 --> 00:16:35,393
arguments. By the way, in your  
reading, there's a whole bunch  

315
00:16:35,461 --> 00:16:39,229
about making inits in classes.  
It's probably                   

316
00:16:39,298 --> 00:16:42,266
the most complicated long part  
of your reading for this week.  

317
00:16:42,334 --> 00:16:46,303
You gonna have to fight         
through it cuz it's pretty      

318
00:16:46,372 --> 00:16:49,607
complicated. Inheritance        
makes initialization really     

319
00:16:49,676 --> 00:16:51,809
difficult because you've got    
your own vars, you've got your  

320
00:16:51,877 --> 00:16:54,511
superclasses vars. You've got   
to get things initialized       

321
00:16:54,580 --> 00:16:57,882
in the right order, all that,   
it's quite complicated.         

322
00:16:57,950 --> 00:17:00,584
So, unfortunately one of the    
things the day you subclass     

323
00:17:00,653 --> 00:17:03,086
can make it so you don't have   
to form an init anymore.        

324
00:17:03,155 --> 00:17:09,060
So that's why you have to       
mark it required. One thing     

325
00:17:09,128 --> 00:17:13,097
is you don't have to add your   
conformance to a protocol.      

326
00:17:13,166 --> 00:17:14,865
You don't have to add           
all the methods, and            

327
00:17:14,934 --> 00:17:17,968
vars in that protocol. In your  
actual class declaration, or    

328
00:17:18,037 --> 00:17:20,671
your struct declaration you     
can add it with an extension,   

329
00:17:20,740 --> 00:17:23,073
you know how we can extend      
Int to add arc4random.          

330
00:17:23,142 --> 00:17:27,144
Well we could extend Int to     
conform to some protocol.       

331
00:17:27,212 --> 00:17:29,013
Okay, that would                
be perfectly fine.              

332
00:17:29,081 --> 00:17:31,682
We would just say               
extension Int :,                

333
00:17:31,751 --> 00:17:35,653
the protocol we wanted int to   
implement and then in there,    

334
00:17:35,721 --> 00:17:39,556
and the extension we would put  
all the implementations of      

335
00:17:39,625 --> 00:17:42,926
the vars and                    
methods in that protocol. And   

336
00:17:42,995 --> 00:17:46,163
this is actually quite common   
to use in extension just for    

337
00:17:46,232 --> 00:17:49,700
code book keeping. Well some    
use an extension to implement   

338
00:17:49,769 --> 00:17:53,304
a whole protocol. It's just     
nice groups it all nicely.      

339
00:17:54,740 --> 00:17:57,441
Okay, let's see an example      
of using protocols like         

340
00:17:57,510 --> 00:18:01,045
the type they are.              
Okay, protocols are types. So   

341
00:18:01,113 --> 00:18:04,114
let's see, here I have          
a protocol called Moveable.     

342
00:18:04,183 --> 00:18:08,018
It has one method in it         
called, move to, all right?     

343
00:18:08,087 --> 00:18:11,188
And I've created a class        
called Car, which can be moved  

344
00:18:11,257 --> 00:18:14,024
and another class called        
Shape, like triangle or         

345
00:18:14,093 --> 00:18:16,694
square, which can also          
be moved. Now a Car and         

346
00:18:16,763 --> 00:18:20,263
a Shape, incredibly different   
things and one is class and     

347
00:18:20,332 --> 00:18:24,335
one is struct but both of them  
implement this same protocol.   

348
00:18:24,404 --> 00:18:26,070
Okay, we're gonna see what      
it looks like in the code,      

349
00:18:26,139 --> 00:18:27,738
when you have this              
kind of situation,              

350
00:18:27,806 --> 00:18:29,940
which it's perfectly            
legal to do this. And so        

351
00:18:30,008 --> 00:18:31,842
I've created a couple of vars   
down at the bottom there,       

352
00:18:31,910 --> 00:18:36,980
a prius, which is a Car, and    
a square, which is a Shape.     

353
00:18:37,049 --> 00:18:39,249
All right, now I'm going to     
declare a var, thing to move.   

354
00:18:39,318 --> 00:18:44,288
It's gonna be of type           
Moveable. Remember I said,      

355
00:18:44,356 --> 00:18:47,391
protocols are types. So I       
made thing to move be of type   

356
00:18:47,459 --> 00:18:50,862
Moveable and assigned it        
to prius, is this allowed?      

357
00:18:52,198 --> 00:18:54,898
Can I assign prius to           
the thing to move? Sure,        

358
00:18:54,967 --> 00:18:58,168
because a prius implements      
the Moveable protocol.          

359
00:18:58,237 --> 00:19:00,304
It implements that move         
to over there and it and        

360
00:19:00,372 --> 00:19:02,273
it also claims to               
implement the Moveable. So      

361
00:19:02,342 --> 00:19:05,075
this is a perfectly legal       
statement right here, but       

362
00:19:05,144 --> 00:19:09,847
this has made a variable        
that is not of type Car, or     

363
00:19:09,916 --> 00:19:13,851
something like that, it's of    
type Moveable. So, I can send   

364
00:19:13,920 --> 00:19:18,655
messages like thingToMove.move  
that's perfectly legal, but     

365
00:19:18,724 --> 00:19:21,625
I can not say                   
thingToMove.changeOil,          

366
00:19:21,694 --> 00:19:25,930
even though a prius is a Car    
and Car implements changeOil.   

367
00:19:25,998 --> 00:19:29,200
You see why I can't send        
that to thingToMove?            

368
00:19:29,268 --> 00:19:33,937
Because thingToMove is          
a Moveable. It's not a Car,     

369
00:19:34,006 --> 00:19:36,673
it's a Moveable. So even        
though the car that happens to  

370
00:19:36,742 --> 00:19:40,311
be in that variable, it can do  
changeOil, I can't send it.     

371
00:19:40,380 --> 00:19:42,947
Swift will not allow me to      
send that message because       

372
00:19:43,015 --> 00:19:44,282
thingToMove in Swift's          

373
00:19:44,350 --> 00:19:47,751
mind is just a Moveable.        
The only thing Swift knows      

374
00:19:47,820 --> 00:19:50,421
that it can do is move to,      
right?                          

375
00:19:50,490 --> 00:19:53,056
So this is the most important   
thing on this entire slide,     

376
00:19:53,125 --> 00:19:57,394
is that red thing. You cannot   
do changeOil if you have a var  

377
00:19:57,463 --> 00:20:02,033
which is of type thingToMove.   
But what are some things you    

378
00:20:02,101 --> 00:20:05,169
can do? Well, I can say         
thingToMove equals square.      

379
00:20:05,237 --> 00:20:08,272
Cuz a square is a Shape,and     
a Shape implements Moveable.    

380
00:20:08,341 --> 00:20:11,375
I could even have an array of   
Moveable and put a prius and    

381
00:20:11,443 --> 00:20:14,311
a square inside of it.          
Cuz even though a prius and     

382
00:20:14,380 --> 00:20:15,579
square are completely           
different,                      

383
00:20:15,648 --> 00:20:17,882
one's a struct, one's a class,  
one's a Car, one's a Shape.     

384
00:20:17,951 --> 00:20:20,150
They're completely              
not really different,           

385
00:20:20,219 --> 00:20:23,320
they can be in the same array,  
because they're both Moveable,  

386
00:20:23,389 --> 00:20:26,957
you see that? And of course I   
can have functions that take    

387
00:20:27,026 --> 00:20:29,226
Moveables as an argument.       
Here's slide,                   

388
00:20:29,295 --> 00:20:32,029
which takes a slider, which     
is a type of Moveable. And      

389
00:20:32,097 --> 00:20:35,132
inside I can say slider         
move to positionToSlideTo,      

390
00:20:35,201 --> 00:20:37,501
and then I can call             
slide the prius,                

391
00:20:37,570 --> 00:20:40,637
slide the square. Perfectly     
legal to say because those      

392
00:20:40,706 --> 00:20:43,473
are Moveables. Yeah, question?  
>> Does that mean that move     

393
00:20:43,542 --> 00:20:44,842
to function where Car and       

394
00:20:44,911 --> 00:20:47,044
Shape have to do                
the exact same thing, or        

395
00:20:47,113 --> 00:20:48,479
do they just-                   
>> You mean,                    

396
00:20:48,548 --> 00:20:51,482
do the exact same thing like    
perform the same action? Okay,  

397
00:20:51,551 --> 00:20:55,452
so the question is, does this   
mean that move to in Car and    

398
00:20:55,521 --> 00:20:58,321
move to in Shape, do they       
have to do exact same thing?    

399
00:20:58,390 --> 00:21:00,824
And the answer is, no. They     
can do anything they want.      

400
00:21:00,893 --> 00:21:03,760
They can do whatever move       
to makes sense for a Car or     

401
00:21:03,829 --> 00:21:05,162
whatever move to                
makes sense for                 

402
00:21:05,231 --> 00:21:07,898
a Shape.                        
>> If you assign it to          

403
00:21:07,967 --> 00:21:10,434
squares. And you call move to,  

404
00:21:10,503 --> 00:21:13,404
how does it decide              
which move to to use?           

405
00:21:13,473 --> 00:21:14,237
>> Okay, so                     

406
00:21:14,306 --> 00:21:17,340
the question is if I declare    
this Movable protocol and       

407
00:21:17,409 --> 00:21:19,142
then I say something            
are movable.                    

408
00:21:19,211 --> 00:21:21,311
They are called move to, how    
does it know which one to use?  

409
00:21:21,380 --> 00:21:25,883
Well, because Swift underneath  
knows which type it is, okay.   

410
00:21:25,951 --> 00:21:28,919
When we say                     
thingToMove.something           

411
00:21:28,988 --> 00:21:30,587
at that level we're             
the programmer and              

412
00:21:30,656 --> 00:21:33,023
Swift is enforcing that         
it has to be a movable.         

413
00:21:33,092 --> 00:21:36,393
But when it comes to actually   
executing the code now Swift    

414
00:21:36,462 --> 00:21:40,030
looks and says, oh it's a Car,  
so I'm gonna use Car's moveTo.  

415
00:21:40,099 --> 00:21:42,232
So Swift behind                 
the scenes is doing it.         

416
00:21:42,301 --> 00:21:44,801
But the whole reason that       
we're typing thing to move      

417
00:21:44,870 --> 00:21:47,538
to be of type thing to move     
is cuz we're telling everyone   

418
00:21:47,607 --> 00:21:50,207
who's reading our code,         
I'm just using this thing as    

419
00:21:50,276 --> 00:21:53,611
a Moveable thing.               
I don't care that it's a car.   

420
00:21:53,679 --> 00:21:56,480
My code works on anything       
that's Movable. So              

421
00:21:56,549 --> 00:22:00,183
I'm just communicating to       
people reading my code and      

422
00:22:00,252 --> 00:22:03,387
to myself in all that but       
Swift under the covers          

423
00:22:03,455 --> 00:22:07,090
of course knows which move to   
execute. It is possible by      

424
00:22:07,159 --> 00:22:10,561
the way to have functions that  
take an argument that has to    

425
00:22:10,630 --> 00:22:13,964
implement multiple protocols.   
So here the slipAndSlide is     

426
00:22:14,033 --> 00:22:17,968
it's function it's argument x.  
Those things have to implement  

427
00:22:18,036 --> 00:22:20,503
Movable and they have to        
implement something called      

428
00:22:20,572 --> 00:22:23,574
slippery which is not shown on  
the slide. So now I cannot say  

429
00:22:23,643 --> 00:22:26,543
slipAndSlide(prius) because     
while prius is Movable,         

430
00:22:26,612 --> 00:22:29,512
it's not slippery. And so       
this would not be allowed,      

431
00:22:29,581 --> 00:22:34,518
Swift would complain here. But  
that's how this &. That's how   

432
00:22:34,586 --> 00:22:40,123
you make it so it requires      
multiple protocol conformists.  

433
00:22:40,192 --> 00:22:43,561
So you're getting a feel for    
how we use a protocol init by   

434
00:22:43,629 --> 00:22:46,897
declaring vars and              
arguments to functions. So      

435
00:22:46,966 --> 00:22:49,633
it's only scratching            
the surface of protocols.       

436
00:22:49,702 --> 00:22:51,301
Yeah, question.                 
>> [INAUDIBLE]                  

437
00:22:51,370 --> 00:22:54,004
The thing to move [INAUDIBLE]   

438
00:22:54,073 --> 00:22:55,405
square.                         
>> Yeah.                        

439
00:22:55,474 --> 00:22:56,240
>> So when you                  

440
00:22:56,309 --> 00:22:58,876
call function [INAUDIBLE]       
>> Here let me back up to       

441
00:23:05,618 --> 00:23:06,816
Okay, so what was that?         

442
00:23:06,885 --> 00:23:09,019
>> [INAUDIBLE]                  
>> Yeah.                        

443
00:23:09,088 --> 00:23:09,686
>> [INAUDIBLE]                  

444
00:23:09,755 --> 00:23:11,321
>> Yeah, up there.              

445
00:23:11,390 --> 00:23:13,790
>> So when you call method on   

446
00:23:13,859 --> 00:23:18,328
thingToMove. [INAUDIBLE]        
>> Okay, so he's saying,        

447
00:23:18,397 --> 00:23:23,500
look, I set thingToMove to be   
a prius. Then I call move to,   

448
00:23:23,569 --> 00:23:24,334
which one did it do?            

449
00:23:24,403 --> 00:23:28,038
Obviously the prius. Then I     
set thingToMove to be square.   

450
00:23:28,107 --> 00:23:31,307
Now if I called move to,        
it would use the square's one.  

451
00:23:31,376 --> 00:23:34,211
So whatever the last thing it   
was set to, that's what it'll   

452
00:23:34,279 --> 00:23:37,848
use. Question?                  
>> [INAUDIBLE]                  

453
00:23:37,917 --> 00:23:38,515
have to take it up here,        

454
00:23:38,584 --> 00:23:40,284
doesn't have to be              
mutating actually?              

455
00:23:40,352 --> 00:23:42,886
Are you allowed to just         
drop that whenever valid-       

456
00:23:42,955 --> 00:23:44,120
>> Great question,              

457
00:23:44,189 --> 00:23:48,025
he's saying up here look in     
Car, move to, no mutating.      

458
00:23:48,094 --> 00:23:50,627
See, down here in Shape,        
we've got mutating. Up here,    

459
00:23:50,696 --> 00:23:55,131
we've got no mutating,          
that's because Car is a class.  

460
00:23:55,200 --> 00:23:58,101
Class is a reference site,      
they don't need mutating, so    

461
00:23:58,170 --> 00:24:03,407
it's perfectly fine. Any other  
questions about this? Okay,     

462
00:24:03,475 --> 00:24:07,244
excellent. So now let's talk    
about the uses of protocol.     

463
00:24:07,313 --> 00:24:09,646
Now we kinda know what          
protocols are and               

464
00:24:09,715 --> 00:24:12,782
how we can put them in our      
API, how do we use it? Well,    

465
00:24:12,851 --> 00:24:16,086
of super important to use is    
this MVC delegation thing,      

466
00:24:16,155 --> 00:24:18,656
right? We've got these          
generic view things,            

467
00:24:18,724 --> 00:24:21,324
like scroll views and table     
views and things like that.     

468
00:24:21,393 --> 00:24:24,227
And then we've got these very   
specific controller things,     

469
00:24:24,296 --> 00:24:26,897
how does a generic thing talk   
to a specific thing without     

470
00:24:26,966 --> 00:24:29,132
knowing anything about          
that specific thing?            

471
00:24:29,201 --> 00:24:31,902
Because obviously, when scroll  
view shifts from Apple,         

472
00:24:31,971 --> 00:24:34,704
it knows nothing about          
Concentration games. So         

473
00:24:34,773 --> 00:24:36,673
how do we do that?              
Well, we use protocols, okay,   

474
00:24:36,742 --> 00:24:40,044
so like simple, so this is      
the will, did, shoulds and      

475
00:24:40,112 --> 00:24:41,378
So let's take a look how        
we do this, all right? So       

476
00:24:41,379 --> 00:24:42,645
the data at.                    

477
00:24:42,715 --> 00:24:46,050
kinda six steps. First a view,  
like a scroll view or           

478
00:24:46,118 --> 00:24:49,285
table view, it declares         
it's delegation protocol.       

479
00:24:49,354 --> 00:24:51,721
That's just a protocol with a   
list of all the well, dids and  

480
00:24:51,790 --> 00:24:55,225
shoulds that it wants to send.  
Remember protocols just a list  

481
00:24:55,294 --> 00:24:58,161
of methods, right? So           
it creates that protocol. Then  

482
00:24:58,230 --> 00:25:01,465
the view, the scroll view,      
it creates a var in itself,     

483
00:25:01,534 --> 00:25:05,669
a public var, it's weak,        
turns out. And so               

484
00:25:05,737 --> 00:25:10,573
it's an optional and that is    
of type that protocol. Okay,    

485
00:25:10,642 --> 00:25:13,711
now that's great because now    
the view whenever it wants      

486
00:25:13,779 --> 00:25:16,980
to send will, did, should,      
it just sends it to that var.   

487
00:25:17,049 --> 00:25:19,083
And that works because that     
var is of type that protocol,   

488
00:25:19,151 --> 00:25:20,918
so of course it can             
understand all the will, did,   

489
00:25:20,986 --> 00:25:24,855
should. Then the controller     
comes along says, raises its    

490
00:25:24,924 --> 00:25:27,824
hand and says, I implement      
that scroll view delegate       

491
00:25:27,893 --> 00:25:31,395
protocol by putting it on this  
little class line right there.  

492
00:25:31,464 --> 00:25:35,765
And the controller sets         
itself as that delegate var,    

493
00:25:35,834 --> 00:25:38,802
it literally says that          
delegate var equals self.       

494
00:25:38,870 --> 00:25:41,939
So it's setting itself as       
the delegate and that's legal.  

495
00:25:42,008 --> 00:25:43,940
Because the controller          
has claimed, hey,               

496
00:25:44,009 --> 00:25:47,844
I implement that delegate and   
so, and that delegate is of     

497
00:25:47,913 --> 00:25:51,715
type that protocol,             
all is good, okay. And then,    

498
00:25:51,784 --> 00:25:54,384
of course, the controller has   
to implement all the methods    

499
00:25:54,453 --> 00:25:56,886
in the protocol. But            
since this is an Objective-C    

500
00:25:56,955 --> 00:25:59,790
protocol, it actually only has  
to implement the none optional  

501
00:25:59,858 --> 00:26:02,659
ones. Okay and                  
actually in delegation in iOS,  

502
00:26:02,728 --> 00:26:05,261
almost all the methods          
are optional. So usually,       

503
00:26:05,330 --> 00:26:08,699
you only have to implement      
the one you really want. But    

504
00:26:08,767 --> 00:26:11,135
the controller implements       
the methods so they did         

505
00:26:11,203 --> 00:26:14,004
successfully fills out its      
claim to have implemented it.   

506
00:26:14,073 --> 00:26:17,808
And that's it. Now the view is  
hooked up to the controller.    

507
00:26:17,877 --> 00:26:19,943
The view can send will, did,    
and should all it wants.        

508
00:26:20,012 --> 00:26:22,980
It has no idea what kind        
of class is doing it.           

509
00:26:23,048 --> 00:26:25,015
All it knows about, it doesn't  
even know if it's a class,      

510
00:26:25,083 --> 00:26:26,884
could be a struct,              
it knows nothing about it.      

511
00:26:26,952 --> 00:26:29,219
All it knows is that that       
thing implements its protocol,  

512
00:26:29,287 --> 00:26:30,955
so it knows that it can         
send well, did, and             

513
00:26:31,023 --> 00:26:33,790
should to it through            
that delegate var. Okay,        

514
00:26:33,859 --> 00:26:37,761
make sense? So                  
let's look at the code for      

515
00:26:37,830 --> 00:26:41,098
this with the example of        
a scroll view, okay. Oh, yeah,  

516
00:26:41,166 --> 00:26:45,368
sorry. Yeah, you find this      
delegation everywhere in iOS,   

517
00:26:45,437 --> 00:26:49,840
it was designed in Objective-C  
world. In Swift, we have        

518
00:26:49,909 --> 00:26:52,375
closure, which I'm gonna talk   
about later in this lecture.    

519
00:26:52,444 --> 00:26:56,846
And you could use closures for  
some of this stuff. But         

520
00:26:56,915 --> 00:27:00,451
even with closures, delegation  
is pretty cool way to do this,  

521
00:27:00,519 --> 00:27:03,653
have this blind communication.  
All right, so                   

522
00:27:03,722 --> 00:27:06,824
let's look at the example of    
UIScrollView. So this is what   

523
00:27:06,892 --> 00:27:10,527
the var that the scroll         
view would have in itself.      

524
00:27:10,595 --> 00:27:13,363
Okay, this is a scroll          
view var. It's a weak,          

525
00:27:13,431 --> 00:27:17,034
why is it weak, by the way?     
Because here the view           

526
00:27:17,103 --> 00:27:19,236
is gonna have a pointers        
to the controller, and          

527
00:27:19,305 --> 00:27:21,838
we know that the controller     
has a lot of pointers to        

528
00:27:21,907 --> 00:27:25,141
the view. They'd be keeping     
themselves in the heap. Okay,   

529
00:27:25,210 --> 00:27:28,478
so what this view is saying     
here is, I wanna point to       

530
00:27:28,547 --> 00:27:32,483
whoever receives my will, did,  
and shoulds. But if that will,  

531
00:27:32,551 --> 00:27:34,684
did, and should guy             
wants to leave the heap,        

532
00:27:34,753 --> 00:27:36,787
that's fine by me,              
just set this to nil and        

533
00:27:36,856 --> 00:27:40,190
I'll stop sending messages      
to it. Okay, so that way,       

534
00:27:40,259 --> 00:27:42,759
the view won't keep             
the controller in the heat.     

535
00:27:42,828 --> 00:27:45,495
So anyway, notice this is       
optional because it's weak.     

536
00:27:45,564 --> 00:27:47,430
This is the delegate, it's of   
type UIScrollview delegate.     

537
00:27:47,499 --> 00:27:49,332
This is what that               
protocol looks like,            

538
00:27:49,401 --> 00:27:52,769
it's an Objective-C protocol.   
It's called UIScrollDelegate,   

539
00:27:52,838 --> 00:27:54,338
and it's got all                
those funcs in there.           

540
00:27:54,406 --> 00:27:57,207
ScrollView did scroll to here.  
Give me the view for            

541
00:27:57,276 --> 00:28:00,010
zooming over here. It's got     
about 15 of them in there,      

542
00:28:00,079 --> 00:28:02,212
if you go look at               
the documentation. So           

543
00:28:02,281 --> 00:28:05,148
now the controller comes        
along, MyViewController,        

544
00:28:05,217 --> 00:28:09,920
and it puts comma, UIViewCont,  
UIScrollViewDelegate on         

545
00:28:09,989 --> 00:28:13,157
the end and claiming I          
implement that protocol.        

546
00:28:13,225 --> 00:28:15,893
Then, in its probably           
in its outlet setter,           

547
00:28:15,961 --> 00:28:19,530
we'll see an example of this    
today. When that scrollView     

548
00:28:19,598 --> 00:28:22,499
gets hooked up on iOS,          
in the didSet of that,          

549
00:28:22,568 --> 00:28:26,036
it probably says,               
scrollView.delegate = self.     

550
00:28:26,105 --> 00:28:29,706
This is a legal statement to    
say because delegate, which is  

551
00:28:29,774 --> 00:28:34,111
this thing up here, is of type  
UIScrollViewDelegate. And       

552
00:28:34,179 --> 00:28:38,315
MyViewController says over      
here that it implemented that.  

553
00:28:38,384 --> 00:28:42,252
So it's legal for it to set     
itself as the delegate. Okay,   

554
00:28:42,321 --> 00:28:44,655
and once it does this,          
they are hooked up, and         

555
00:28:44,723 --> 00:28:47,524
now the view can send will,     
did, said to the controller     

556
00:28:47,593 --> 00:28:50,894
all at once. Okay, so           
that's delegation,              

557
00:28:50,962 --> 00:28:54,765
probably one of the most        
obvious uses of protocols.      

558
00:28:54,833 --> 00:28:57,066
What's another one? Okay,       
remember, I talked about that   

559
00:28:57,135 --> 00:28:59,803
key in the dictionary in        
the hashable business, right?   

560
00:28:59,872 --> 00:29:02,406
So of course, the key in the    
dictionary has to be hashable.  

561
00:29:02,475 --> 00:29:05,442
How do we enforce this          
in our API? Well,               

562
00:29:05,511 --> 00:29:08,211
there is a protocol             
called Hashable.                

563
00:29:08,280 --> 00:29:10,781
It inherits from another        
protocol called Equatable, and  

564
00:29:10,849 --> 00:29:13,149
that's because you know         
anything about Hashtables.      

565
00:29:13,218 --> 00:29:16,319
When you hash something, it's   
likely to be a unique hash but  

566
00:29:16,388 --> 00:29:17,888
it's not gonna guaranteed.      

567
00:29:17,956 --> 00:29:21,324
You have to follow it up by     
actually using equals to see    

568
00:29:21,393 --> 00:29:25,529
if the two things are actually  
equal, so we hash in works.     

569
00:29:25,598 --> 00:29:28,332
So that's why Hashable          
inherits from Equatable.        

570
00:29:28,400 --> 00:29:30,333
So if you wanna be Hashable,    
you also have to be able to     

571
00:29:30,402 --> 00:29:32,702
check if you're equal to        
something else. Now this is of  

572
00:29:32,771 --> 00:29:35,606
super simple protocol,          
it only has one var in it.      

573
00:29:35,674 --> 00:29:40,176
It's a get only var,            
which is the hash value.        

574
00:29:40,245 --> 00:29:44,314
Some integer, that hopefully,   
uniquely represents you,        

575
00:29:44,382 --> 00:29:47,918
that's what this is. Now,       
let's look at Equatable, okay,  

576
00:29:47,986 --> 00:29:50,453
which, cuz that's another       
protocol that is inherited and  

577
00:29:50,522 --> 00:29:53,022
thus, required here.            
What does that look like?       

578
00:29:53,091 --> 00:29:55,258
That's a very simple            
protocol as well.               

579
00:29:55,327 --> 00:29:57,861
It has one function in it,      
one method,                     

580
00:29:57,930 --> 00:30:01,431
which is static. Meaning it's   
on the type, like get unique    

581
00:30:01,500 --> 00:30:05,401
identifier was in card,         
remember that? And its name is  

582
00:30:05,470 --> 00:30:09,506
==. In Swift, remember, names   
of methods can be like emoji.   

583
00:30:09,575 --> 00:30:12,709
It's not required to be         
alpha numeric characters, so    

584
00:30:12,777 --> 00:30:17,080
they chooses to be called ==,   
which is kind of cool. And      

585
00:30:17,149 --> 00:30:20,283
the arguments are a left-hand   
side and a right-hand side,     

586
00:30:20,352 --> 00:30:24,454
notice that the type itself,    
this is a type method, so self  

587
00:30:24,523 --> 00:30:27,824
is the type. So if this were    
implemented by int, if int      

588
00:30:27,893 --> 00:30:32,262
were implementing equitable,    
self would be int. Okay,        

589
00:30:32,331 --> 00:30:34,498
cuz it would be a type          
function on int, and so         

590
00:30:34,566 --> 00:30:35,231
the left-hand side and          

591
00:30:35,300 --> 00:30:37,233
the right-hand side would       
be ints of course. So           

592
00:30:37,302 --> 00:30:40,503
this is basically saying, that  
your type has to have an ==     

593
00:30:40,572 --> 00:30:44,173
method that compares to ints,   
or whatever you are. And sees   

594
00:30:44,242 --> 00:30:48,111
if they're equal, and returns   
a bool, yes or no. Okay, now,   

595
00:30:48,180 --> 00:30:51,047
this is, that's so that's what  
you have to do to be Hashable.  

596
00:30:51,116 --> 00:30:55,485
But what's really cool,         
that the == operator in Swift,  

597
00:30:55,553 --> 00:30:59,389
okay, when you say like x ==    
y, that's actually not like     

598
00:30:59,457 --> 00:31:02,125
built into Swift or anything.   
All that does is look for       

599
00:31:02,194 --> 00:31:06,162
this method, okay.              
So any two, any class can use,  

600
00:31:06,231 --> 00:31:10,200
can do == as long as you        
implements this protocol. So    

601
00:31:10,268 --> 00:31:13,069
this protocol is required to    
make the Hashable work, but     

602
00:31:13,138 --> 00:31:16,506
it also makes the == operator   
work. And we're gonna see this  

603
00:31:16,575 --> 00:31:20,977
in our concentration demo when  
I go to implement this. So,     

604
00:31:21,046 --> 00:31:25,048
now that we know that Hashable  
means you can be a key          

605
00:31:25,116 --> 00:31:27,750
in a dictionary,                
how is this expressed? Well,    

606
00:31:27,819 --> 00:31:31,054
dictionary which is a generic   
type, right? It's got these     

607
00:31:31,122 --> 00:31:33,256
two types, the type of the key  
and the type of the value.      

608
00:31:33,325 --> 00:31:37,693
It declares itself as           
Dictionary<Key: Hashable,       

609
00:31:37,762 --> 00:31:42,031
Value>, and that means that     
key can only work there if      

610
00:31:42,100 --> 00:31:47,237
it's Hashable. So this is how   
we use protocols to constrain   

611
00:31:47,305 --> 00:31:50,874
these generic types, right?     
Now Value, right there          

612
00:31:50,943 --> 00:31:53,343
in the dictionary, it doesn't   
have any colon anything, so     

613
00:31:53,412 --> 00:31:54,645
Value could be any type.        

614
00:31:54,713 --> 00:31:57,147
You can put any type            
whatsoever as the value         

615
00:31:57,216 --> 00:32:01,918
in a dictionary. But the key    
has to implement hashable. So   

616
00:32:01,987 --> 00:32:07,324
let's go into concentration     
and do this very thing.         

617
00:32:07,392 --> 00:32:09,992
What do we have in a            
dictionary? Well, we have one   

618
00:32:10,061 --> 00:32:13,530
dictionary, it's that emoji     
thing. It's, keys are int,      

619
00:32:13,599 --> 00:32:16,366
ints are hashable so            
we're good, and the values      

620
00:32:16,434 --> 00:32:19,802
are the emoji. And the int      
is our cards identifier.        

621
00:32:19,871 --> 00:32:22,839
Remember that card identifier?  
So, I don't want to do that.    

622
00:32:22,907 --> 00:32:27,210
I want my keys in my emoji      
dictionary to be cards.         

623
00:32:27,279 --> 00:32:29,046
I want to look up               
the cards directly,             

624
00:32:29,114 --> 00:32:30,980
I don't want any of that        
looking at the int thing,       

625
00:32:31,049 --> 00:32:34,183
that's ridiculous. So, if I go  
over here to view controller.   

626
00:32:34,252 --> 00:32:35,518
Here it is right here,          
actually.                       

627
00:32:35,587 --> 00:32:39,489
See, here is my emoji thing,    
int to string, int keys,        

628
00:32:39,557 --> 00:32:43,627
string values, this has to be   
hashable, it is right now.      

629
00:32:43,695 --> 00:32:44,594
But I don't want that,          

630
00:32:44,663 --> 00:32:46,329
i just want to look up          
the cards directly.             

631
00:32:46,398 --> 00:32:47,531
I don't want to use             
the identifier,                 

632
00:32:47,599 --> 00:32:51,134
I am just going to take this    
identifier right off of here    

633
00:32:51,203 --> 00:32:54,036
and when I do this,             
I'm gonna get errors.           

634
00:32:54,105 --> 00:32:58,508
And why am I gonna get errors?  
Because card, see right here?   

635
00:32:58,577 --> 00:33:01,811
Let's see if we can make        
this a little wider so          

636
00:33:01,880 --> 00:33:06,683
you can see it a little         
better down here.               

637
00:33:06,752 --> 00:33:11,421
It says right here that         
we cannot substitute,           

638
00:33:11,490 --> 00:33:14,691
oh, sorry. Okay, it says        
cannot subscript a value of     

639
00:33:14,760 --> 00:33:16,993
int string with a card.         
Of course okay,                 

640
00:33:17,062 --> 00:33:20,530
I said that the keys were int,  
and here I'm trying to do it    

641
00:33:20,599 --> 00:33:22,031
by card. So                     
I'm just gonna say okay,        

642
00:33:22,100 --> 00:33:25,001
that I'm gonna have them be     
cards instead. So I'm just      

643
00:33:25,070 --> 00:33:28,772
gonna have my dictionary, have  
keys of card,values of string.  

644
00:33:30,175 --> 00:33:36,979
So now, what do we got here?    
It says type card               

645
00:33:37,048 --> 00:33:40,449
does not conform to protocol    
hashable, it worked, okay.      

646
00:33:40,518 --> 00:33:44,221
I tried to make a card be       
the key of my dictionary and    

647
00:33:44,289 --> 00:33:47,290
it says, no, card does not      
conform the protocol hashable.  

648
00:33:47,359 --> 00:33:50,293
So the declaration dictionary   
which you can go look up in     

649
00:33:50,362 --> 00:33:52,028
the documentation,              

650
00:33:52,097 --> 00:33:55,465
it says card, the key has to    
be hashable and it wasn't. So   

651
00:33:55,533 --> 00:33:58,368
let's go make card              
be hashable, so                 

652
00:33:58,437 --> 00:34:00,303
we won't have this              
error any more, so              

653
00:34:00,371 --> 00:34:03,740
I'm gonna go over to card,      
here it is. And here is card,   

654
00:34:03,808 --> 00:34:09,912
I'm just gonna say,             
okay, card is hashable.         

655
00:34:09,981 --> 00:34:12,983
So I just made card hashable,   
now of course Swift is gonna    

656
00:34:13,051 --> 00:34:16,486
look at this and say whoa wait  
a second errors here, card      

657
00:34:16,555 --> 00:34:19,222
does not conform to hashable.   
Card does not conform           

658
00:34:19,290 --> 00:34:22,058
to equatable which it doesn't   
because I don't implement       

659
00:34:22,127 --> 00:34:25,528
those methods the hash value    
or the equals equal thing.      

660
00:34:25,596 --> 00:34:28,264
What's really cool in Swift,    
look at the fix button here.    

661
00:34:28,333 --> 00:34:32,669
Do you wanna add protocol       
stubs? Oh, yes please. And      

662
00:34:32,737 --> 00:34:35,538
look what it did. It added      
a stub for hashable, and        

663
00:34:35,607 --> 00:34:38,808
a stub for equitables. Now I    
just have to implement these.   

664
00:34:38,877 --> 00:34:41,611
So, making hash value,          
which has to be get only,       

665
00:34:41,679 --> 00:34:46,149
that's easy. I'm just gonna     
return my identifier. That's    

666
00:34:46,217 --> 00:34:50,987
an extremely good hash for      
a card because it's unique for  

667
00:34:51,056 --> 00:34:54,291
that card. And the equals,      
equals is also really easy      

668
00:34:54,359 --> 00:34:56,526
too. I just have to             
compare these two cards.        

669
00:34:56,594 --> 00:34:59,462
I'm gonna return if the left    
hand side's identifier          

670
00:34:59,530 --> 00:35:03,433
equals the right hand side's    
identifier. So there we go.     

671
00:35:03,501 --> 00:35:06,069
I've implemented hashable and   
equatable. So                   

672
00:35:06,138 --> 00:35:08,538
now if I go back to             
my view controller,             

673
00:35:08,607 --> 00:35:11,507
will that error be gone?        
Here's the error over here.     

674
00:35:11,576 --> 00:35:15,611
So let's make Xcode recompile,  
and sure enough look,           

675
00:35:15,680 --> 00:35:19,015
no problems. It's completely    
fine with that, okay, and       

676
00:35:19,084 --> 00:35:23,053
that's because I made           
this hashable. Now,             

677
00:35:23,121 --> 00:35:24,787
we can get another              
benefit of this.                

678
00:35:24,856 --> 00:35:28,291
Let me go back to card. And I   
told you before, I didn't like  

679
00:35:28,360 --> 00:35:30,861
that this identifier was        
public. I see no reason for     

680
00:35:30,929 --> 00:35:32,495
it to be public.                
And we know we don't need it    

681
00:35:32,564 --> 00:35:35,064
now to look in our emoji        
thing, so I'm just gonna make   

682
00:35:35,133 --> 00:35:38,534
it private. And let's see       
if that's gonna work.           

683
00:35:38,603 --> 00:35:40,069
So is private gonna work?       

684
00:35:40,138 --> 00:35:43,139
Let's build and see. Oh, no,    
we have some errors over here.  

685
00:35:43,207 --> 00:35:45,942
So let's go look at them.       
Here's an error here, it says,  

686
00:35:46,011 --> 00:35:49,512
identifier is inaccessible due  
to private protection level.    

687
00:35:49,581 --> 00:35:51,714
That's right,                   
I made identifier private.      

688
00:35:51,783 --> 00:35:56,086
What's it trying to do here?    
Oh, here I'm trying to see if   

689
00:35:56,154 --> 00:36:01,390
two cards match, oh, well       
cards implement equatable now.  

690
00:36:01,459 --> 00:36:05,328
So I can just go like           
this card matchIndex            

691
00:36:05,397 --> 00:36:10,033
=cards[index] because I can     
compare cards directly,         

692
00:36:10,102 --> 00:36:12,268
now. They implement equatable,  
right?                          

693
00:36:12,337 --> 00:36:15,305
Now if we build,                
that's gone away. So            

694
00:36:15,373 --> 00:36:17,440
we had a huge benefit by        
making that equatable and       

695
00:36:17,508 --> 00:36:20,943
hashable. We got to use it      
directly in our emoji thing to  

696
00:36:21,012 --> 00:36:24,147
make that code look nice and    
look how nice this code looks.  

697
00:36:24,216 --> 00:36:26,549
Compared to how it used to      
look with that identifier,      

698
00:36:26,618 --> 00:36:30,020
right, so we cleaned up our     
code on the use side and        

699
00:36:30,088 --> 00:36:31,354
we were able to go              
back to card and                

700
00:36:31,423 --> 00:36:33,789
make something that really      
didn't need to be public,       

701
00:36:33,858 --> 00:36:38,194
completely private.             
Pretty cool with that? Okay,    

702
00:36:38,263 --> 00:36:41,164
so you're starting to see the   
power of protocols a building   

703
00:36:41,233 --> 00:36:45,402
here. So let's go back and      
look at even more protocol      

704
00:36:45,470 --> 00:36:50,139
stuff that's cool.              
All right, there                

705
00:36:50,208 --> 00:36:54,610
is the demo, okay, let's talk   
a little about this multiple    

706
00:36:54,679 --> 00:36:59,782
inheritance kind of trick.      
Consider countable range,       

707
00:36:59,851 --> 00:37:02,652
remember countable range zero   
dot dot less than something     

708
00:37:02,720 --> 00:37:06,055
creates this countable range    
of ints from zero that thing    

709
00:37:06,123 --> 00:37:10,293
minus one. Countable range      
implements a lot of protocols.  

710
00:37:10,362 --> 00:37:14,063
If you go look at countable     
range, it may have 12 or        

711
00:37:14,132 --> 00:37:16,866
15 different protocols. Well,   
two of the most interesting     

712
00:37:16,935 --> 00:37:19,135
ones it implements              
are sequence.                   

713
00:37:20,772 --> 00:37:22,088
right? A countable range is a   
sequence of numbers from zero   

714
00:37:22,089 --> 00:37:23,405
Which makes sense,              

715
00:37:23,474 --> 00:37:26,643
to something else.              
And also collection,            

716
00:37:26,711 --> 00:37:29,345
because accountable range is    
also a collection of things.    

717
00:37:29,413 --> 00:37:30,713
If it's accountable             
range of int,                   

718
00:37:30,782 --> 00:37:32,815
it's a collection of int or     
whatever. And                   

719
00:37:32,884 --> 00:37:36,819
so these two protocols define   
a lot of fun things like        

720
00:37:36,888 --> 00:37:41,057
sequence defines really         
only one method,                

721
00:37:41,125 --> 00:37:44,127
next, which goes to the next    
thing in the sequence.          

722
00:37:44,196 --> 00:37:46,862
But that let you do for in,     
anything that implements        

723
00:37:46,931 --> 00:37:49,799
the sequence protocol could     
do for in, okay, just like      

724
00:37:49,867 --> 00:37:53,269
anything that's hashable can    
be a key in the dictionary.     

725
00:37:53,338 --> 00:37:55,571
And then, collection            
has even more methods,          

726
00:37:55,640 --> 00:37:59,509
all the indexing, sub-scripts,  
all that stuff is all           

727
00:37:59,578 --> 00:38:03,345
in the collection protocol.     
Now, why do we do this?         

728
00:38:03,414 --> 00:38:06,216
Why do we have countable range  
implement all these protocols?  

729
00:38:06,284 --> 00:38:09,652
Well, because array implements  
all those as well, and so       

730
00:38:09,721 --> 00:38:13,990
does dictionary and set and     
string. All these classes       

731
00:38:14,059 --> 00:38:17,593
that are sequences of things    
or collections of things        

732
00:38:17,662 --> 00:38:20,129
implement all these             
exact same things. And          

733
00:38:20,198 --> 00:38:23,799
so I as a programmer only have  
to learn these things once.     

734
00:38:23,868 --> 00:38:26,902
Okay, I only have to learn      
learn for in once. And          

735
00:38:26,971 --> 00:38:29,672
all I need to know is that      
the thing I wanna for           

736
00:38:29,741 --> 00:38:32,641
in over has to be a sequence.   
So I can just look to see does  

737
00:38:32,710 --> 00:38:34,243
this thing implement            
that protocol? Or               

738
00:38:34,312 --> 00:38:37,947
I can even invent my own        
things that I can for in over.  

739
00:38:38,016 --> 00:38:40,750
All I have to do is implement   
the sequencing, the sequence    

740
00:38:40,819 --> 00:38:43,820
protocol which really only has  
one method in it ultimately.    

741
00:38:45,423 --> 00:38:49,392
So that's one good reason why   
because I learned indexing,     

742
00:38:49,461 --> 00:38:52,662
indexOf to get things and       
I can now do indexOf            

743
00:38:52,731 --> 00:38:54,630
on a string and find            
a character on a string or      

744
00:38:54,699 --> 00:38:57,667
I can do indexOf in             
an array and find in there.     

745
00:38:57,736 --> 00:39:01,070
I can even do indexOf on        
accountable range not super     

746
00:39:01,139 --> 00:39:04,273
valuable but if the count       
of a range wasn't of int,       

747
00:39:04,342 --> 00:39:06,976
then it might be interesting    
to do index of to try and       

748
00:39:07,044 --> 00:39:10,847
find something where it is      
in the range, okay. But         

749
00:39:10,915 --> 00:39:13,816
there's a bigger and            
better reason why we do this.   

750
00:39:13,885 --> 00:39:17,854
And that's because there's a    
little bit of magic in, or not  

751
00:39:17,923 --> 00:39:21,590
magic but really good design    
implementation in Swift.        

752
00:39:21,659 --> 00:39:25,061
Which is that for protocols it  
is possible to provide default  

753
00:39:25,130 --> 00:39:31,868
implementations of methods.     
Default implementations         

754
00:39:31,937 --> 00:39:37,006
of methods. So                  
this makes it possible for      

755
00:39:37,075 --> 00:39:39,709
us to implement indexOf for     

756
00:39:39,777 --> 00:39:45,014
all of these classes in         
one place. So that's why,       

757
00:39:45,082 --> 00:39:47,617
again, we think it's like       
multiple inheritance cuz        

758
00:39:47,686 --> 00:39:51,120
they're actually gonna inherit  
implementation. So where do     

759
00:39:51,188 --> 00:39:53,623
you put this implementation?    
Cuz we know protocol is just    

760
00:39:53,691 --> 00:39:56,525
a declaration method with       
no implementation. Well,        

761
00:39:56,594 --> 00:39:59,962
the answer is you put them in   
an extension to your protocol.  

762
00:40:00,031 --> 00:40:03,066
You know how we can have        
extension int? You can also do  

763
00:40:03,134 --> 00:40:07,336
extension protocol.             
And in that extension you can   

764
00:40:07,405 --> 00:40:10,206
implement as many other         
protocol methods as you want.   

765
00:40:10,275 --> 00:40:12,709
Now you're little bit           
restricted there because        

766
00:40:12,777 --> 00:40:14,877
extensions can't                
have any storage.               

767
00:40:14,946 --> 00:40:17,713
We know that, right?            
No vars, so that's certainly    

768
00:40:17,782 --> 00:40:21,117
a restriction. Also in          
the extension, really the only  

769
00:40:21,186 --> 00:40:24,119
method you could use to         
implement it are the methods    

770
00:40:24,188 --> 00:40:26,990
in the protocol or              
in the protocols you inherit.   

771
00:40:27,058 --> 00:40:30,126
So, like collection, happens    
to inherit from sequence so     

772
00:40:30,194 --> 00:40:32,729
a lot of the collection         
methods can be implemented      

773
00:40:32,797 --> 00:40:35,364
using the sequence by just      
going through the whole         

774
00:40:35,433 --> 00:40:39,301
sequence of the collection and  
finding things, or whatever.    

775
00:40:39,370 --> 00:40:44,173
So if you look here, sequence   
has that one important method   

776
00:40:44,242 --> 00:40:46,609
next goes to the next           
thing in the sequence. But      

777
00:40:46,678 --> 00:40:48,711
sequence also has all           
these other methods,            

778
00:40:48,779 --> 00:40:51,414
contains which finds whether    
somethings in the sequence,     

779
00:40:51,483 --> 00:40:54,783
forEach which kind of does      
what for n does. Joined by      

780
00:40:54,852 --> 00:40:57,586
separator, which takes all      
the things in the sequence,     

781
00:40:57,655 --> 00:41:00,356
converts it to a string and     
creates a big string            

782
00:41:00,425 --> 00:41:04,293
joined by a separator like      
comma or space. It has min,     

783
00:41:04,362 --> 00:41:06,729
find me the minimum thing       
in this sequence, max,          

784
00:41:06,798 --> 00:41:10,133
the maximum thing. Even has     
functions that take closures,   

785
00:41:10,201 --> 00:41:12,001
which I'm going to talk         
about soon like filter and      

786
00:41:12,070 --> 00:41:15,171
map, that do major              
operations on the sequence.     

787
00:41:15,240 --> 00:41:17,740
Well, all the implementation    
of all those things contains,   

788
00:41:17,808 --> 00:41:19,909
forEach, joined, min,           
max all those things.           

789
00:41:19,978 --> 00:41:23,512
Those are all implemented in    
an extension to sequence that   

790
00:41:23,581 --> 00:41:27,583
Apple provides so that if       
you want to have a sequence,    

791
00:41:27,652 --> 00:41:30,586
as long as you implement that   
next thing to go to the next    

792
00:41:30,655 --> 00:41:33,222
thing in the sequence you get   
implementations of all those    

793
00:41:33,291 --> 00:41:36,892
other things for free. That     
also means that array, and set  

794
00:41:36,961 --> 00:41:39,595
and dictionary, and countable   
range are all sharing           

795
00:41:39,663 --> 00:41:42,398
the implementations of min and  
max and all these things.       

796
00:41:42,466 --> 00:41:45,134
Now, these are only             
default implementations.        

797
00:41:45,203 --> 00:41:48,337
If an array you actually        
implement min or max or         

798
00:41:48,405 --> 00:41:50,740
something like that. Maybe you  
can do it more efficiently      

799
00:41:50,808 --> 00:41:51,941
than the default                
implementation or               

800
00:41:52,010 --> 00:41:55,978
whatever. You can do it.        
But it's replace the default    

801
00:41:56,047 --> 00:41:58,915
implementation that's           
in the extension.               

802
00:41:58,983 --> 00:42:00,983
Okay, but are you getting       
the feel for what I'm saying?   

803
00:42:01,052 --> 00:42:03,385
Why this is valuable to have    
these default imitations.       

804
00:42:03,454 --> 00:42:05,921
You can have these really       
powerful protocols and          

805
00:42:05,990 --> 00:42:07,690
you'll only have to implement   
one of the methods and          

806
00:42:07,759 --> 00:42:08,690
you'll get implementations for  

807
00:42:08,759 --> 00:42:11,293
all of them. And then they're   
shared across all these weird   

808
00:42:11,362 --> 00:42:13,061
different classes like array,   
string,                         

809
00:42:13,130 --> 00:42:16,765
countable range. They all get   
all these implementations they  

810
00:42:16,834 --> 00:42:18,801
don't have to implement any of  
that and they get it for free.  

811
00:42:20,971 --> 00:42:23,739
Now all of these that I'm       
talking about generics,         

812
00:42:23,808 --> 00:42:28,678
value typing,                   
var versus let immutability     

813
00:42:28,746 --> 00:42:33,750
control, constraining things    
by protocols, extensions or     

814
00:42:33,818 --> 00:42:36,685
protocols. All these things     
add up to support a kind of     

815
00:42:36,754 --> 00:42:39,322
programming called functional   
programming. How many people    

816
00:42:39,391 --> 00:42:42,591
here have heard about           
functional programming?         

817
00:42:42,660 --> 00:42:43,993
About half of you, see? So      

818
00:42:44,062 --> 00:42:46,062
I encourage you at              
your Stanford careers,          

819
00:42:46,130 --> 00:42:48,765
go take a class and learn       
about functional programming.   

820
00:42:48,833 --> 00:42:51,467
It's really kind of             
the evolution, some would say,  

821
00:42:51,535 --> 00:42:54,270
of object-oriented              
programming. It's a little      

822
00:42:54,339 --> 00:42:56,538
different way of thinking       
about dividing things up.       

823
00:42:56,607 --> 00:42:58,774
It allows you to get things     
like multiple inheritance       

824
00:42:58,843 --> 00:43:00,977
without things getting          
completely out of control.      

825
00:43:01,046 --> 00:43:02,744
Since things aren't             
living in the heap,             

826
00:43:02,813 --> 00:43:05,414
you don't have 20 pointers to   
something and you're not sure   

827
00:43:05,483 --> 00:43:07,950
who's gonna modify things, so   
your programs are much more     

828
00:43:08,018 --> 00:43:10,552
provable,right? You can prove   
that they do what they do.      

829
00:43:10,621 --> 00:43:13,322
You don't have to worry about   
what pointers are messing this  

830
00:43:13,390 --> 00:43:15,758
thing up in the heap lot        
of advantages of it. Now,       

831
00:43:15,827 --> 00:43:17,560
what's really                   
cool about Swift,               

832
00:43:17,629 --> 00:43:20,329
it supports both these          
programming models.             

833
00:43:20,397 --> 00:43:22,898
Object oriented programming,    
which is all I'm gonna          

834
00:43:22,967 --> 00:43:24,967
use in this class because       
that's the prerequisite for     

835
00:43:25,036 --> 00:43:27,203
this class, and                 
functional programming,         

836
00:43:27,271 --> 00:43:31,373
which is what pretty much       
all of the foundation of        

837
00:43:31,442 --> 00:43:35,545
foundation framework like       
dictionary, array, string,      

838
00:43:35,613 --> 00:43:38,380
all those things. Those are     
all built with a functional     

839
00:43:38,449 --> 00:43:42,117
programming model. Swift        
supports them both equally,     

840
00:43:42,186 --> 00:43:44,219
which is really great.          
So it's kind of your best,      

841
00:43:44,288 --> 00:43:46,088
it's a mix between              
languages like Haskell,         

842
00:43:46,156 --> 00:43:48,457
how many of you have ever       
heard of the language Haskell?  

843
00:43:48,525 --> 00:43:51,160
Okay, same people who know      
about functional programming,   

844
00:43:51,229 --> 00:43:53,863
right, so Haskell which is a    
purely functional programming   

845
00:43:53,932 --> 00:43:56,532
language, and you know, like    
Java which is a purely object   

846
00:43:56,600 --> 00:44:01,137
oriented language. It's a good  
mix of two. That's all I'm      

847
00:44:01,205 --> 00:44:03,773
going to say about functional   
programming, just so            

848
00:44:03,841 --> 00:44:07,509
that you know it's there.       
That's it for protocols.        

849
00:44:07,578 --> 00:44:11,113
When you see it all in action   
it will make a lot more sense.  

850
00:44:11,181 --> 00:44:12,114
Hopefully it makes              
a lot of sense.                 

851
00:44:12,183 --> 00:44:14,016
Now it's really,                
protocols are very simple.      

852
00:44:14,085 --> 00:44:16,485
Just those lists but we can     
use them in powerful ways,      

853
00:44:16,553 --> 00:44:20,522
all right. Now let's go talk    
for briefly about something     

854
00:44:20,591 --> 00:44:23,459
that's not super important,     
but strings are in almost       

855
00:44:23,528 --> 00:44:26,028
every app. And I just wanna     
talk a little bit about how we  

856
00:44:26,097 --> 00:44:28,531
index in to strings,            
cuz it is not what you would    

857
00:44:28,599 --> 00:44:33,035
think it is at first glance.    
In addition to string,          

858
00:44:33,104 --> 00:44:36,572
the struct string, there's      
another struct in foundation    

859
00:44:36,641 --> 00:44:40,543
called character. Now,          
a character is what we humans   

860
00:44:40,611 --> 00:44:44,580
would perceive of as            
a character. On the screen or   

861
00:44:44,649 --> 00:44:49,519
whatever. However, a string is  
not a sequence. A string is     

862
00:44:49,587 --> 00:44:52,355
an underlying built with        
character, it's built with      

863
00:44:52,423 --> 00:44:56,659
unicodes. Okay, unicodes are    
just little bite size chunks    

864
00:44:56,728 --> 00:45:00,162
that can represent pretty much  
any language on earth. Okay,    

865
00:45:00,231 --> 00:45:02,631
it's international.             
You know, like ASCII.           

866
00:45:02,700 --> 00:45:05,501
We used to have ASCII, you      
can only really do English.     

867
00:45:05,569 --> 00:45:07,870
Unicodes do all All             
the languages on Earth.         

868
00:45:07,939 --> 00:45:10,773
So that's what's in a string.   
So we have a little bit         

869
00:45:10,841 --> 00:45:13,976
of trying to bridge the world   
between Unicodes and            

870
00:45:14,045 --> 00:45:17,212
characters. So let me           
show you by example here,       

871
00:45:17,281 --> 00:45:22,351
if we have the word cafe,       
C-A-F-E, right?                 

872
00:45:22,419 --> 00:45:25,054
That we perceive to have four   
characters, the C, the A,       

873
00:45:25,122 --> 00:45:27,290
the F, and the E with           
the accent on it. But           

874
00:45:27,358 --> 00:45:30,526
it might be represented by      
five Unicodes, because there's  

875
00:45:30,595 --> 00:45:33,162
a Unicode which is put          
an accent on the previous       

876
00:45:33,231 --> 00:45:38,434
character, okay, so, it could   
have five Unicodes. Well, So    

877
00:45:38,503 --> 00:45:41,704
how do we deal with this?       
Well, the main problem or       

878
00:45:41,772 --> 00:45:46,175
the main ramification           
of this is that string          

879
00:45:46,243 --> 00:45:50,980
cannot indexed by int.          
Because if we had a phrase,     

880
00:45:51,049 --> 00:45:54,449
cafe pesto, right there. One    
of my favorite pizza joints in  

881
00:45:54,518 --> 00:45:58,020
Hawaii, Cafe Pesto.             
The p is that in index 5 or     

882
00:45:58,088 --> 00:46:02,925
is that in index 6? It          
depends on whether that e is    

883
00:46:02,993 --> 00:46:07,029
an e with an accent or two      
Unicode here there's the e and  

884
00:46:07,097 --> 00:46:11,634
the accent. So ugh,             
what are we gonna do here? So   

885
00:46:11,702 --> 00:46:16,138
what we do is we don't          
index strings by int.           

886
00:46:16,207 --> 00:46:19,708
Instead strings are indexed     
by their own special type,      

887
00:46:19,777 --> 00:46:23,979
String.Index.                   
And that's the only way         

888
00:46:24,048 --> 00:46:26,215
to use subscripting             
on a String,                    

889
00:46:26,283 --> 00:46:30,285
you need a String.Index, not    
an Int. So this makes this,     

890
00:46:30,354 --> 00:46:33,022
people don't like this. They    
wanna index Strings by Int and  

891
00:46:33,090 --> 00:46:36,358
I understand why, but           
you can't do that. So           

892
00:46:36,427 --> 00:46:39,362
what does that mean? Well,      
we have to get an index, so     

893
00:46:39,430 --> 00:46:42,565
how do we get an index? Well,   
you can get the startIndex      

894
00:46:42,633 --> 00:46:45,834
of a string, you can get        
the endIndex of a string.       

895
00:46:45,903 --> 00:46:49,438
You can also use index(of:)     
a character to find the first   

896
00:46:49,506 --> 00:46:52,241
index of that character. So     
there's a bunch of different    

897
00:46:52,309 --> 00:46:55,144
methods and vars on             
strings to get an index.        

898
00:46:55,212 --> 00:46:58,814
Once you have an index in       
your hand, now you can offset   

899
00:46:58,883 --> 00:47:02,951
that index by an Int. So        
if you want to get the fourth   

900
00:47:03,020 --> 00:47:05,454
character in the string you     
have to get the startIndex and  

901
00:47:05,522 --> 00:47:08,323
then offset it by three to      
get to the fourth index, from   

902
00:47:08,392 --> 00:47:11,960
the first to the fourth. So it  
was let's get to the code that  

903
00:47:12,029 --> 00:47:14,597
makes that work. So here's my   
pizzaJoint cafe pesto here,     

904
00:47:14,665 --> 00:47:17,733
I'm gonna get the index of      
the first character by saying   

905
00:47:17,802 --> 00:47:20,769
pizzaJoint.startIndex that's    
not an Int.                     

906
00:47:20,838 --> 00:47:23,438
It's of type String.Index.      

907
00:47:23,507 --> 00:47:25,374
Now I'm gonna get the fourth    
character by taking             

908
00:47:25,443 --> 00:47:28,010
the first character and         
offsetting it by three.         

909
00:47:28,079 --> 00:47:29,444
Now I've got the index          
of the fourth character.        

910
00:47:29,513 --> 00:47:32,881
Now I'm gonna get the actual    
fourth character by using       

911
00:47:32,950 --> 00:47:36,952
subscripting. PizzaJoint,       
subscript, fourth character,    

912
00:47:37,021 --> 00:47:40,222
index, fourth character index   
of subtype String.index,        

913
00:47:40,290 --> 00:47:43,525
not of type int. And            
I can also do index (of:), so   

914
00:47:43,594 --> 00:47:46,695
here I'm gonna say              
The firstSpace character in     

915
00:47:46,764 --> 00:47:50,032
cafe pesto is                   
pizzaJoint.index(of: " ").      

916
00:47:50,101 --> 00:47:51,767
Now the reason I have           
to say if let there is,         

917
00:47:51,836 --> 00:47:53,836
of course, index(of: "          
") could return nil.            

918
00:47:53,904 --> 00:47:56,672
There might not be any          
spaces in pizzaJoint.           

919
00:47:56,740 --> 00:47:58,507
There happens to be but         
there might not be.             

920
00:47:58,575 --> 00:48:01,410
So it would return nil then.    
And so I'm doing if let Now,    

921
00:48:01,479 --> 00:48:03,412
I've got the index              
of that space.                  

922
00:48:03,480 --> 00:48:06,181
Now I'm going to get the index  
to the start of the second      

923
00:48:06,250 --> 00:48:08,417
word, the word pesto there.     
And                             

924
00:48:08,485 --> 00:48:12,054
we do it by indexing that       
first space over by one.        

925
00:48:12,123 --> 00:48:15,390
And I am gonna assume there is  
one space in between words,     

926
00:48:15,459 --> 00:48:18,593
go to the next one. And now, I  
am going to get the whole word  

927
00:48:18,662 --> 00:48:25,201
pesto by indexing string with   
a range, okay. The index        

928
00:48:25,269 --> 00:48:27,903
of a string doesn't have        
to be an individual index.      

929
00:48:27,972 --> 00:48:31,040
It could be a range of          
indexes. Now you notice to      

930
00:48:31,109 --> 00:48:35,511
make a range, I'm using         
exactly the same dot,           

931
00:48:35,580 --> 00:48:38,247
dot, less than thing that I     
did when I made that countable  

932
00:48:38,315 --> 00:48:42,585
range of INTs. Ranges are       
generic types. They don't have  

933
00:48:42,653 --> 00:48:45,787
to be of INTs. They can be      
a range of string.index.        

934
00:48:45,856 --> 00:48:50,325
Perfectly legal. As though we   
saw before, we had a range,     

935
00:48:50,394 --> 00:48:52,727
countable range, of double      
precision floating points.      

936
00:48:52,796 --> 00:48:55,196
Remember that at the beginning  
of the last lecture? So         

937
00:48:55,265 --> 00:48:58,767
range is generic type. So       

938
00:48:58,836 --> 00:49:02,738
it is perfectly legal to use a  
range inside subscripting, and  

939
00:49:02,806 --> 00:49:05,441
that's true anywhere there's    
subscripting of collections.    

940
00:49:07,011 --> 00:49:08,844
These methods,                  
by the way, these index,        

941
00:49:08,913 --> 00:49:11,646
offsetBy, those are not         
methods in string,              

942
00:49:11,715 --> 00:49:13,582
those are methods in            
collection. Okay,               

943
00:49:13,651 --> 00:49:15,284
the selection protocol,         
string may or                   

944
00:49:15,352 --> 00:49:18,087
may not implement it itself,    
it's up to the string.          

945
00:49:18,155 --> 00:49:21,156
The collection protocol is      
also generic, and so the index  

946
00:49:21,225 --> 00:49:25,160
you use in the collection       
is configurable. For            

947
00:49:25,229 --> 00:49:28,664
a string it's a string.index.   
By the way, another way         

948
00:49:28,733 --> 00:49:31,634
to get the second word, and     
probably what we would use, is  

949
00:49:31,702 --> 00:49:35,570
a more complicated method like  
component separated by. So      

950
00:49:35,639 --> 00:49:39,508
components separated by, is a   
collection method. You give it  

951
00:49:39,577 --> 00:49:42,979
an element that would be        
in that collection and          

952
00:49:43,047 --> 00:49:46,282
it will create an array         
with all the things,            

953
00:49:46,351 --> 00:49:48,751
all the elements in             
an array grouped and            

954
00:49:48,819 --> 00:49:52,588
separated by that thing. So     
this would give you an array    

955
00:49:52,656 --> 00:49:55,857
of all the words separated by   
a space. Then I would grab      

956
00:49:55,926 --> 00:49:59,294
index one, which would be       
the second word. Okay,          

957
00:49:59,363 --> 00:50:02,031
so I'm showing you how to do    
the indexing directly, but      

958
00:50:02,100 --> 00:50:04,000
a lot of times we use           
much higher level               

959
00:50:05,302 --> 00:50:09,871
things in string.               
Okay, so string,                

960
00:50:09,940 --> 00:50:14,109
like I say, is a collection of  
character. Just like an array   

961
00:50:14,178 --> 00:50:15,978
is a collection of              
arbitrary things,               

962
00:50:16,046 --> 00:50:19,214
accountable range of int is     
a collection of ints, and so    

963
00:50:19,283 --> 00:50:22,017
all that stuff is coming from   
collection. And collection is   

964
00:50:22,086 --> 00:50:24,686
a sequence we know, so          
of course you can do for        

965
00:50:24,755 --> 00:50:28,657
c and if s is a string c will   
be a tight character and you    

966
00:50:28,725 --> 00:50:31,460
can iterate with a four loop    
through all the characters.     

967
00:50:31,529 --> 00:50:34,930
There's also really cool        
initializer for array           

968
00:50:34,998 --> 00:50:39,067
that takes a sequence, as       
the argument. So you can say,   

969
00:50:39,136 --> 00:50:42,638
array of any sequence and what  
it will do is go through that   

970
00:50:42,706 --> 00:50:45,774
sequence and take each element  
and put it into the array.      

971
00:50:45,842 --> 00:50:47,209
So it creates a big array for   
you,                            

972
00:50:47,277 --> 00:50:48,978
cuz it's an array initializer.  
And                             

973
00:50:49,046 --> 00:50:52,214
in the array will be all the    
elements of the sequence. So    

974
00:50:52,283 --> 00:50:54,883
since a string is a sequence    
of characters, if you say       

975
00:50:54,952 --> 00:50:59,321
array of string, you'll get an  
array of its characters. And    

976
00:50:59,390 --> 00:51:03,592
now you can use int to index    
them if you want. So sometimes  

977
00:51:03,661 --> 00:51:06,194
people, they get tired of       
all this string index stuff.    

978
00:51:06,263 --> 00:51:08,229
They just create an array       
of the characters. And          

979
00:51:08,298 --> 00:51:11,967
then now they can use ints to   
get at the various characters.  

980
00:51:13,204 --> 00:51:16,071
That's kind of                  
a trick as well.                

981
00:51:16,140 --> 00:51:19,374
Ah, remember that a string is   
a value type, it's a struct,    

982
00:51:19,443 --> 00:51:22,177
we almost always use immutable  
strings like let s equal        

983
00:51:22,246 --> 00:51:24,213
something, we're working        
with it immutably,              

984
00:51:24,281 --> 00:51:26,781
but of course there             
are mutable versions, mutable   

985
00:51:26,850 --> 00:51:30,519
methods. There's another kind   
of protocol called range        

986
00:51:30,587 --> 00:51:33,121
replaceable collection. That's  
kind of a collections that      

987
00:51:33,190 --> 00:51:37,793
can be mutated. Ranges of the   
things can be replaced. And so  

988
00:51:37,862 --> 00:51:40,862
here's a method in that         
insert the contents of          

989
00:51:40,931 --> 00:51:45,233
a collection of characters,     
which string is, at an index,   

990
00:51:45,302 --> 00:51:47,336
so in this case it's            
index of space,                 

991
00:51:47,404 --> 00:51:49,871
that's gotta be                 
a string.index right there.     

992
00:51:49,940 --> 00:51:54,477
And so I can insert the word    
foo into Cafe Pastel. So        

993
00:51:54,545 --> 00:51:56,111
you can do this,                
we don't do this that much.     

994
00:51:56,180 --> 00:51:58,814
We tend to just use them        
immutably, and we use plus to   

995
00:51:58,882 --> 00:52:04,052
add them together and stuff     
like that. So that's string,    

996
00:52:04,121 --> 00:52:06,088
it's that little weirdness      
about the indexing.             

997
00:52:06,156 --> 00:52:09,858
Now, There are lots of other    
methods in string, I want to    

998
00:52:09,927 --> 00:52:11,427
show you an interesting         
thing about one of them.        

999
00:52:11,495 --> 00:52:16,265
So here is replace range,       
which, my pointer doesn't work  

1000
00:52:16,333 --> 00:52:18,133
any more, but                   
if you look at replace range,   

1001
00:52:18,201 --> 00:52:21,069
do you see where it's red,      
right there? That's that dot,   

1002
00:52:21,138 --> 00:52:23,905
dot less than thing, look,      
I forgot to put something on    

1003
00:52:23,974 --> 00:52:28,076
the left. So what does          
that range go from? Okay,       

1004
00:52:28,145 --> 00:52:31,613
we know it goes to s.endIndex.  
Well, Swift is smart enough to  

1005
00:52:31,682 --> 00:52:35,150
know that that is a range of    
str-, the strings indexes,      

1006
00:52:35,219 --> 00:52:38,854
so it will automatically put    
start index at the beginning.   

1007
00:52:38,923 --> 00:52:40,155
And if you left off             
the other side,                 

1008
00:52:40,224 --> 00:52:43,659
it will automatically put       
ending index at the end. So     

1009
00:52:43,728 --> 00:52:46,228
you can oh, leave those         
arranged things open ended.     

1010
00:52:46,297 --> 00:52:48,764
But Swift has to be able to     
infer the type of whats going   

1011
00:52:48,833 --> 00:52:50,065
on there. So                    
you can't always do it,         

1012
00:52:50,134 --> 00:52:53,702
but in that case you could.     
Okay, so                        

1013
00:52:53,771 --> 00:52:58,274
that's string. I guess          
we'll go like this. So, to      

1014
00:52:58,342 --> 00:53:02,611
make this all understandable    
let's go back to our,           

1015
00:53:02,679 --> 00:53:08,249
um, concentration.              
And we're gonna make this       

1016
00:53:08,318 --> 00:53:12,421
thing right here,               
this emoji choices,             

1017
00:53:12,489 --> 00:53:15,424
which is currently              
an array of emoji strings.      

1018
00:53:15,492 --> 00:53:17,759
I'm gonna change that. I'm      
gonna copy and paste it here.   

1019
00:53:17,828 --> 00:53:21,730
I'm gonna change it from being  
an array, to being a string.    

1020
00:53:21,799 --> 00:53:24,433
So I'm gonna take off           
the array things.               

1021
00:53:24,501 --> 00:53:29,304
And I'm gonna get rid of all    
of these little commas. And     

1022
00:53:29,373 --> 00:53:32,707
now emojiChoices is             
gonna be a string.              

1023
00:53:32,776 --> 00:53:35,577
And I'm gonna have              
my code be the same,            

1024
00:53:35,646 --> 00:53:38,179
but instead of grab it out of   
the array, it's gonna grab it   

1025
00:53:38,248 --> 00:53:41,250
out of the string. Now as soon  
as I change that to a string,   

1026
00:53:41,319 --> 00:53:44,853
look what happens.              
Cannot convert value of type    

1027
00:53:44,921 --> 00:53:49,625
int to expected argument,       
string.index. Okay, remove at,  

1028
00:53:49,694 --> 00:53:52,027
right here, which we moved      
to remove the thing,            

1029
00:53:52,095 --> 00:53:57,365
where do you think that's       
declared? Anyone wanna guess?   

1030
00:53:57,434 --> 00:54:02,437
Is that an array thing?         
A string? No,                   

1031
00:54:02,506 --> 00:54:04,973
that's in collection, range     
replaceable collection, right?  

1032
00:54:05,042 --> 00:54:07,142
So it's in a protocol           
somewhere that both string and  

1033
00:54:07,211 --> 00:54:07,976
array implement. So             

1034
00:54:08,045 --> 00:54:10,178
you would think it              
should just work here,          

1035
00:54:10,247 --> 00:54:13,315
because emoji choices, yeah,    
now it's a string, but remove   

1036
00:54:13,384 --> 00:54:15,884
at is in range replaceable      
collection, they're range       

1037
00:54:15,952 --> 00:54:18,454
replaceable collection.         
Why does this work? Well,       

1038
00:54:18,522 --> 00:54:21,823
because strings are not         
indexed by ints. And            

1039
00:54:21,892 --> 00:54:25,494
so this doesn't work. So we     
have to create a string.index,  

1040
00:54:25,562 --> 00:54:29,465
I'm gonna do that. I'm gonna    
create a random string index    

1041
00:54:29,533 --> 00:54:34,002
and I'm gonna do it by using    
that index offset by things.    

1042
00:54:34,070 --> 00:54:38,172
I'm gonna say, emojiChoices     
give me an index, I'm gonna     

1043
00:54:38,241 --> 00:54:41,276
use this first one right here,  
index offsetBy, which let's us  

1044
00:54:41,344 --> 00:54:44,446
take a known index and          
offset it by something else.    

1045
00:54:44,515 --> 00:54:47,716
The known index I'm going to    
start with is the start index   

1046
00:54:47,785 --> 00:54:51,219
of this thing, so,              
emojiChoices.startIndex, and    

1047
00:54:51,288 --> 00:54:54,989
I'm gonna offset by a random    
int. So that offset,            

1048
00:54:55,058 --> 00:54:58,627
that can be by an int.          
That happens to be because      

1049
00:54:58,696 --> 00:55:01,797
this particular collections     
strides, or the distance        

1050
00:55:01,865 --> 00:55:05,434
between indexes is an int.      
Even though the indexes         

1051
00:55:05,503 --> 00:55:08,503
themselves are string           
dot index. So I do that.        

1052
00:55:08,572 --> 00:55:11,273
So now I'm gonna put random     
string index in here and        

1053
00:55:11,341 --> 00:55:14,476
all should be well, right?      
Because remove at,              

1054
00:55:14,544 --> 00:55:17,979
oh no, still doesn't work.      
What's this error?              

1055
00:55:18,048 --> 00:55:23,451
Cannot assign value of          
type character to string.       

1056
00:55:23,520 --> 00:55:25,054
Okay, this is a dictionary,     
this is looking for             

1057
00:55:25,122 --> 00:55:29,124
strings. Okay?                  
Why is this a character? Well,  

1058
00:55:29,192 --> 00:55:32,894
because a string is             
a collection of character. So   

1059
00:55:32,963 --> 00:55:37,565
if remove at, I'm removing a    
character. So no problem here,  

1060
00:55:37,634 --> 00:55:40,168
we know that we can             
probably convert types. And     

1061
00:55:40,237 --> 00:55:42,704
we're gonna do that by using    
a string initializer that       

1062
00:55:42,773 --> 00:55:44,606
takes a character               
as an argument and              

1063
00:55:44,675 --> 00:55:47,409
returns a string with just      
that character in it. So now    

1064
00:55:47,478 --> 00:55:51,313
we converted it. So, that's     
it. That's all we need to do.   

1065
00:55:51,381 --> 00:55:55,684
And I did this just so you can  
see all that offsetBy, and      

1066
00:55:55,752 --> 00:55:57,653
all that stuff so you could     
see how we would index this     

1067
00:55:57,721 --> 00:56:00,121
into a string instead of        
doing here. So, hopefully       

1068
00:56:00,190 --> 00:56:02,991
this is still working. Yes,     
it is. It's still working.      

1069
00:56:04,261 --> 00:56:09,397
Okay? Got it everybody?         
Questions about this? So        

1070
00:56:09,466 --> 00:56:11,767
this is the important line      
of coding in here. And          

1071
00:56:11,835 --> 00:56:14,102
also a little bit of            
understanding that even though  

1072
00:56:14,170 --> 00:56:17,973
remove at is in collection      
range, replaceable collection,  

1073
00:56:18,042 --> 00:56:21,075
the types matter,               
because it's a generic type.    

1074
00:56:21,144 --> 00:56:25,347
Collection is a generically     
typed protocol. All right,      

1075
00:56:25,416 --> 00:56:29,251
let's go back. Oops,            
not there. Here, no. Here.      

1076
00:56:29,319 --> 00:56:33,755
All right, let's talk about     
another class that has          

1077
00:56:33,823 --> 00:56:37,425
to do with Strings which        
is NSAttributedString. For      

1078
00:56:37,494 --> 00:56:41,429
NSAttributedString is           
a String that every character   

1079
00:56:41,498 --> 00:56:43,765
has a little dictionary         
associated with it. And         

1080
00:56:43,834 --> 00:56:46,067
that Dictionary can have        
lots of little keys and         

1081
00:56:46,136 --> 00:56:50,471
values that say how to draw     
that character on screen.       

1082
00:56:50,540 --> 00:56:53,741
Okay so those Dictionaries can  
have things like font, color,   

1083
00:56:53,810 --> 00:56:57,179
all these things. Okay that's   
what an attributed string is,   

1084
00:56:57,247 --> 00:57:00,249
right? A String with            
attributes of each character,   

1085
00:57:00,317 --> 00:57:04,652
right? The Dictionary that      
each character can have.        

1086
00:57:04,721 --> 00:57:06,354
The keys are well known,        

1087
00:57:06,423 --> 00:57:08,256
you can look them up            
in the documentation.           

1088
00:57:08,325 --> 00:57:12,260
The values depend on            
the type of thing, so           

1089
00:57:12,328 --> 00:57:14,796
sometimes the values are UI     
font, which is a font thing,    

1090
00:57:14,865 --> 00:57:15,998
sometimes the values            
are colors,                     

1091
00:57:16,066 --> 00:57:19,267
sometimes they're floating      
point numbers, etcetera.        

1092
00:57:19,336 --> 00:57:23,471
Now a lot of times, we use the  
same Dictionary for big long    

1093
00:57:23,540 --> 00:57:27,342
ranges of characters, right?    
You know like if users select   

1094
00:57:27,411 --> 00:57:30,478
some text on screen and they    
say make it orange, then we're  

1095
00:57:30,547 --> 00:57:33,215
gonna have one Dictionary for   
all those characters so not     

1096
00:57:33,283 --> 00:57:36,618
like every character has to     
have a different Dictionary.    

1097
00:57:36,686 --> 00:57:37,919
And in your homework,           

1098
00:57:37,988 --> 00:57:40,856
the entire String is going      
to have one Dictionary. So      

1099
00:57:40,924 --> 00:57:43,758
I've given you a really easy    
use of attributed String and    

1100
00:57:43,827 --> 00:57:47,629
you're gonna see why I did      
that in a moment here.          

1101
00:57:47,698 --> 00:57:50,398
Once you have an Attributed     
String with all those font and  

1102
00:57:50,467 --> 00:57:51,700
color for each character,       

1103
00:57:51,769 --> 00:57:55,604
now you can use to it to set    
the text in UI label, or        

1104
00:57:55,672 --> 00:57:58,539
to set the title of             
a UIButton. Or next week we're  

1105
00:57:58,608 --> 00:58:01,209
going to learn how to draw it   
directly on-screen, in our own  

1106
00:58:01,278 --> 00:58:06,214
drawing classes. Okay?          
Here's how you create and       

1107
00:58:06,283 --> 00:58:08,383
use an AttributedString,        
and it's got red.               

1108
00:58:08,451 --> 00:58:10,919
Any time you see red on my      
slides, it's kind of like oh,   

1109
00:58:10,988 --> 00:58:15,123
look out. And this is red       
because it's really weird.      

1110
00:58:15,192 --> 00:58:18,426
Okay? And why is this really    
weird? Well, it's really weird  

1111
00:58:18,495 --> 00:58:22,263
cuz this is an Objective-C API  
that's trying to live           

1112
00:58:22,332 --> 00:58:25,166
in the Swift world, and         
that requires a little bit of   

1113
00:58:25,235 --> 00:58:27,602
compromise. There's not         
a lot of APIs like this.        

1114
00:58:27,671 --> 00:58:30,372
Every time iOS comes out, the   
next one I always hope there    

1115
00:58:30,441 --> 00:58:33,174
can have                        
Non NSAttributedString, just    

1116
00:58:33,243 --> 00:58:36,445
regular AttributedString would  
now fix this, but they haven't  

1117
00:58:36,513 --> 00:58:39,214
done it yet. So, when you're    
declaring those attributes,     

1118
00:58:39,282 --> 00:58:41,482
the little Dictionary that      
goes on each character,         

1119
00:58:41,551 --> 00:58:43,919
you have to give it             
an explicit type.               

1120
00:58:43,988 --> 00:58:45,920
You cannot let the type         
be inferred and                 

1121
00:58:45,989 --> 00:58:48,289
that's because those            
values could be font,           

1122
00:58:48,358 --> 00:58:50,959
colors, whatever. So, a source  
can't infer what the value of   

1123
00:58:51,028 --> 00:58:53,795
the Dictionary is. So they      
type that you're gonna use      

1124
00:58:53,864 --> 00:58:56,965
here is Keys                    
are NSAttributedString key.     

1125
00:58:57,033 --> 00:58:59,134
And you can just look that      
up in the documentation,        

1126
00:58:59,203 --> 00:59:02,470
see what the choices are. It's  
things like font, underline,    

1127
00:59:02,539 --> 00:59:04,840
strike through, all the things  
you would think to be.          

1128
00:59:04,908 --> 00:59:08,876
And then the value is Any.      
Okay, so                        

1129
00:59:08,945 --> 00:59:12,413
Any is a special Swift          
thing that means                

1130
00:59:12,482 --> 00:59:15,083
anything can go here, any       
struct, any class, any type.    

1131
00:59:15,152 --> 00:59:17,652
So this is very non Swift       
cuz Swift is strongly           

1132
00:59:17,721 --> 00:59:20,621
typed, and                      
here's there's no type. So      

1133
00:59:20,690 --> 00:59:24,792
you would never have an API     
like this in Swift. Okay,       

1134
00:59:24,861 --> 00:59:27,295
if this weren't an Objective-C  
API brought forward, so         

1135
00:59:27,364 --> 00:59:28,396
you would never have it.        

1136
00:59:28,465 --> 00:59:30,232
Can anyone think of what        
we would have instead of        

1137
00:59:30,300 --> 00:59:33,268
any right there? Why type       
of thing instead of any?        

1138
00:59:35,472 --> 00:59:39,808
How about an enum with          
associated values? Right?       

1139
00:59:39,877 --> 00:59:43,077
If you had an enum, and one of  
the enum things is the font,    

1140
00:59:43,146 --> 00:59:45,113
then the associated             
value could be a font.          

1141
00:59:45,182 --> 00:59:47,815
Or what if the thing was        
the color of the text?          

1142
00:59:47,884 --> 00:59:49,050
Then the associated             
value could                     

1143
00:59:49,119 --> 00:59:51,553
be a UI color, you see? How we  
would do that in Swift? Well,   

1144
00:59:51,621 --> 00:59:54,723
we didn't have those enums      
when Objective-C did this so,   

1145
00:59:54,792 --> 00:59:56,657
we're stuck with Any. Okay?     

1146
00:59:56,726 --> 01:00:00,895
Never use any in your data      
structures. Any is purely so    

1147
01:00:00,964 --> 01:00:05,567
we can deal with these old      
Objective-C things. Alright,    

1148
01:00:05,635 --> 01:00:08,870
so, now that I have declared    
the type to be a dictionary     

1149
01:00:08,939 --> 01:00:12,874
with NSAttributeString keys     
with Any as the value, then I   

1150
01:00:12,943 --> 01:00:16,511
can make my dictionary and      
so StrokeColor is obviously     

1151
01:00:16,579 --> 01:00:19,648
the color that it strokes       
the outside of the text.        

1152
01:00:19,716 --> 01:00:22,050
There's also foreground color   
which is the color it puts      

1153
01:00:22,119 --> 01:00:25,921
the inside of the text,         
the fill color. There's also    

1154
01:00:25,989 --> 01:00:28,756
background color which is like  
if you had a highlighter,       

1155
01:00:28,825 --> 01:00:32,059
that's the background of it.    
There's also StrokeWidth.       

1156
01:00:32,128 --> 01:00:33,961
StrokeWidth, if it's            
a positive number,              

1157
01:00:34,030 --> 01:00:38,867
it outlines. Okay? If it's      
a negative number its solid.    

1158
01:00:38,936 --> 01:00:41,870
The character is solid. Okay?   
You'll see that. We're going    

1159
01:00:41,939 --> 01:00:44,505
to do a demo of that. Okay? So  
you can do this. You can put    

1160
01:00:44,574 --> 01:00:47,142
these things in here for your   
homework. You'll use stroke,    

1161
01:00:47,210 --> 01:00:50,479
color stroke with maybe a       
couple others. In the hints I   

1162
01:00:50,547 --> 01:00:52,047
kind of tell you the things     
you need to use.                

1163
01:00:52,115 --> 01:00:54,515
So, I don't want you wasting    
too much time looking up all    

1164
01:00:54,584 --> 01:00:57,652
these things. Then you can      
created an attributed string    

1165
01:00:57,721 --> 01:01:00,822
with that Dictionary for        
all the cards in the string by  

1166
01:01:00,891 --> 01:01:03,491
just saying NSAttributedString  
using the initialize of         

1167
01:01:03,560 --> 01:01:07,028
the text of string and the      
attributes. So that creates     

1168
01:01:07,097 --> 01:01:09,430
an attributed string then       
I can take that attributed      

1169
01:01:09,499 --> 01:01:12,901
string and like put it on       
my flipCountLabel, right?       

1170
01:01:12,969 --> 01:01:15,470
Now my flipCountLabel, so       
this particular ones since I'm  

1171
01:01:15,539 --> 01:01:19,107
using a positive stroke width   
this would be outlined text.    

1172
01:01:19,175 --> 01:01:20,708
On my flip count.               
So I'm gonna do a demo and      

1173
01:01:20,777 --> 01:01:23,277
see what that looks             
like in a second here.          

1174
01:01:23,346 --> 01:01:25,380
I just briefly want to talk     
about the peculiarities of      

1175
01:01:25,449 --> 01:01:27,716
NSAttributed strings            
since there's an NS.            

1176
01:01:27,784 --> 01:01:29,551
You know, you see that NS at    
the beginning and you know,     

1177
01:01:29,619 --> 01:01:32,654
hmm, this is kinda              
of an older API.                

1178
01:01:32,722 --> 01:01:36,124
It's not a String. It's a       
totally different thing, okay.  

1179
01:01:36,192 --> 01:01:37,992
An NSAttributedString is        
a class that's completely       

1180
01:01:38,061 --> 01:01:41,796
different. Then String worked   
completely differently.         

1181
01:01:41,864 --> 01:01:44,332
Because it's a class            
not a struct,                   

1182
01:01:44,401 --> 01:01:47,468
you can't make a mutable        
one by just using var.          

1183
01:01:47,537 --> 01:01:49,670
You actually have to            
use a different class.          

1184
01:01:49,739 --> 01:01:52,074
And it's mutable Attributable   
String. If you actually         

1185
01:01:52,142 --> 01:01:54,342
wanted to go set                
the dictionaries on certain     

1186
01:01:54,410 --> 01:01:57,345
characters individually, you    
would need to use a mutable     

1187
01:01:57,414 --> 01:02:00,048
Attributable String,            
a completely different class    

1188
01:02:00,116 --> 01:02:03,151
there. Also NSAttributedString  
was built and                   

1189
01:02:03,220 --> 01:02:07,088
constructed internally with     
NSString in mind. NSString is   

1190
01:02:07,157 --> 01:02:10,892
the old Objective-C String.     
NSString and String have        

1191
01:02:10,961 --> 01:02:14,262
a little different Unicode and  
coding underneath. So,          

1192
01:02:14,331 --> 01:02:18,032
when you have wacky characters  
like emoji or cafe in there,    

1193
01:02:18,101 --> 01:02:21,703
the indexes into them might     
not quite match up. And         

1194
01:02:21,771 --> 01:02:24,873
there's automatic bridging      
between string and NSString so  

1195
01:02:24,942 --> 01:02:27,175
if you have any iOS API         
that takes an NSString          

1196
01:02:27,243 --> 01:02:29,477
as an argument,                 
you can just pass a string.     

1197
01:02:29,546 --> 01:02:32,114
It just automatically           
works except,                   

1198
01:02:32,182 --> 01:02:34,415
that this little encoding       
doesn't always get              

1199
01:02:34,484 --> 01:02:39,020
fixed up quite right so the     
bottom line here is if you're   

1200
01:02:39,089 --> 01:02:42,057
going to be trying to be index  
into an NSAttibutedString and   

1201
01:02:42,125 --> 01:02:46,194
you have wacky characters like  
emoji or cafe, the indexes      

1202
01:02:46,263 --> 01:02:49,330
might not line up very well.    
Now in your homework you don't  

1203
01:02:49,399 --> 01:02:50,932
have to worry about any of      
that cuz I'm only gonna ask     

1204
01:02:51,001 --> 01:02:53,868
you to make the entire String   
have the attributes. So         

1205
01:02:53,937 --> 01:02:56,538
you're not even doing           
any indexing into there.        

1206
01:02:56,606 --> 01:02:58,873
But in the future, if you're    
ever using AttributedString,    

1207
01:02:58,941 --> 01:02:59,674
just be careful about           

1208
01:02:59,743 --> 01:03:02,043
the indexing in there if        
you've got wacky characters.    

1209
01:03:02,112 --> 01:03:07,282
All right, the demo. So,        
I'm gonna do this flip count    

1210
01:03:07,350 --> 01:03:11,353
thing and show you what this    
looks like real quick here.     

1211
01:03:13,023 --> 01:03:14,555
Where do we do that?            
That's right up here,           

1212
01:03:14,624 --> 01:03:17,091
right? Here's where we set      
our flipCountLabel to Flips:    

1213
01:03:17,160 --> 01:03:19,794
\(flipCount). So I'm going to   
put attributed text there. So   

1214
01:03:19,863 --> 01:03:22,430
I'm going to let my             
attributes, which I have to     

1215
01:03:22,498 --> 01:03:29,671
type to be                      
[NSAttributedStringKey:         

1216
01:03:29,740 --> 01:03:34,642
Any] =. And now I can just      
put the things I want, so       

1217
01:03:34,711 --> 01:03:40,415
I want the StrokeWidth          
to be 5.0.                      

1218
01:03:40,483 --> 01:03:44,552
Okay, that's a fairly           
thick stroking width.           

1219
01:03:44,621 --> 01:03:47,055
And then what was the other     
thing I said I wanted to, oh,   

1220
01:03:47,124 --> 01:03:50,692
the color. So the strokeColor   
and I'll go ahead and           

1221
01:03:50,761 --> 01:03:54,195
use the color literal here.     
Use our favorite color,         

1222
01:03:54,264 --> 01:03:59,000
which is orange.                
Halloween color. Okay,          

1223
01:03:59,069 --> 01:04:02,403
so now if I wanna use these     
attributes to draw the text on  

1224
01:04:02,472 --> 01:04:05,039
my label, I'm just gonna        
create an attributedString.     

1225
01:04:05,108 --> 01:04:08,710
So I'm gonna say,               
let attributedString equal. By  

1226
01:04:08,778 --> 01:04:11,412
creating an attributedString    
with its constructor,           

1227
01:04:11,481 --> 01:04:13,414
I want the one down             
here at the bottom.             

1228
01:04:13,483 --> 01:04:15,816
It takes attributes and         
string. Okay, so                

1229
01:04:15,885 --> 01:04:18,352
what you're gonna do for your   
Homework-2. I put the string,   

1230
01:04:18,421 --> 01:04:22,356
it's just this string           
right here. And                 

1231
01:04:22,425 --> 01:04:26,627
attributes is these attributes  
I just created up there. And    

1232
01:04:26,696 --> 01:04:29,564
then instead of saying          
flipCountLabel.text,            

1233
01:04:29,633 --> 01:04:33,335
I say attributedText. And for   
a button, you would say set     

1234
01:04:33,403 --> 01:04:36,838
attributedTitle for             
state instead of setTitle for   

1235
01:04:36,906 --> 01:04:40,141
state and that equals           
this attributedString.          

1236
01:04:40,209 --> 01:04:43,945
Okay, so that's all you need    
to do. So let's run this and    

1237
01:04:44,013 --> 01:04:46,581
we're gonna see something       
a little bit kind of odd about  

1238
01:04:46,650 --> 01:04:51,052
this, though. A little          
bit unexpected, I think.        

1239
01:04:51,121 --> 01:04:54,522
So here we go. Hey, it didn't   
draw anything different.        

1240
01:04:54,591 --> 01:04:55,823
Look at that, Flips: 0.         

1241
01:04:55,892 --> 01:04:58,893
That looks exactly like         
before we made this change.     

1242
01:04:58,962 --> 01:05:03,497
But, oh, look, if I click, now  
I'm getting the outlined font.  

1243
01:05:03,566 --> 01:05:05,833
See how it's                    
outlining my Flips?             

1244
01:05:05,902 --> 01:05:10,338
So why when it first came up    
didn't this work, right here?   

1245
01:05:12,709 --> 01:05:15,843
Yeah because this right here,   
this little =0,                 

1246
01:05:15,912 --> 01:05:19,414
this initialization, that       
does not cause the didSet to    

1247
01:05:19,483 --> 01:05:22,650
happen. Okay, so that's         
an important thing to know.     

1248
01:05:22,718 --> 01:05:26,554
When you initialize a var,      
it does not invoke the didSet,  

1249
01:05:26,623 --> 01:05:30,525
only later settings             
of flipCount. So                

1250
01:05:30,593 --> 01:05:32,693
how can we fix this?            
Well, I'm gonna take this and   

1251
01:05:32,762 --> 01:05:37,265
put it in it's own little       
func. Okay, private func,       

1252
01:05:37,334 --> 01:05:43,471
I'm gonna call it               
updateFlipCountLabel.           

1253
01:05:43,540 --> 01:05:45,006
I'm gonna put that in there,    
and                             

1254
01:05:45,074 --> 01:05:47,441
I'm gonna call this             
updateFlipCountLabel in here.   

1255
01:05:47,510 --> 01:05:49,176
updateFlipCountLabel, and       

1256
01:05:49,245 --> 01:05:52,814
where's the other place I need  
to update the FlipCountLabel?   

1257
01:05:52,882 --> 01:05:56,217
Well, here's another thing to   
learn that's kind of cool.      

1258
01:05:56,286 --> 01:05:58,653
This, right here,               
is the label, right?            

1259
01:05:58,721 --> 01:06:03,991
If you remember in our UI over  
here, that this right here      

1260
01:06:04,060 --> 01:06:09,330
is connected up to that,        
right, it's connected. Now,     

1261
01:06:09,399 --> 01:06:12,767
this connection gets made by    
iOS when you start up your UI,  

1262
01:06:12,836 --> 01:06:14,869
right, it makes                 
that connection.                

1263
01:06:14,938 --> 01:06:19,473
Well, when it makes that        
connection, it's setting this.  

1264
01:06:19,542 --> 01:06:24,745
So guess what,                  
we can use didSet here.         

1265
01:06:24,814 --> 01:06:26,648
When you have an outlet,        

1266
01:06:26,716 --> 01:06:30,885
didSet does get called when     
that outlet gets set by iOS,    

1267
01:06:30,954 --> 01:06:34,955
when this connection right      
here gets made, that gets       

1268
01:06:35,024 --> 01:06:39,693
called. So here we can update   
our flipCountLabel here. Okay,  

1269
01:06:39,762 --> 01:06:43,697
so now that flipCountLabel is   
gonna be updated when we first  

1270
01:06:43,766 --> 01:06:47,268
connect that flip zero and      
also every time we change it    

1271
01:06:47,337 --> 01:06:52,974
after that. Got it? All right,  
back to our slides. So,         

1272
01:06:53,043 --> 01:06:55,843
you learned two things there,   
right? You learned that that    

1273
01:06:55,912 --> 01:06:59,280
equal zero didn't cause didSet  
to happen and you learned that  

1274
01:06:59,348 --> 01:07:02,449
on an outlet, you can didSet.   
You can set things because      

1275
01:07:02,518 --> 01:07:04,652
that outlet just got            
hooked up for you.              

1276
01:07:04,721 --> 01:07:08,022
All right, last really, really  
important thing here. We need   

1277
01:07:08,090 --> 01:07:09,724
to really rush, because         
we're running out of time.      

1278
01:07:09,792 --> 01:07:12,994
This is very important, this    
is about functions as types.    

1279
01:07:13,062 --> 01:07:16,097
So I believe the supreme court  
a couple of years ago that      

1280
01:07:16,165 --> 01:07:19,667
functions are people too.       
And so functions get the full   

1281
01:07:19,735 --> 01:07:22,236
treatment of a type that        
any other type gets.            

1282
01:07:22,305 --> 01:07:25,039
You can use a function as a     
type anywhere, all right? And   

1283
01:07:25,107 --> 01:07:28,009
you do it just by declaring     
an argument to a function or    

1284
01:07:28,078 --> 01:07:30,378
a var, whatever,                
to be of type function.         

1285
01:07:30,446 --> 01:07:31,645
And you specify                 
the arguments and               

1286
01:07:31,714 --> 01:07:33,147
the return value of             
that function. So               

1287
01:07:33,215 --> 01:07:35,883
it'll be a variable of that.    
So you can do this anywhere     

1288
01:07:35,952 --> 01:07:38,853
a type is allowed. Let's look   
at an example. I have a var     

1289
01:07:38,921 --> 01:07:43,390
here called operation. It is    
of type function that takes     

1290
01:07:43,459 --> 01:07:47,862
a double and returns a double.  
So the syntax here is awesome.  

1291
01:07:47,931 --> 01:07:50,999
It looks just like declaring    
a function that takes a double  

1292
01:07:51,067 --> 01:07:54,302
and return it, just no names    
of arguments, but the types     

1293
01:07:54,370 --> 01:07:58,572
are all in there. So this is    
how you declare a function.     

1294
01:07:58,641 --> 01:08:00,375
You declare a var               
that is a function.             

1295
01:08:00,443 --> 01:08:02,911
You can do it for variables,    
passing to functions,           

1296
01:08:02,979 --> 01:08:06,113
parameters, everything.         
You can always do this. So      

1297
01:08:06,182 --> 01:08:09,917
you can assign this var, it's   
exactly like you would think.   

1298
01:08:09,986 --> 01:08:12,853
I'm gonna assign                
operation = sqrt. Okay,         

1299
01:08:12,922 --> 01:08:16,724
sqrt is a function that takes   
a double and returns a double.  

1300
01:08:16,792 --> 01:08:20,161
So it's perfectly legal for     
me to say operation = sqrt,     

1301
01:08:20,230 --> 01:08:24,198
all right? And how do I call    
it? Well, I call it just like   

1302
01:08:24,266 --> 01:08:27,969
a function. Operation of 4.0    
is gonna call, in this case,    

1303
01:08:28,037 --> 01:08:31,872
square root of 4.0, because     
operation is a function var,    

1304
01:08:31,941 --> 01:08:33,974
that's holding a functioning.   

1305
01:08:34,043 --> 01:08:37,144
That function is square root,   
okay. Could not be simpler.     

1306
01:08:37,213 --> 01:08:40,114
Everybody cool with this? Now,  
other languages have function   

1307
01:08:40,182 --> 01:08:43,017
pointers and all this stuff,    
but it's all pretty tortuous    

1308
01:08:43,086 --> 01:08:46,020
to use. But in Swift, it's      
a first class citizen, okay.    

1309
01:08:46,089 --> 01:08:47,355
Functions are a first           
class citizen.                  

1310
01:08:47,424 --> 01:08:50,358
They will be the argument       
to many iOS methods,            

1311
01:08:50,426 --> 01:08:53,628
functions will be.              
Okay, now a lot of times,       

1312
01:08:53,696 --> 01:08:57,665
the function you wanna past     
doesn't already exist.          

1313
01:08:57,734 --> 01:09:00,701
So forces you to go write       
a function to pass in. For      

1314
01:09:00,770 --> 01:09:04,639
example, let's say I had the    
function changeSign, okay. So   

1315
01:09:04,707 --> 01:09:07,942
there's no thing like square    
root that does change signs.    

1316
01:09:08,010 --> 01:09:10,878
So I have to write a really     
simple little function here,    

1317
01:09:10,946 --> 01:09:11,896
And all it does, it takes       
a double and returns a double,  

1318
01:09:11,897 --> 01:09:12,847
changeSign.                     

1319
01:09:12,915 --> 01:09:15,983
just like square root. And      
it returns minus the operand.   

1320
01:09:16,051 --> 01:09:19,020
So I'm changing the sign of     
the operand here. So I could    

1321
01:09:19,088 --> 01:09:21,588
use it in the same way. I've    
got an operation. I'll just     

1322
01:09:21,657 --> 01:09:24,358
say operation = changeSign      
instead of operation = sqrt.    

1323
01:09:24,427 --> 01:09:26,527
But this is kind of             
a lot of typing and             

1324
01:09:26,596 --> 01:09:29,630
annoyance to have to go         
create a whole function to do   

1325
01:09:29,699 --> 01:09:33,300
changeSign when all I want is   
for that thing to change sign.  

1326
01:09:33,369 --> 01:09:35,703
So we can do,                   
use what's called a closure.    

1327
01:09:35,772 --> 01:09:37,738
How many people have            
heard the phrase closure,       

1328
01:09:37,807 --> 01:09:39,307
know what a closure is?         

1329
01:09:39,375 --> 01:09:43,577
Okay, about half of you again.  
Okay, so closure is really      

1330
01:09:43,646 --> 01:09:46,580
like an inlined function. It's  
a little special in that it     

1331
01:09:46,649 --> 01:09:49,784
captures the state around it    
but it's essentially an inline  

1332
01:09:49,852 --> 01:09:52,620
function. So what does the      
syntax look like if we wanted   

1333
01:09:52,689 --> 01:09:55,522
to take changeSign and just     
drop it right into the middle   

1334
01:09:55,591 --> 01:09:58,192
here instead of having          
a separate function? Okay,      

1335
01:09:58,261 --> 01:10:00,061
how would we do that?           
All right,                      

1336
01:10:00,130 --> 01:10:02,830
we're just gonna pick up all    
of changeSign except for        

1337
01:10:02,899 --> 01:10:04,365
its name and move it down.      

1338
01:10:04,433 --> 01:10:07,635
Watch, okay, so I just put      
it right in there. Now I        

1339
01:10:07,704 --> 01:10:11,072
do have to make one syntactic   
change here, very important.    

1340
01:10:11,141 --> 01:10:14,275
I have to move that first       
curly brace, the one right      

1341
01:10:14,344 --> 01:10:17,345
before the word return. I had   
to move it to beginning and     

1342
01:10:17,413 --> 01:10:20,948
replace it with the word in,    
so watch this happen.           

1343
01:10:21,017 --> 01:10:24,318
This moves to the front, put    
the word in. That's it though.  

1344
01:10:24,387 --> 01:10:27,654
Once you make that small        
syntactic change, you can drop  

1345
01:10:27,723 --> 01:10:31,359
any function right in there.    
But it gets much better on      

1346
01:10:31,427 --> 01:10:35,629
this because we have type       
inference in Swift. And Swift   

1347
01:10:35,698 --> 01:10:39,734
can absolutely go to town here  
because it knows a lot about    

1348
01:10:39,802 --> 01:10:44,138
what's going on here. For       
example, Swift knows that this  

1349
01:10:44,207 --> 01:10:47,775
operation thing returns         
a double. It knows that, so     

1350
01:10:47,843 --> 01:10:50,645
you don't need to say returns   
double there, so just take      

1351
01:10:50,713 --> 01:10:54,849
that out. it also knows that    
the operand is a double, so     

1352
01:10:54,918 --> 01:10:58,052
you don't need to say that      
that operand is a double,       

1353
01:10:58,121 --> 01:11:00,454
you can take that out, right?   

1354
01:11:00,523 --> 01:11:03,224
It also knows that this         
function returns something, so  

1355
01:11:03,292 --> 01:11:07,595
you don't need the keyword      
return minus operand there. So  

1356
01:11:07,663 --> 01:11:10,698
we can take that out as well.   
Okay, and even more,            

1357
01:11:10,766 --> 01:11:13,835
Swift knows you want to have    
these embedded functions all    

1358
01:11:13,903 --> 01:11:16,938
the time, and it's a little     
annoying to have to think up    

1359
01:11:17,006 --> 01:11:19,740
a name for the argument         
to this thing. Okay, that       

1360
01:11:19,808 --> 01:11:23,210
operand word that I had to      
think up there. So it lets you  

1361
01:11:23,279 --> 01:11:27,681
substitute $0 for the first     
one, $1 for the second, $3 for  

1362
01:11:27,750 --> 01:11:32,920
the third one. So I'm gonna     
replace operand there with $0.  

1363
01:11:32,988 --> 01:11:35,556
And when I do that, I don't     
need the in anymore either.     

1364
01:11:38,461 --> 01:11:42,096
Now you see the power           
of the closure. Okay,           

1365
01:11:42,165 --> 01:11:45,265
I wanted to have an operation   
that changes the sign.          

1366
01:11:45,334 --> 01:11:47,868
And I barely had to type        
any more characters than        

1367
01:11:47,937 --> 01:11:52,973
the changeSign, just the curly  
braces around it. And that's    

1368
01:11:53,042 --> 01:11:56,911
still gonna do, operation 4.0   
is still gonna do -4.0. Okay,   

1369
01:11:56,979 --> 01:11:59,380
so you're gonna be using        
closures all the time, and      

1370
01:11:59,449 --> 01:12:01,949
you're gonna be using           
these $0, 1, $1, $2,            

1371
01:12:02,017 --> 01:12:04,552
as the argument names. And      
it's gonna make it so that you  

1372
01:12:04,620 --> 01:12:07,187
have to type very little        
code to put the things in.      

1373
01:12:07,256 --> 01:12:09,990
Now why do I want closures,     
why do I want functions as      

1374
01:12:10,059 --> 01:12:12,626
arguments? Well,                
it's usually because you,       

1375
01:12:12,695 --> 01:12:15,196
you're passing something to     
a function that wants to know   

1376
01:12:15,264 --> 01:12:18,365
what to do. A function is       
a great way to tell it what to  

1377
01:12:18,434 --> 01:12:21,335
do. Now why might it want       
to know what to do? Well,       

1378
01:12:21,404 --> 01:12:24,638
maybe it wants to know what     
to do if there's an error.      

1379
01:12:24,707 --> 01:12:27,541
I'm gonna do something, it      
might generate an error, and    

1380
01:12:27,610 --> 01:12:30,110
I want to call a function       
in case there's an error so     

1381
01:12:30,179 --> 01:12:33,080
you can handle this function.   
Maybe it wants to know what to  

1382
01:12:33,149 --> 01:12:35,382
do if it's gonna do something   
that takes a long time.         

1383
01:12:35,451 --> 01:12:37,184
It's gonna go on                
the network and                 

1384
01:12:37,253 --> 01:12:40,754
download something off in the   
background and when it's done,  

1385
01:12:40,823 --> 01:12:44,525
it wants to tell you. Okay,     
we call a function to do that.  

1386
01:12:44,594 --> 01:12:47,060
Another thing is, it might be   
doing something repeatedly,     

1387
01:12:47,129 --> 01:12:49,997
it wants to do the same thing   
over and over. So it's asking   

1388
01:12:50,066 --> 01:12:53,100
you to tell it what to do over  
and over. So let's take a look  

1389
01:12:53,169 --> 01:12:55,937
at an example of that last one  
there, doing something over     

1390
01:12:56,005 --> 01:13:00,074
and over. So array,             
naturally, it's a collection.   

1391
01:13:00,143 --> 01:13:04,378
Well anyway, array has          
a method called map. And        

1392
01:13:04,447 --> 01:13:08,816
what map does, it takes only    
one argument, a function. And   

1393
01:13:08,885 --> 01:13:12,586
it applies that function to     
every element in the array and  

1394
01:13:12,655 --> 01:13:15,088
creates a new array. So         

1395
01:13:15,157 --> 01:13:19,160
map returns a new array where   
every element in the array you  

1396
01:13:19,228 --> 01:13:21,995
send it to gets operated        
on by some function.            

1397
01:13:22,064 --> 01:13:24,131
In other words, it's a way to   
pass a function into array and  

1398
01:13:24,200 --> 01:13:26,534
tell it to do it on             
every element. Okay,            

1399
01:13:26,602 --> 01:13:29,370
that's what map does, so how    
does that work? Here I have     

1400
01:13:29,439 --> 01:13:32,673
an array of floating point      
numbers. They happen to be      

1401
01:13:32,742 --> 01:13:35,910
the first 5 prime numbers,      
right, 2, 3, 5, 7, 11 here.     

1402
01:13:35,978 --> 01:13:39,714
And what if I wanted to have    
an array of all negative 2,     

1403
01:13:39,782 --> 01:13:43,317
negative 3? Well I would        
just say negativePrimes =       

1404
01:13:43,386 --> 01:13:47,354
prime.map, the only argument    
is a function that does change  

1405
01:13:47,423 --> 01:13:48,989
sign, right? Just like we       
had on the previous slide,      

1406
01:13:49,058 --> 01:13:51,692
change sign. And                
now we're getting a new array,  

1407
01:13:51,761 --> 01:13:56,163
negativePrimes is gonna be      
a new array with -2, -3, -5.    

1408
01:13:56,231 --> 01:13:59,934
You see how I used map there?   
Now, list another example,      

1409
01:14:00,002 --> 01:14:02,770
maybe inverting the primes.     
So I'm gonna propriate          

1410
01:14:02,839 --> 01:14:06,507
the closure, 1.0 divided        
by $0. Now I get 0.5, 0.33,     

1411
01:14:06,575 --> 01:14:09,810
maybe I even want to            
convert it to a string.         

1412
01:14:09,878 --> 01:14:11,946
Perfectly legal, doesn't        
have to be the same type.       

1413
01:14:12,015 --> 01:14:15,516
I can return array of string.   
Now notice the yellow           

1414
01:14:15,584 --> 01:14:18,519
things up there, changed a      
little with each line. You see  

1415
01:14:18,587 --> 01:14:22,256
the first one map parentheses   
the closure. The next one       

1416
01:14:22,325 --> 01:14:25,025
map open parentheses, closed    
parentheses then the closure.   

1417
01:14:25,094 --> 01:14:28,129
And the third one map, no       
parentheses and the closure.    

1418
01:14:28,197 --> 01:14:31,632
Okay, this is using what's      
called trailing closure         

1419
01:14:31,701 --> 01:14:35,670
syntax, okay, we almost always  
use this. The rule here is,     

1420
01:14:35,738 --> 01:14:39,907
if the last argument to         
any function is a closure,      

1421
01:14:39,975 --> 01:14:43,343
you can move the closure        
outside the parenthesis of      

1422
01:14:43,412 --> 01:14:46,981
the arguments. So see in the    
second line, inverted primes?   

1423
01:14:47,049 --> 01:14:50,217
How I moved the closure         
outside? And furthermore,       

1424
01:14:50,286 --> 01:14:52,519
if it's the only argument,      

1425
01:14:52,588 --> 01:14:54,955
then you can just get rid of    
the parentheses entirely.       

1426
01:14:55,023 --> 01:14:57,991
That's the third line, okay.    
And this is just to make our    

1427
01:14:58,060 --> 01:15:00,627
code look nice. So we don't     
have extraneous parenthesis in  

1428
01:15:00,696 --> 01:15:03,364
there that we don't, beccause   
we've got the curly braces,     

1429
01:15:03,433 --> 01:15:05,900
we kind of don't need           
those parentheses. Okay,        

1430
01:15:05,968 --> 01:15:10,204
so you'll see that in iOS when  
an argument to a function       

1431
01:15:10,273 --> 01:15:13,274
is a function, it'll usually    
be the last argument. So        

1432
01:15:13,343 --> 01:15:15,242
that you can move it            
outside if you want.            

1433
01:15:15,311 --> 01:15:16,844
It's optional,                  
you don't have to.              

1434
01:15:16,912 --> 01:15:19,079
All three of those are          
perfectly valid syntax right    

1435
01:15:19,148 --> 01:15:23,417
there. Okay,                    
another cool use of closures,   

1436
01:15:23,485 --> 01:15:27,354
property initialization. What   
if you have a property and      

1437
01:15:27,423 --> 01:15:29,356
you wanna initialize            
it to something but             

1438
01:15:29,425 --> 01:15:32,159
it's not like you just can't    
do one line thing, right.       

1439
01:15:32,227 --> 01:15:35,862
You can't say equals five or    
equals something simple. You    

1440
01:15:35,931 --> 01:15:38,432
need to do two or three lines   
of code to get it initialized.  

1441
01:15:38,501 --> 01:15:42,002
No problem, you're allowed      
to set the property equal to    

1442
01:15:42,071 --> 01:15:45,205
executing a closure. Now that   
closure is automatically        

1443
01:15:45,274 --> 01:15:47,675
going to be a closure that      
takes no arguments and          

1444
01:15:47,744 --> 01:15:51,412
returns the right type to       
initialize that property.       

1445
01:15:51,480 --> 01:15:53,347
So you can do anything you      
want in that closure and        

1446
01:15:53,415 --> 01:15:55,182
just return something           
of the right type. And          

1447
01:15:55,251 --> 01:15:58,652
then you execute it right away  
with open parenthesis, closed   

1448
01:15:58,720 --> 01:16:01,522
parenthesis. See how there's    
the little open parenthesis,    

1449
01:16:01,590 --> 01:16:04,625
closed parenthesis there right  
at the end of the closure?      

1450
01:16:04,694 --> 01:16:06,761
That's just gonna execute       
that closure right there.       

1451
01:16:06,829 --> 01:16:09,830
This is especially cool with    
lazy properties. Because it     

1452
01:16:09,898 --> 01:16:12,433
means, this closure won't be    
executed until someone asks     

1453
01:16:12,502 --> 01:16:16,036
for this property. Okay, so     

1454
01:16:16,105 --> 01:16:18,638
you're combining lazy           
in the closures. So             

1455
01:16:18,707 --> 01:16:22,342
closures really cool for        
initializing properties. Now,   

1456
01:16:22,411 --> 01:16:25,079
one thing about closures        
to be careful of.               

1457
01:16:25,147 --> 01:16:29,483
They do capture their           
surrounding variables.          

1458
01:16:29,552 --> 01:16:32,386
So if I have a closure, it's    
just a function embedded right  

1459
01:16:32,454 --> 01:16:35,156
in my code. If there            
are local variables, or         

1460
01:16:35,224 --> 01:16:37,958
instance variables in the       
class I'm in, or whatever, and  

1461
01:16:38,027 --> 01:16:42,296
I use them in the closure       
it works. And even if that      

1462
01:16:42,365 --> 01:16:45,966
closure sticks around, those    
things still continue to work   

1463
01:16:46,035 --> 01:16:49,936
until the closure goes away.    
What this means, though,        

1464
01:16:50,005 --> 01:16:52,306
since closures are types and    
they can put in arrays and      

1465
01:16:52,375 --> 01:16:56,810
dictionaries, closures          
are reference types.            

1466
01:16:56,879 --> 01:17:01,014
There's only two reference      
types in Swift, classes and     

1467
01:17:01,083 --> 01:17:02,683
closures. So                    
what does that mean?            

1468
01:17:02,752 --> 01:17:05,285
It means this closure gets put  
in the heap if you put it in    

1469
01:17:05,354 --> 01:17:08,856
an array. So that array         
actually has pointers to this   

1470
01:17:08,925 --> 01:17:13,327
closure. Now this is a little   
mind bending. I don't expect    

1471
01:17:13,395 --> 01:17:16,330
you to get this right at the    
top. But it also means that,    

1472
01:17:16,398 --> 01:17:19,934
if you capture variables        
in your closure from your       

1473
01:17:20,002 --> 01:17:22,803
surrounding code, they have     
to go live in the heap too.     

1474
01:17:22,872 --> 01:17:25,505
Because we can't have this      
closure not function, right?    

1475
01:17:25,574 --> 01:17:28,842
Can't if this function has to   
be a function that executes.    

1476
01:17:28,911 --> 01:17:30,644
So here's an example of that.   

1477
01:17:30,713 --> 01:17:33,848
Here I have a local             
variable called ltaue,          

1478
01:17:33,916 --> 01:17:35,382
life the universe and           
everything,                     

1479
01:17:35,451 --> 01:17:38,585
I think that stands for.        
It's set to 42. Okay,           

1480
01:17:38,654 --> 01:17:41,822
and my operation, the closure   
there, says ltuae times $0. So  

1481
01:17:41,891 --> 01:17:47,594
that closure is actually using  
a local variable inside it.     

1482
01:17:47,663 --> 01:17:51,264
Now what happens if I put that  
operation in an array? Okay,    

1483
01:17:51,333 --> 01:17:53,700
and then later go back and      
get it out of the array, and    

1484
01:17:53,769 --> 01:17:56,837
execute it. Well, when it does  
that, ltuae still needs to be   

1485
01:17:56,905 --> 01:18:00,741
there. Because otherwise,       
the closure won't execute. So   

1486
01:18:00,810 --> 01:18:05,079
ltuau, the ltuae gets           
captured into the heap and      

1487
01:18:05,148 --> 01:18:07,681
stays there until               
the closure goes away.          

1488
01:18:07,749 --> 01:18:10,217
Now, this is awesome,           
it all just works magically.    

1489
01:18:10,286 --> 01:18:13,487
You don't have to think about   
it, except in one case, and     

1490
01:18:13,555 --> 01:18:15,522
that's a memory cycle.          

1491
01:18:15,590 --> 01:18:18,391
This can create a memory cycle  
because you might capture       

1492
01:18:18,460 --> 01:18:22,696
the class that array of         
operations is in. Okay,         

1493
01:18:22,764 --> 01:18:26,766
if you capture the class that   
array is of operations in,      

1494
01:18:26,835 --> 01:18:31,605
then this closure has captured  
that class into the heap. And   

1495
01:18:31,674 --> 01:18:35,275
that class through              
its array is captured           

1496
01:18:35,344 --> 01:18:36,877
the closure in the heap. So     

1497
01:18:36,946 --> 01:18:38,912
they're pointing to each        
other through the array,        

1498
01:18:38,981 --> 01:18:41,448
you see? They're creating a     
memory cycle, that closure is   

1499
01:18:41,517 --> 01:18:43,717
keeping the class, the class    
is keeping the closure.         

1500
01:18:43,786 --> 01:18:44,584
They're staying in the heap,    

1501
01:18:44,653 --> 01:18:47,153
they can never leave until      
someone removes that closure    

1502
01:18:47,222 --> 01:18:49,156
from this array,                
for example. So,                

1503
01:18:49,225 --> 01:18:52,592
we can break closure cycles     
like these. We use that thing,  

1504
01:18:52,661 --> 01:18:54,995
I talked about last time,       
unowned. Remember, unowned?     

1505
01:18:55,063 --> 01:18:57,164
When we talked about weak and   
strong and unowned.             

1506
01:18:57,233 --> 01:18:59,266
And I said, I'll tell           
you what unowned is. So         

1507
01:18:59,335 --> 01:19:01,701
I'm gonna put these two         
things together. Unowned and    

1508
01:19:01,770 --> 01:19:04,238
the fact that we can have       
these cycles. In a couple of    

1509
01:19:04,306 --> 01:19:07,007
weeks, I'll talk to you, how    
we break these cycles. Okay,    

1510
01:19:07,076 --> 01:19:09,977
how we can create a closure     
that will not keep              

1511
01:19:10,046 --> 01:19:14,514
something else in. Okay so,     
let's see a demo of closures.   

1512
01:19:14,583 --> 01:19:17,851
I'm gonna improve the method    
index of the one and only face  

1513
01:19:17,920 --> 01:19:21,021
card to be way better. And not  
only am I gonna use closures,   

1514
01:19:21,090 --> 01:19:23,824
I'm gonna go back and use       
extensions to protocols, and    

1515
01:19:23,893 --> 01:19:26,493
I'm gonna tie this all          
together. Okay, so              

1516
01:19:26,562 --> 01:19:30,931
lets do that.                   
Over here, if we remember,      

1517
01:19:31,000 --> 01:19:35,102
our, we'll make it one          
big window here. If we go       

1518
01:19:35,171 --> 01:19:37,838
back to our concentration, all  
right, here's concentration.    

1519
01:19:37,907 --> 01:19:39,973
Remember we had index of        
one and only face card,         

1520
01:19:40,042 --> 01:19:43,343
which, supposedly made          
our code simpler,               

1521
01:19:43,412 --> 01:19:46,213
which it did down here.         
It made this code really        

1522
01:19:46,281 --> 01:19:49,716
beautiful and readable down     
here. But, it actually added    

1523
01:19:49,785 --> 01:19:53,754
quite a bit of code here. But   
this is way more code than you  

1524
01:19:53,822 --> 01:19:56,657
actually need To find           
the index of the oneAndOnly     

1525
01:19:56,725 --> 01:20:00,594
face card, if you use a method  
that takes a closure. Now,      

1526
01:20:00,663 --> 01:20:03,196
the method we're gonna use,     
it's kinda like map,            

1527
01:20:03,265 --> 01:20:07,701
its own collection, it's        
called filter. So what filter   

1528
01:20:07,769 --> 01:20:10,437
does is it goes through every   
item in the collection and      

1529
01:20:10,505 --> 01:20:13,040
executes a function that you    
provide. Filter only has one    

1530
01:20:13,108 --> 01:20:16,810
argument. It's a function.      
That function returns a bool.   

1531
01:20:16,878 --> 01:20:20,246
So it executes that function    
with the argument being each    

1532
01:20:20,315 --> 01:20:23,751
item in the collection.         
If that function returns true,  

1533
01:20:23,820 --> 01:20:26,253
then it puts it in              
a new array, okay, and          

1534
01:20:26,321 --> 01:20:29,089
if it turns false, it doesn't.  
So essentially                  

1535
01:20:29,158 --> 01:20:32,759
filters the collection into an  
array, but only the ones that   

1536
01:20:32,828 --> 01:20:35,195
return true from the function.  
See what I'm saying? So         

1537
01:20:35,264 --> 01:20:37,564
that's why it's called filter.  
Filters the collection,         

1538
01:20:37,633 --> 01:20:40,100
makes an array out of the ones  
that return true. Well,         

1539
01:20:40,169 --> 01:20:43,069
that's great for this, because  
index of oneAndOnly face card.  

1540
01:20:43,138 --> 01:20:45,639
How about I go look at all      
the indexes of the cards and    

1541
01:20:45,707 --> 01:20:49,876
just find the indexes that      
have face up cards? So I just   

1542
01:20:49,945 --> 01:20:52,045
need a function that says       
whether a card's face up and    

1543
01:20:52,114 --> 01:20:56,083
I can do it. So let's do that.  
I'm gonna let index, we'll say  

1544
01:20:56,152 --> 01:21:01,154
the let the face up card        
indices I'll call it, okay,     

1545
01:21:01,223 --> 01:21:05,325
this is gonna be an array. I'm  
gonna let it equal to my card   

1546
01:21:05,394 --> 01:21:09,430
indices. Card indices,          
what type is card indices,      

1547
01:21:09,498 --> 01:21:14,033
anyone remember? Oh I just      
showed you what it was.         

1548
01:21:14,102 --> 01:21:19,039
Right, right? It's accountable  
range of int. It indexes into   

1549
01:21:19,108 --> 01:21:24,144
the cards array. So I'm gonna   
filter those indices by         

1550
01:21:24,213 --> 01:21:26,913
providing a function.           
And it's the only argument, so  

1551
01:21:26,982 --> 01:21:28,449
I don't need any                
parentheses or                  

1552
01:21:28,517 --> 01:21:31,885
anything, I'm just gonna put    
it after. This function just    

1553
01:21:31,954 --> 01:21:35,622
needs to look at the index and  
see if that's a face up card.   

1554
01:21:35,691 --> 01:21:39,726
So that's cards sub the index,  
we'll just use $0,              

1555
01:21:39,794 --> 01:21:44,664
which is the one argumentative  
function, isFaceup. Okay,       

1556
01:21:44,733 --> 01:21:46,800
so that's a Boolean function,   
right here.                     

1557
01:21:46,868 --> 01:21:50,103
This is a Boolean function,     
executed by a closure, right    

1558
01:21:50,172 --> 01:21:53,506
in there that returns true, if  
the card of that index is face  

1559
01:21:53,575 --> 01:21:56,676
up. So, now I've created        
this which is an array,         

1560
01:21:56,745 --> 01:21:59,179
it's an array of array          
indexes by the way.             

1561
01:21:59,248 --> 01:22:01,948
Let's take a look, see.         
Array of array indexes.         

1562
01:22:02,017 --> 01:22:05,819
This type Array.Index,          
remember, we had String.Index,  

1563
01:22:05,887 --> 01:22:09,690
Array.Index, is type aliased    
or just set equal to be int.    

1564
01:22:09,759 --> 01:22:12,225
That's why arrays can           
be indexed by int,              

1565
01:22:12,294 --> 01:22:15,595
cuz their Array.Index is int.   
That's not true for strings.    

1566
01:22:15,664 --> 01:22:19,699
String.Index, unfortunately,    
is not int. Okay, so            

1567
01:22:19,768 --> 01:22:23,437
this is an array of all the     
indices. Now, if this only has  

1568
01:22:23,506 --> 01:22:26,639
one thing in it then we         
have one face up card.          

1569
01:22:26,708 --> 01:22:30,377
We all agree with that?         
So I'm just gonna return here,  

1570
01:22:30,446 --> 01:22:34,914
that if                         
faceUpCardIndices.count ==1,    

1571
01:22:34,983 --> 01:22:41,555
I am going to return            
the faceUpCardIndices.first,    

1572
01:22:41,623 --> 01:22:44,024
first is just a collection      
method that returns the first   

1573
01:22:44,093 --> 01:22:46,960
thing in the collection.        
Otherwise, I'm gonna return     

1574
01:22:47,029 --> 01:22:49,696
nil, because we either          
have zero face up cards or      

1575
01:22:49,765 --> 01:22:52,966
we have more than one, in       
either case, we'll return 0.    

1576
01:22:53,035 --> 01:22:56,770
So I don't need any of this     
stuff right here. Okay,         

1577
01:22:56,839 --> 01:23:00,473
so this is a lot cleaner        
than this whole thing.          

1578
01:23:00,542 --> 01:23:03,310
Everybody agree with that? And  
a little more readable too.     

1579
01:23:03,379 --> 01:23:05,979
Give me all the face            
card indices by filtering       

1580
01:23:06,048 --> 01:23:09,216
the indices to show me the      
ones that are face up. Okay,    

1581
01:23:09,285 --> 01:23:11,618
it kind of reads a little       
better as well, but             

1582
01:23:11,687 --> 01:23:13,586
we can do better                
than this even.                 

1583
01:23:13,655 --> 01:23:16,156
And we're gonna do better       
by creating an extension to     

1584
01:23:16,224 --> 01:23:20,827
a protocol down here. The       
protocol we're gonna extend is  

1585
01:23:20,896 --> 01:23:25,832
collection. So we're gonna add  
a var. Could be a function,     

1586
01:23:25,901 --> 01:23:27,734
but it's gonna be               
a var to collection.            

1587
01:23:27,802 --> 01:23:30,437
So, I'm gonna be adding         
it to string, dictionary,       

1588
01:23:30,506 --> 01:23:33,240
array, all these things.        
And what it's gonna do,         

1589
01:23:33,309 --> 01:23:39,045
it's gonna be the oneAndOnly.   
And it's gonna return           

1590
01:23:39,114 --> 01:23:43,216
the one and only thing in that  
collection, if there's only     

1591
01:23:43,285 --> 01:23:45,953
one thing in the collection or  
it's gonna return nil.          

1592
01:23:46,021 --> 01:23:47,553
Now, what is the type,          

1593
01:23:47,622 --> 01:23:52,325
of oneAndOnly gonna be? Well,   
collection is a generic type.   

1594
01:23:52,394 --> 01:23:55,695
And it has one of its           
generic things as element,      

1595
01:23:55,764 --> 01:23:59,633
which is the type of the thing  
in there. So element is just    

1596
01:23:59,701 --> 01:24:03,303
like a placeholder, right,      
in the array of element.        

1597
01:24:03,371 --> 01:24:06,506
You recognize that? For in      
a generic type, it's the type.  

1598
01:24:06,575 --> 01:24:08,208
And of course I want            
it to be optional.              

1599
01:24:08,277 --> 01:24:10,844
Because I'm only gonna return   
non nil, if there's one and     

1600
01:24:10,912 --> 01:24:14,181
only one thing in this          
collection, this string, or     

1601
01:24:14,249 --> 01:24:15,682
this array, or                  
this dictionary, or             

1602
01:24:15,750 --> 01:24:17,484
this countable range.           

1603
01:24:17,553 --> 01:24:22,088
And here's how I can implement  
it, watch this. Return count    

1604
01:24:22,157 --> 01:24:27,961
== 1? first : nil.              
Now how am I able to do this?   

1605
01:24:28,029 --> 01:24:32,132
Well count is a collection      
method, tells how many things   

1606
01:24:32,200 --> 01:24:37,504
in there. first is a            
collection method, it returns   

1607
01:24:37,572 --> 01:24:41,341
the first thing in there.       
So since these are collection   

1608
01:24:41,410 --> 01:24:44,844
methods, I can use them in the  
implementation of a collection  

1609
01:24:44,913 --> 01:24:50,951
var. Seeing the power here of   
these extensions on protocols.  

1610
01:24:51,019 --> 01:24:54,120
And now, strings, arrays,       
countable ranges,               

1611
01:24:54,189 --> 01:24:58,525
they all implement oneAndOnly.  
So I can go back up here and    

1612
01:24:58,593 --> 01:25:05,165
just return, Return this,       
remember, it's an array         

1613
01:25:05,234 --> 01:25:09,503
of the indices of face up       
cards, dot oneAndOnly.          

1614
01:25:11,239 --> 01:25:16,743
Okay, and I don't even need     
this. Okay, even simpler.       

1615
01:25:16,812 --> 01:25:21,614
By the way,                     
I could absolutely do, let ch   

1616
01:25:21,683 --> 01:25:26,286
= hello.oneAndOnly. Okay,       
now that would return what?     

1617
01:25:26,355 --> 01:25:30,924
What would ch be equal          
to there? Anybody?              

1618
01:25:32,427 --> 01:25:33,493
>> It would be nil,             

1619
01:25:33,562 --> 01:25:37,330
because oneAndOnly returns      
if there's one and only one     

1620
01:25:37,399 --> 01:25:42,769
element and this string has     
five elements. If I did this,   

1621
01:25:42,838 --> 01:25:47,874
what would this return? This    
will return h, the one and      

1622
01:25:47,943 --> 01:25:52,946
only thing in that string.      
So I got that by                

1623
01:25:53,015 --> 01:25:56,917
extending collection, which     
string and array happen to be.  

1624
01:25:56,986 --> 01:25:58,451
What's the type of this,        
by the way? ch,                 

1625
01:25:58,520 --> 01:26:03,557
what do you think its type is?  
It's an optional character.     

1626
01:26:05,427 --> 01:26:09,429
Optional character because      
the elements of a string are    

1627
01:26:09,498 --> 01:26:13,300
characters. And a string is a   
collection of characters. But   

1628
01:26:13,368 --> 01:26:17,537
if I click on it, it's gonna    
say, it's a String.Element.     

1629
01:26:17,606 --> 01:26:21,408
So just like Array.Index        
is type alias to be int,        

1630
01:26:21,476 --> 01:26:25,212
String.Element is type          
alias to be character.          

1631
01:26:25,280 --> 01:26:27,814
So, you have to look in the     
documentation to see that or    

1632
01:26:27,883 --> 01:26:28,981
you just have to know it.       

1633
01:26:29,050 --> 01:26:30,984
But if you're doing your Alt    
clicking, I don't want you      

1634
01:26:31,053 --> 01:26:32,986
to be surprised when you        
see that's not a character.     

1635
01:26:34,756 --> 01:26:39,326
Okay, all right, so a lot of    
things went on in just this     

1636
01:26:39,395 --> 01:26:42,562
short demo here. We used        
the closure right here. And     

1637
01:26:42,631 --> 01:26:46,767
we also extended a protocol     
right here to create this       

1638
01:26:46,835 --> 01:26:49,202
method here. So hopefully you   
understand both of those.       

1639
01:26:49,271 --> 01:26:53,039
If you don't, use Piazza, come  
up and ask me afterwards or     

1640
01:26:53,108 --> 01:26:57,811
whatever. All right,            
see you next time. Oh,          

1641
01:26:57,880 --> 01:26:59,212
wait, sorry one thing,          
let me go back and              

1642
01:26:59,281 --> 01:27:02,182
just show you the coming up.    
Because there is one thing to   

1643
01:27:02,251 --> 01:27:05,852
note here about the coming up.  
Which is that Friday,           

1644
01:27:05,921 --> 01:27:08,088
we were gonna have              
the optional section            

1645
01:27:08,156 --> 01:27:10,991
object persistence, we're not   
gonna do that this Friday.      

1646
01:27:11,060 --> 01:27:12,125
We'll do it in                  
a future Friday,                

1647
01:27:12,194 --> 01:27:14,060
we will do object persistence   
but in a future Friday.         

1648
01:27:14,129 --> 01:27:17,197
So, there's no Friday section   
at all this week. Next week,    

1649
01:27:17,265 --> 01:27:19,666
I will be doing views,          
gestures, multi-touch,          

1650
01:27:19,735 --> 01:27:24,270
multiple MVCs, all that.        
>> For more,                    

1651
01:27:24,339 --> 01:27:26,907
please visit us                 
at Stanford.edu.                

